<!DOCTYPE html>
<html lang="en" dir="ltr">

<head prefix="og: http://ogp.me/ns#">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>ËØëÔΩú2019ÔΩúKernel Probes (Kprobes) ‚Äì Blog</title>
    


  
  <script defer src="/public/js/fuse.min.94c78ad70b02749822921660cf4e9f0b3701bc0680c421afb784a78228de0275.js"></script>



<script src="/public/js/enquire.min.dfb99dee1e029d51d6cfb672d847929890b1585402de17f5ed092edd72a688b4.js"></script>

<script defer src="/public/js/lazysizes.min.31dd6a2d3a1ec0f78a8df007535cf23f03aeb5c70f026e6d6a19dac3b3acc340.js"></script>

<script defer src="/public/js/helper/getParents.min.1618c696be7c98933f9a92677f518b512a74e55bdbb976b09936b4182e93181b.js"></script>

<script defer src="/public/js/helper/fadeinout.min.93a331f96194789a542f33690bbe4f0c102c7e78ffc018217f5a1c33010bad91.js"></script>

<script defer src="/public/js/helper/closest.min.js"></script>
  
<script>
  "use strict";

  
  
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  
  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (search instanceof RegExp) {
        throw TypeError('first argument must not be a RegExp');
      }
      if (start === undefined) { start = 0; }
      return this.indexOf(search, start) !== -1;
    };
  }

  
  Document.prototype.append = Element.prototype.append = function append() {
    this.appendChild(_mutation(arguments));
  };
  function _mutation(nodes) {
    if (!nodes.length) {
      throw new Error('DOM Exception 8');
    } else if (nodes.length === 1) {
      return typeof nodes[0] === 'string' ? document.createTextNode(nodes[0]) : nodes[0];
    } else {
      var
      fragment = document.createDocumentFragment(),
      length = nodes.length,
      index = -1,
      node;

      while (++index < length) {
        node = nodes[index];

        fragment.appendChild(typeof node === 'string' ? document.createTextNode(node) : node);
      }

      return fragment;
    }
  }

  
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    };
  }
  


  document.addEventListener('DOMContentLoaded', function () {
    
    var navCollapseBtn = document.querySelector('.navbar__burger');
    navCollapseBtn ? navCollapseBtn.addEventListener('click', function (e) {
      var navCollapse = document.querySelector('.navbarm__collapse');

      if (navCollapse) {
        var dataOpen = navCollapse.getAttribute('data-open');

        if (dataOpen === 'true') {
          navCollapse.setAttribute('data-open', 'false');
          navCollapse.style.maxHeight = 0;
          navCollapseBtn.classList.remove('is-active');
        } else {
          navCollapse.setAttribute('data-open', 'true');
          navCollapse.style.maxHeight = navCollapse.scrollHeight + "px";
          navCollapseBtn.classList.add('is-active');
        }
      }
    }) : null;
    


    
    var summaryContainer = document.querySelector('.summary__container');
    var searchResult = document.querySelector('.search-result');
    var searchResultCloseBtn = document.querySelector('.search-result__close');
    searchResultCloseBtn ? searchResultCloseBtn.addEventListener('click', function (e) {
      searchResult.setAttribute('data-display', 'none');
      summaryContainer.setAttribute('data-display', 'block');
    }) : null;
    


    
    document.querySelectorAll('.tab') ? 
    document.querySelectorAll('.tab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var tabLinks = elem.querySelectorAll('.tab__link');
      var tabContents = elem.querySelectorAll('.tab__content');
      var ids = [];

      tabLinks && tabLinks.length > 0 ?
      tabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                tabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              tabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    document.querySelectorAll('.codetab') ? 
    document.querySelectorAll('.codetab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var codetabLinks = elem.querySelectorAll('.codetab__link');
      var codetabContents = elem.querySelectorAll('.codetab__content');
      var ids = [];

      codetabLinks && codetabLinks.length > 0 ?
      codetabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                codetabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              codetabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    var gttBtn = document.getElementById("gtt");
    gttBtn.style.display = "none";
    gttBtn.addEventListener('click', function () {
      if (window.document.documentMode) {
        document.documentElement.scrollTop = 0;
      } else {
        scrollToTop(250);
      }
    });

    function scrollToTop(scrollDuration) {
      var scrollStep = -window.scrollY / (scrollDuration / 15);
      var scrollInterval = setInterval(function () {
        if (window.scrollY != 0) {
          window.scrollBy(0, scrollStep);
        }
        else clearInterval(scrollInterval);
      }, 15);
    }

    var scrollFunction = function () {
      if (document.body.scrollTop > 250 || document.documentElement.scrollTop > 250) {
        gttBtn.style.display = "block";
      } else {
        gttBtn.style.display = "none";
      }
    }
    


    
    var expandBtn = document.querySelectorAll('.expand__button');

    for (let i = 0; i < expandBtn.length; i++) {
      expandBtn[i].addEventListener("click", function () {
        var content = this.nextElementSibling;
        if (content.style.maxHeight) {
          content.style.maxHeight = null;
          this.querySelector('svg').classList.add('expand-icon__right');
          this.querySelector('svg').classList.remove('expand-icon__down');
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
          this.querySelector('svg').classList.remove('expand-icon__right');
          this.querySelector('svg').classList.add('expand-icon__down');
        }
      });
    }
    


    
    var lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
    var tocElem = document.querySelector('.toc');
    var tableOfContentsElem = tocElem ? tocElem.querySelector('#TableOfContents') : null;
    var toggleTocElem = document.getElementById('toggle-toc');
    var singleContentsElem = document.querySelector('.single__contents');
    var navbar = document.querySelector('.navbar');
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var expandContents = document.querySelectorAll('.expand__content');
    var boxContents = document.querySelectorAll('.box');
    var notAllowedTitleIds = null;

    
    var tocFolding = JSON.parse("null");
    
    var tocLevels = JSON.parse("null");
    
    if (tocLevels) {
      tocLevels = tocLevels.toString();
    } else {
      tocLevels = "h1, h2, h3, h4, h5, h6";
    }

    
    singleContentsElem && singleContentsElem.querySelectorAll(".tab") ?
    singleContentsElem.querySelectorAll(".tab").forEach(function (elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    expandContents ? expandContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    boxContents ? boxContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    window.onscroll = function () {
      scrollFunction();
      
      var st = window.pageYOffset || document.documentElement.scrollTop;
      if (st > lastScrollTop) { 
        if (st < 250) {
          gttBtn.style.display = "none";
        } else {
          gttBtn.style.display = "block";
        }

        if (st < 45) {
          return null;
        }
        
        if (!navbar.classList.contains('navbar--hide')) {
          navbar.classList.add('navbar--hide');
        } else if (navbar.classList.contains('navbar--show')) {
          navbar.classList.remove('navbar--show');
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }

              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }
              
              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox) {
              tocFlexbox.setAttribute('data-position', '');
              if (!tocFlexbox.classList.contains('hide')) {
                tocFlexbox.classList.add('hide');
              }
            }
            if (tocFlexboxOuter) {
              tocFlexboxOuter.setAttribute('data-position', '');
              if (!tocFlexboxOuter.classList.contains('hide')) {
                tocFlexboxOuter.classList.add('hide');
              }
            }
          }
        }
      } else { 
        if (st < 250) {
          gttBtn.style.display = "none";
        }

        if (navbar.classList.contains('navbar--hide')) {
          navbar.classList.remove('navbar--hide');
        } else if (!navbar.classList.contains('navbar--show')) {
          navbar.classList.add('navbar--show');
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }
              
              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }

              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox && !tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
            if (tocFlexboxOuter && !tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
          
        }

        if (tableOfContentsElem && document.documentElement.scrollTop < 250) {
          if (false === tocFolding) {

          } else {
            tableOfContentsElem.querySelector('ul') ?
              tableOfContentsElem.querySelector('ul').querySelectorAll('li').forEach(function (liElem) {
                liElem.querySelectorAll('ul').forEach(function (ulElem) {
                  ulElem.style.display = 'none';
                });
              }) : null;
          }
        }
      }
      lastScrollTop = st <= 0 ? 0 : st;
    };
  


  
    var localTheme = localStorage.getItem('theme');
    var rootEleme = document.getElementById('root');
    var selectThemeElem = document.querySelectorAll('.select-theme');
    var selectThemeItemElem = document.querySelectorAll('.select-theme__item');

    var setMetaColor = function(themeColor) {
      var metaMsapplicationTileColor = document.getElementsByName('msapplication-TileColor')[0];
      var metaThemeColor = document.getElementsByName('theme-color')[0];
      var metaMsapplicationNavbuttonColor = document.getElementsByName('msapplication-navbutton-color')[0];
      var metaAppleMobileWebAappStatusBarStyle = document.getElementsByName('apple-mobile-web-app-status-bar-style')[0];

      if (themeColor.includes('dark')) {
        metaMsapplicationTileColor.setAttribute('content', '#fcfcfa');
        metaThemeColor.setAttribute('content', '#403E41');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#403E41');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#403E41');
      } else if (themeColor.includes('light')) {
        metaMsapplicationTileColor.setAttribute('content', '#555');
        metaThemeColor.setAttribute('content', '#eee');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee');
      } else if (themeColor.includes('hacker')) {
        metaMsapplicationTileColor.setAttribute('content', '#e3cd26');
        metaThemeColor.setAttribute('content', '#252526');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#252526');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#252526');
      } else if (themeColor.includes('solarized')) {
        metaMsapplicationTileColor.setAttribute('content', '#d3af86');
        metaThemeColor.setAttribute('content', '#51412c');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#51412c');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#51412c');
      } else if (themeColor.includes('kimbie')) {
        metaMsapplicationTileColor.setAttribute('content', '#586e75');
        metaThemeColor.setAttribute('content', '#eee8d5');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee8d5');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee8d5');
      } 
    }
    
    if (localTheme) {
      selectThemeItemElem ? 
      selectThemeItemElem.forEach(function (elem) {
        if (elem.text.trim() === localTheme) {
          elem.classList.add('is-active');
        } else {
          elem.classList.remove('is-active');
        }
      }) : null;

      setMetaColor(localTheme);
    } else {
      setMetaColor(rootEleme.className);
    }

    selectThemeItemElem ? 
    selectThemeItemElem.forEach(function (v, i) {
      v.addEventListener('click', function (e) {
        var selectedThemeVariant = e.target.text.trim();
        localStorage.setItem('theme', selectedThemeVariant);
        setMetaColor(selectedThemeVariant);

        rootEleme.removeAttribute('class');
        rootEleme.classList.add('theme__' + selectedThemeVariant);
        selectThemeElem.forEach(function(rootElem) {
          rootElem.querySelectorAll('a').forEach(function (elem) {
            if (elem.classList) {
              if (elem.text.trim() === selectedThemeVariant) {
                if (!elem.classList.contains('is-active')) {
                  elem.classList.add('is-active');
                }
              } else {
                if (elem.classList.contains('is-active')) {
                  elem.classList.remove('is-active');
                }
              }
            }
          });
        });

        if (window.mermaid) {
          if (selectedThemeVariant === "dark" || selectedThemeVariant === "hacker") {
            mermaid.initialize({ theme: 'dark' });
            location.reload();
          } else {
            mermaid.initialize({ theme: 'default' });
            location.reload();
          }
        }

        var utterances = document.getElementById('utterances');
        if (utterances) {
          utterances.querySelector('iframe').contentWindow.postMessage({
            type: 'set-theme',
            theme: selectedThemeVariant === "dark" || selectedThemeVariant === "hacker" ? 'photon-dark' : selectedThemeVariant === 'kimbie' ? 'github-dark-orange' : 'github-light',
          }, 'https://utteranc.es');
        }

        var twitterCards = document.querySelectorAll('.twitter-timeline');
        if (twitterCards) {
          window.postMessage({
            type: 'set-twitter-theme',
            theme: selectedThemeVariant === 'light' || selectedThemeVariant === 'solarized' ? 'light' : 'dark',
          });
        }
      });
    }) : null;
  


  
    
    var baseurl = JSON.parse("\"https://jayce.github.io/public/\"");
    
    var permalink = JSON.parse("\"https://jayce.github.io/public/posts/trace/kernel-kprobes/\"");
    
    var langprefix = JSON.parse("\"\"");
    var searchResults = null;
    var searchMenu = null;
    var searchText = null;
    
    
    var enableSearch = JSON.parse("true");
    
    var enableSearchHighlight = JSON.parse("true");
    
    var searchResultPosition = JSON.parse("null");
    
    var sectionType = JSON.parse("\"posts\"");
    
    var kind = JSON.parse("\"page\"");
    
    var fuse = null;

    if (enableSearch) {
      (function initFuse() {
        var xhr = new XMLHttpRequest();
        if (sectionType === "publication" && kind !== "page") {
          xhr.open('GET', permalink + "index.json");
        } else {
          xhr.open('GET', baseurl + langprefix + "/index.json");
        }
        
        xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
        xhr.onload = function () {
          if (xhr.status === 200) {
            fuse = new Fuse(JSON.parse(xhr.response.toString('utf-8')), {
              keys: sectionType.includes('publication') ? ['title', 'abstract'] : ['title', 'description', 'content'],
              includeMatches: enableSearchHighlight,
              shouldSort: true,
              threshold: 0.4,
              location: 0,
              distance: 100,
              maxPatternLength: 32,
              minMatchCharLength: 1,
            });
            window.fuse = fuse;
          }
          else {
            console.error('[' + xhr.status + ']Error:', xhr.statusText);
          }
        };
        xhr.send();
      })();
    }

    function makeLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      
      var a = document.createElement('a');
      a.innerHTML = obj.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.permalink);

      var descDiv = document.createElement('div');
      descDiv.setAttribute('class', 'search-result__item--desc');
      if (obj.description) {
        descDiv.innerHTML = obj.description;
      } else if (obj.content) {
        descDiv.innerHTML = obj.content.substring(0, 225);
      }
      
      li.appendChild(a);
      li.appendChild(descDiv);
      ulElem.appendChild(li);
    }

    function makeHighlightLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      var descDiv = null;

      var a = document.createElement('a');
      a.innerHTML = obj.item.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.item.uri);

      if (obj.matches && obj.matches.length) {
        for (var i = 0; i < obj.matches.length; i++) {
          if ('title' === obj.matches[i].key) {
            a = document.createElement('a');
            a.innerHTML = generateHighlightedText(obj.matches[i].value, obj.matches[i].indices);
            a.setAttribute('class', 'search-result__item--title');
            a.setAttribute('href', obj.item.uri);
          }
          
          if ('description' === obj.matches[i].key) {
            descDiv = document.createElement('div');
            descDiv.setAttribute('class', 'search-result__item--desc');
            descDiv.innerHTML = generateHighlightedText(obj.item.description, obj.matches[i].indices);
          } else if ('content' === obj.matches[i].key) {
            if (!descDiv) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = generateHighlightedText(obj.item.content.substring(0, 150), obj.matches[i].indices);
            }
          } else {
            if (obj.item.description) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.description;
            } else {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.content.substring(0, 150);
            }
          }
        }

        li.appendChild(a);
        if (descDiv) {
          li.appendChild(descDiv);
        }
        if (li) {
          ulElem.appendChild(li);
        }
      }
    }

    function renderSearchResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');
      
      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          a.setAttribute('href', result.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.title;
          titleDiv.setAttribute('class', 'menu-item__title');

          var descDiv = document.createElement('div');
          descDiv.setAttribute('class', 'menu-item__desc');
          if (result.description) {
            descDiv.innerHTML = result.description;
          } else if (result.content) {
            descDiv.innerHTML = result.content.substring(0, 150);
          }

          li.appendChild(titleDiv);
          li.appendChild(descDiv);
          ul.appendChild(a);
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      
      searchMenu.appendChild(ul);
    }

    function renderSearchHighlightResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');

      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'menu-item__title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'menu-item__desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      searchMenu.appendChild(ul);
    }

    function renderSearchResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var content = document.createElement('div');
      content.setAttribute('class', 'mobile-search__content');

      if (results.length > 0) {
        results.forEach(function (result) {
          var item = document.createElement('a');
          item.setAttribute('href', result.uri);
          item.innerHTML = '<div class="mobile-search__item"><div class="mobile-search__item--title">üìÑ ' + result.title + '</div><div class="mobile-search__item--desc">' + (result.description ? result.description : result.content) + '</div></div>';
          content.appendChild(item);
        });
      } else {
        var item = document.createElement('span');
        content.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(content);      
    }

    function renderSearchHighlightResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var ul = document.createElement('div');
      ul.setAttribute('class', 'mobile-search__content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.appendChild(li);
          li.setAttribute('class', 'mobile-search__item');

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'mobile-search__item--title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'mobile-search__item--desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var item = document.createElement('span');
        ul.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(ul);
    }

    function generateHighlightedText(text, regions) {
      if (!regions) {
        return text;
      }

      var content = '', nextUnhighlightedRegionStartingIndex = 0;

      regions.forEach(function(region) {
        if (region[0] === region[1]) {
          return null;
        }
        
        content += '' +
          text.substring(nextUnhighlightedRegionStartingIndex, region[0]) +
          '<span class="search__highlight">' +
            text.substring(region[0], region[1] + 1) +
          '</span>' +
        '';
        nextUnhighlightedRegionStartingIndex = region[1] + 1;
      });

      content += text.substring(nextUnhighlightedRegionStartingIndex);

      return content;
    };

    var searchElem = document.getElementById('search');
    var searchMobile = document.getElementById('search-mobile');
    var searchResultsContainer = document.getElementById('search-results');

    searchElem ?
    searchElem.addEventListener('input', function(e) {
      if (!e.target.value | window.innerWidth < 770) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      
      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }
        
        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function(item) {
          item.addEventListener('mousedown', function(e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    searchElem ? 
    searchElem.addEventListener('blur', function() {
      if (window.innerWidth < 770) {
        return null;
      }
      searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
    }) : null;

    searchElem ? 
    searchElem.addEventListener('click', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }
      if (!e.target.value) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);

      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else{
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }

        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function (item) {
          item.addEventListener('mousedown', function (e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    var searchMenuElem = document.getElementById("search-menu");
    var activeItem = document.querySelector('#search-menu .dropdown-item.is-active');
    var activeIndex = null;
    var items = null;
    var searchContainerMaxHeight = 350;

    searchElem ? 
    searchElem.addEventListener('keydown', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }

      if (e.key === 'Escape') {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      }

      var items = document.querySelectorAll('#search-menu .dropdown-item');
      var keyCode = e.which || e.keyCode;

      if (!items || !items.length) {
        return null;
      }
      
      if (e.key === 'ArrowDown' || keyCode === 40) {
        if (activeIndex === null) {
          activeIndex = 0;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === items.length - 1 ? 0 : activeIndex + 1;
        }
        items[activeIndex].classList.add('is-active');

        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel > 0) {
          document.querySelector(".search-content").scrollTop += items[activeIndex].getBoundingClientRect().height;
        } else if (activeIndex === 0) {
          document.querySelector(".search-content").scrollTop = 0;
        }
      } else if (e.key === 'ArrowUp' || keyCode === 38) {
        if (activeIndex === null) {
          activeIndex = items.length - 1;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === 0 ? items.length - 1 : activeIndex - 1;
        }
        items[activeIndex].classList.add('is-active');
        
        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel < 0) {
          document.querySelector(".search-content").scrollTop -= items[activeIndex].getBoundingClientRect().height;
        } else {
          document.querySelector(".search-content").scrollTop = overflowedPixel + items[activeIndex].getBoundingClientRect().height;
        }
      } else if (e.key === 'Enter' || keyCode === 13) {
        if (items[activeIndex] && items[activeIndex].getAttribute('href')) {
          location.href = items[activeIndex].getAttribute('href');
        }
      } else if (e.key === 'Escape' || keyCode === 27) {
        e.target.value = null;
        if (searchResults) {
          searchResults.classList.remove('is-active');
        }
      }
    }) : null;

    searchMobile ? 
    searchMobile.addEventListener('input', function(e) {
      if (!e.target.value) {
        let wrap = document.getElementById('search-mobile-results');
        while (wrap.firstChild) {
          wrap.removeChild(wrap.firstChild);
        }
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      renderSearchResultsMobile(searchText, results);
      if (enableSearchHighlight) {
        renderSearchHighlightResultsMobile(searchText, results);
      } else {
        renderSearchResultsMobile(searchText, results);
      }
    }) : null;
  


  
    var mobileSearchInputElem = document.querySelector('#search-mobile');
    var mobileSearchClassElem = document.querySelector('.mobile-search');
    var mobileSearchBtnElem = document.querySelector('#mobileSearchBtn');
    var mobileSearchCloseBtnElem = document.querySelector('#search-mobile-close');
    var mobileSearchContainer = document.querySelector('#search-mobile-container');
    var mobileSearchResultsElem = document.querySelector('#search-mobile-results');
    var htmlElem = document.querySelector('html');

    if (mobileSearchClassElem) {
      mobileSearchClassElem.style.display = 'none';
    }

    mobileSearchBtnElem ? 
    mobileSearchBtnElem.addEventListener('click', function () {
      if (mobileSearchContainer) {
        mobileSearchContainer.style.display = 'block';
      }

      if (mobileSearchInputElem) {
        mobileSearchInputElem.focus();
      }

      if (htmlElem) {
        htmlElem.style.overflowY = 'hidden';
      }
    }) : null;

    mobileSearchCloseBtnElem ? 
    mobileSearchCloseBtnElem.addEventListener('click', function() {
      if (mobileSearchContainer) {
        mobileSearchContainer.style.display = 'none';
      }

      if (mobileSearchInputElem) {
        mobileSearchInputElem.value = '';
      }
      
      if (mobileSearchResultsElem) {
        while (mobileSearchResultsElem.firstChild) {
          mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
        }
      }

      if (htmlElem) {
        htmlElem.style.overflowY = 'visible';
      }
    }) : null;

    mobileSearchInputElem ?
    mobileSearchInputElem.addEventListener('keydown', function(e) {
      var keyCode = e.which || e.keyCode;
      if (e.key === 'Escape' || keyCode === 27) {
        if (mobileSearchContainer) {
          mobileSearchContainer.style.display = 'none';
        }
        
        if (mobileSearchInputElem) {
          mobileSearchInputElem.value = '';
        }

        if (mobileSearchResultsElem) {
          while (mobileSearchResultsElem.firstChild) {
            mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
          }
        }
        if (htmlElem) {
          htmlElem.style.overflowY = 'visible';
        }
      }
    }) : null;
  


  
    function renderSearchResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');
      
      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }

    function renderSearchHighlightResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');

      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeHighlightLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }
  
  });
</script>    
    


<link rel="stylesheet" href="/public/css/main.min.css">


    
<meta name="description" content="" />


<meta name="keywords" content="kprobe,trace">

<meta name="created" content="2020-05-19T11:03:35&#43;0800">
<meta name="modified" content="2020-05-19T11:03:35&#43;0800">
<meta property="article:published_time" content="2020-05-19T11:03:35&#43;0800">

<meta name="author" content="jayce">


<meta property="og:site_name" content="Blog">
<meta property="og:title" content="ËØëÔΩú2019ÔΩúKernel Probes (Kprobes)">
<meta property="og:url" content="https://jayce.github.io/public/posts/trace/kernel-kprobes/">
<meta property="og:type" content="article">
<meta property="og:description" content="">

<meta name="generator" content="Hugo 0.68.3" />
<meta name="msapplication-TileColor" content="#fff">

<meta name="theme-color" content="#fff">

<meta name="msapplication-navbutton-color" content="#fff">

<meta name="apple-mobile-web-app-status-bar-style" content="#fff">

<link rel="canonical" href="https://jayce.github.io/public/posts/trace/kernel-kprobes/">

<link rel="manifest" href="/public/manifest.json">

  <link rel="apple-touch-icon" sizes="57x57" href="/public/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/public/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/public/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/public/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/public/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/public/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/public/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/public/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/public/favicon/android-icon-512x512.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/public/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/public/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/public/favicon/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">


    <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "headline": "ËØëÔΩú2019ÔΩúKernel Probes (Kprobes)",
    "datePublished": "2020-05-19T11:03:35+08:00",
    "dateModified": "2020-05-19T11:03:35+08:00",
    "url" : "https://jayce.github.io/public/posts/trace/kernel-kprobes/",
    "description": "ËØëËÄÖÂ∫è ËøôÁØáÊñáÁ´†ÁøªËØëËá™ Linux ÂÜÖÊ†∏Ê∫êÁ†ÅÊ†ë‰∏≠ÁöÑ kprobes.txt Êñá‰ª∂ÔºåÊ≠§Êñá‰ª∂ÊèèËø∞‰∫Ü Kprobes ÁöÑÊ¶ÇÂøµ„ÄÅÂ∑•‰ΩúÂéüÁêÜ„ÄÅÈôêÂà∂Á≠âÂÜÖÂÆπ„ÄÇÂõ†‰∏∫Êñá‰ª∂ÁöÑÊúÄÂêé‰∏ÄÊ¨°Êèê‰∫§ÊòØÂú® 2019 Âπ¥ÔºåÊâÄ‰ª•ÊñáÁ´†Ê†áÈ¢ò‰∏≠ÁöÑÂπ¥‰ªΩ",
    "keywords": ["kprobe","trace"],
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://jayce.github.io/public/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Blog",
      "url": "https://jayce.github.io/public/"
    }
  }
</script>

    
  
  







    
</head>

<body id="root" class="theme__light">
    <script>
        var localTheme = localStorage.getItem('theme');
        if (localTheme) {
            document.getElementById('root').className = 'theme__' + localTheme;
        }
    </script>
    <div id="container">
        





        <div class="wrapper" data-type="posts" data-kind="page">
            <nav class="navbar" role="navigation" aria-label="main navigation" data-dir="ltr">
  <div class="navbar__brand">
    
    <a href="/public/" title="Home" rel="home" class="navbar__logo-link">
      <img src="/public/logo.png" alt="Home" class="navbar__logo">
    </a>
    
    
      <a href="/public/" title="Home" rel="home" class="navbar__title-link">
        <h6 class="navbar__title">Jayce</h6>
      </a>
    
  </div>

  
<div class="theme theme-mobile" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" style="" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          dark
        </a>
        
      
    </div>
  </div>
</div>


<div id="mobileSearchBtn" class="mobile-search__btn" data-ani="true">
  <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
</div>

<div id="search-mobile-container" class="mobile-search hide" data-dir="ltr">
  <div class="mobile-search__top">
    <input id="search-mobile" type="text" aria-label="Mobile Search" placeholder="Search" class="mobile-search__top--input"/>
    <div id="search-mobile-close" class="mobile-search__top--icon">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path opacity=".87" fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.59-13L12 10.59 8.41 7 7 8.41 10.59 12 7 15.59 8.41 17 12 13.41 15.59 17 17 15.59 13.41 12 17 8.41z"/></svg>
    </div>
  </div>
  <div id="search-mobile-results" class="mobile-search__body">
    
  </div>
</div>


<a role="button" class="navbar__burger" aria-label="menu" aria-expanded="false"
  data-ani="true">
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
</a>
<div class="navbarm__collapse" data-open="false">
  <ul dir="ltr">
    
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/public/about">about</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/public/archive">archive</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item active">
          <a href="/public/posts">posts</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="https://github.com/jayce">Github</a>
        </li>
      
      
    

    
  </ul>
</div>
  <div class="navbar__menu">
  
<div class="theme" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          dark
        </a>
        
      
    </div>
  </div>
</div>

  
  
  
  
  
  
  
  <a href="/public/about" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">about</a>
  
  
  
  
  
  
  
  <a href="/public/archive" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">archive</a>
  
  
  
  
  
  
  
  <a href="/public/posts" class="navbar__menu-item navbar__slide-down active" dir="ltr" data-ani="true">posts</a>
  
  
  
  
  
  
  
  <a href="https://github.com/jayce" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">Github</a>
  
  
</div>
</nav>
            
            

<main class="single__main main-main">
  
    <nav class="breadcrumb hide" aria-label="breadcrumbs">
  <script>document.querySelector('.breadcrumb').classList.remove('hide')</script>
  <ol>
    
  
  
  
  
  
  <li >
    
      <a href="https://jayce.github.io/public/" class="capitalize">Blog</a>
    
  </li>
  
  
  <li >
    
      <a href="https://jayce.github.io/public/posts/" class="capitalize">Posts</a>
    
  </li>
  
  
  <li  class="is-active" >
    
      <span>ËØëÔΩú2019ÔΩúKernel Probes (Kprobes)</span>
    
  </li>
  
  </ol>
  
</nav>
  
  
  <div class="single ">
    <div class="single__nojs">This page looks best with JavaScript enabled</div>
    <script>document.querySelector('.single').classList.remove('hide'); document.querySelector('.single__nojs').classList.add('hide');</script>
    <h2 class="single__title" data-ani="true">ËØëÔΩú2019ÔΩúKernel Probes (Kprobes)</h2>
    <div class="single__meta">
      
<div class="single__infos">
  <time class="single__info" title="Written At">üìÖ&nbsp;May 19, 2020 </time>
  
  &nbsp;&middot;&nbsp; <span class="single__info" title="Reading Time"> ‚òï&nbsp;18&nbsp;min read </span>
  
  <span class="single__info">
    
  </span>
</div>
      
<ul class="single__tags caption">
  
  üè∑Ô∏è
  

  <li><a href="https://jayce.github.io/public/tags/trace/" class="single__tag" title="trace">#trace</a></li>

  <li><a href="https://jayce.github.io/public/tags/kprobe/" class="single__tag" title="kprobe">#kprobe</a></li>

</ul>
    </div>
    <article class="single__contents" data-dir="ltr" data-ani="true">
      
      <!--
## ÂØπ‰∫éÊñá‰∏≠‰∏Ä‰∫õÁñëÊÉëÔºö**
* trap ÊÄé‰πàÁêÜËß£ÔºüÈô∑Èò±ÔºüË∞ÉËØïÔºüÊçïÊçâÔºü
* notifier_call_chain Êú∫Âà∂Ôºü
* routine ÁøªËØë‰∏∫ÂáΩÊï∞ÊàñËÄÖÁ®ãÂ∫è
* debug ÁøªËØë‰∏∫Ë∞ÉËØï
* probepoint ÁøªËØë‰∏∫Êé¢ÊµãÁÇπ
* Êü•Êü•‰ª• TOC ‰Ωú‰∏∫ÂáΩÊï∞Ë∞ÉÁî®ÁöÑÊû∂ÊûÑÔºåÂèäÂÖ∂ÂéüÁêÜ
* CPU Â¶Ç‰ΩïÂå∫ÂàÜ‰∫åËøõÂà∂‰∏≠ÁöÑÊåá‰ª§ÂíåÊï∞ÊçÆÔºåÊàñËÄÖËØ¥ÊòØÂèØÊâßË°åÊñá‰ª∂Â¶Ç‰ΩïÂ≠òÂÇ®Êåá‰ª§‰ª•ÂèäÊï∞ÊçÆÁöÑÔºü
* Êåá‰ª§‰∏éÂáΩÊï∞ÊÄé‰πàÂØπÂ∫îÔºüÁºñËØëÂéüÁêÜÔºü
-->
<h2 id="ËØëËÄÖÂ∫è">ËØëËÄÖÂ∫è</h2>
<p>ËøôÁØáÊñáÁ´†ÁøªËØëËá™ Linux ÂÜÖÊ†∏Ê∫êÁ†ÅÊ†ë‰∏≠ÁöÑ <a href="https://github.com/torvalds/linux/blob/master/Documentation/kprobes.txt">kprobes.txt</a> Êñá‰ª∂ÔºåÊ≠§Êñá‰ª∂ÊèèËø∞‰∫Ü Kprobes ÁöÑÊ¶ÇÂøµ„ÄÅÂ∑•‰ΩúÂéüÁêÜ„ÄÅÈôêÂà∂Á≠âÂÜÖÂÆπ„ÄÇÂõ†‰∏∫Êñá‰ª∂ÁöÑÊúÄÂêé‰∏ÄÊ¨°Êèê‰∫§ÊòØÂú® 2019 Âπ¥ÔºåÊâÄ‰ª•ÊñáÁ´†Ê†áÈ¢ò‰∏≠ÁöÑÂπ¥‰ªΩ‰πüÂ∞±ÊòØÊåáËøô‰∏™ÊÑèÊÄùÁöÑ„ÄÇ</p>
<p>‰∏ãÈù¢ÁöÑË°®Ê†ºÊòØÂØπÂÖ≥ÈîÆËØçÁöÑ‰∏ÄÁÇπËß£ÈáäÔºåÊ¶ÇÂøµÂÖ∂ÂÆûÂ∞±ËøôÂá†‰∏™„ÄÇ</p>
<table>
<thead>
<tr>
<th>ÂÖ≥ÈîÆËØç</th>
<th>Ëß£Èáä</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kprobes</td>
<td>ÊåáÁöÑÊòØÂÜÖÊ†∏ÁöÑÊé¢ÊµãÊú∫Âà∂„ÄÅÊ°ÜÊû∂Ôºå‰æùËµñ‰∫éÁ°¨‰ª∂ÁöÑÁâπÂÆöÂäüËÉΩÂÆûÁé∞ÁöÑÔºåÊØîÂ¶Ç int3 Êåá‰ª§</td>
</tr>
<tr>
<td>kprobe</td>
<td>ÊåáÁöÑÊòØ Kprobes ÁöÑÂØπË±°ÊàñÁªìÊûÑ‰ΩìÔºåÂÖ≥ËÅîÊé¢ÊµãÁÇπÂíåÊé¢Èíà</td>
</tr>
<tr>
<td>probepoint</td>
<td><strong>Êé¢ÊµãÁÇπ</strong>Ôºå‰∏Ä‰∏™ÂèØÁî®‰∫éËßÇÂØü„ÄÅÁõëËßÜÁõÆÁöÑÁöÑÂÖ∑‰Ωì‰ΩçÁΩÆÔºåÊØîÂ¶ÇÔºö‰∏Ä‰∏™ÂáΩÊï∞ÁöÑÂÖ•Âè£„ÄÅËøîÂõûÂú∞ÂùÄ</td>
</tr>
<tr>
<td>probe</td>
<td><strong>Êé¢Èíà</strong>ÔºåÂú®Êé¢ÊµãÁÇπÂÅöÂÖ∑‰Ωì‰∫ãÊÉÖÁöÑÂØπË±°ÔºåÊØîÂ¶ÇÔºöÂàÜÊûê„ÄÅËøΩË∏™</td>
</tr>
</tbody>
</table>
<p><strong>Â¶ÇÊûúÁî®‰∏ÄÂè•ËØùËß£Èáä Kprobes ÂéüÁêÜÂ∞±ÊòØ</strong>ÔºöKprobes Âú®Êé¢ÊµãÁÇπ‰∏äÊ≥®ÂÜå‰∫Ü‰∏Ä‰∫õÊé¢ÈíàÔºåÂΩì CPU ÊâßË°åÂà∞Êé¢ÊµãÁÇπÁöÑÊó∂ÂÄô Kprobes ‰ºöË∞ÉÁî®ÊâÄÊúâÁõ∏ÂÖ≥Êé¢ÈíàÁöÑÂõûË∞ÉÂáΩÊï∞„ÄÇCPU ÊòØÊÄé‰πà‰ªéÊâßË°åÊµÅËΩ¨Âà∞ Kprobes ÁöÑÂë¢Ôºü</p>
<p><strong>Ê≥®ÔºöÂõ†‰∏∫Ê∞¥Âπ≥ÊúâÈôêÔºåÊñá‰∏≠ÈöæÂÖçÂ≠òÂú®ÈÅóÊºèÊàñËÄÖÈîôËØØÁöÑÂú∞Êñπ„ÄÇÂ¶ÇÊúâÁñëÈóÆÔºåÂª∫ËÆÆÁõ¥Êé•ÈòÖËØªÂéüÊñá„ÄÇ</strong></p>
<hr />
<!--
Concepts: Kprobes and Return Probes
===================================

Kprobes `enables you to dynamically break into` any kernel `routine` and
collect debugging and performance information `non-disruptively`. You
can trap at almost any kernel code address [1]_, specifying a handler
routine to be `invoked` when the breakpoint is hit.

.. [1] some parts of the kernel code can not be trapped, see

       :ref:`kprobes_blacklist`)
-->
<h2 id="Ê¶ÇÂøµ-kprobes-Âíå-return-probes">Ê¶ÇÂøµÔºö Kprobes Âíå Return Probes</h2>
<p>Kprobes ËÉΩÂ§üËÆ©‰Ω†Âä®ÊÄÅÁöÑ‰ªãÂÖ•ÂÜÖÊ†∏ÁöÑ‰ªªÊÑèÂáΩÊï∞Ôºå‰∏îÊó†‰∏≠Êñ≠ÁöÑÊî∂ÈõÜË∞ÉËØïÂíåÊÄßËÉΩ‰ø°ÊÅØ„ÄÇÂü∫Êú¨‰∏äÔºå‰Ω†ÂèØ‰ª•ÊçïËé∑ÂÜÖÊ†∏ÁöÑ‰ªªÊÑèÂú∞ÂùÄ<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>ÔºåÊåáÂÆö‰∏Ä‰∏™Âú®Êñ≠ÁÇπÂëΩ‰∏≠ÂÄôË∞ÉÁî®ÂõûË∞ÉÂáΩÊï∞„ÄÇ</p>
<!--
There are currently two types of probes: kprobes, and kretprobes
(also called return probes).  A kprobe can be inserted on `virtually`
any `instruction` in the kernel.  A return probe `fires` when a specified
function returns.
-->
<p>ÁõÆÂâçÔºåÊé¢ÈíàÊúâ‰∏§ÁßçÁ±ªÂûãÔºökprobes ÔºåkretprobesÔºà‰πüË¢´Áß∞‰∏∫ <code>return</code> Êé¢ÈíàÔºâ„ÄÇÂü∫Êú¨‰∏äÔºå kprobe ÂèØ‰ª•ÂÆâÊèíÂà∞‰ªªÊÑèÊåá‰ª§‰∏ä„ÄÇÂΩì‰∏Ä‰∏™ÊåáÂÆöÁöÑÂáΩÊï∞ËøîÂõûÊó∂Ëß¶Âèë <code>return</code> Êé¢Èíà„ÄÇ</p>
<!--
In the typical case, Kprobes-based `instrumentation` is packaged as
a kernel module.  The module‚Äôs init function installs (‚Äúregisters‚Äù)
one or more probes, and the exit function unregisters them.  A
`registration` function such as register_kprobe() specifies where
the probe is to be inserted and what handler is to be called when
the probe is hit.
-->
<p>ÈÄöÂ∏∏ÔºåÂü∫‰∫é Kprobes ÁöÑÊé¢ÊµãÂ∑•ÂÖ∑Ë¢´ÊâìÂåÖÊàê‰∫Ü‰∏Ä‰∏™ÂÜÖÊ†∏Ê®°Âùó„ÄÇÊ®°ÂùóÁöÑÂàùÂßãÂåñÂáΩÊï∞‰ºöÂÆâË£ÖÔºàÊ≥®ÂÜåÔºâ‰∏Ä‰∏™ÊàñÂ§ö‰∏™Êé¢ÈíàÔºåËÄåÊ®°ÂùóÁöÑÂç∏ËΩΩÂáΩÊï∞‰ºöÊ≥®ÈîÄÂÆÉ‰ª¨„ÄÇ <code>register_kprobe()</code> Ê≥®ÂÜåÂáΩÊï∞ÊåáÊòéÊé¢ÈíàË¶ÅÊèíÂÖ•Âà∞‰ªÄ‰πà‰ΩçÁΩÆÔºåÊé¢ÈíàÂëΩ‰∏≠ÁöÑÊó∂ÂÄôË¶ÅË∞ÉÁî®‰ªÄ‰πàÊ†∑ÁöÑÂáΩÊï∞„ÄÇ</p>
<!--
There are also `register_/unregister_*probes()` functions for `batch`
registration/unregistration of a group of `*probes`. These functions
can `speed up` unregistration process when you have to unregister
a lot of probes at once.
-->
<p>‰πüÊúâ‰∏Ä‰∫õÁî®Êù•ÊâπÈáèÊ≥®ÈîÄÊàñÊ≥®ÂÜå‰∏ÄÁªÑÊé¢ÈíàÁöÑ <code>register_/unregister_*probes()</code> ÂáΩÊï∞„ÄÇÂú®ÂøÖÈ°ª‰∏ÄÊ¨°ÊÄßÊ≥®ÈîÄÂ§ßÈáèÊé¢ÈíàÁöÑÊó∂ÂÄôÔºåËøô‰∫õÂáΩÊï∞ÂèØ‰ª•Âä†Âø´Ê≥®ÈîÄËøáÁ®ã„ÄÇ</p>
<!--
The next four subsections explain how the different types of
probes work and how jump optimization works.  They explain certain
things that you‚Äôll need to know in order to make the best use of
Kprobes ‚Äî e.g., the difference between a pre_handler and
a post_handler, and how to use the maxactive and nmissed fields of
a kretprobe.  But if you‚Äôre in a hurry to start using Kprobes, you
can skip ahead to :ref:`kprobes_archs_supported`.
-->
<p>Êé•‰∏ãÊù•ÁöÑÂõõ‰∏™Â∞èËäÇ‰ºöËß£Èáä‰∏çÂêåÁ±ªÂûãÁöÑÊé¢ÈíàÂèäË∑≥ËΩ¨‰ºòÂåñÊòØÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑ„ÄÇËøô‰∫õÂÜÖÂÆπËÆ≤‰∫Ü‰∏Ä‰∫õÂøÖÈ°ªË¶ÅÁü•ÈÅìÁöÑ‰∫ãÈ°πÔºå‰ª•‰æøÂÖÖÂàÜÂà©Áî® Kprobes Ôºå‰æãÂ¶ÇÔºö <code>pre_handler</code> ‰∏é <code>post_handler</code> ‰πãÈó¥ÁöÑÂå∫Âà´Ôºå‰ª•ÂèäÂ¶Ç‰Ωï‰ΩøÁî® kretprobes ÁöÑ <code>maxactive</code> „ÄÅ <code>nmissed</code> Â≠óÊÆµ„ÄÇ‰∏çËøáÔºåÂÅáÂ¶Ç‰Ω†ÊÉ≥È©¨‰∏äËØïËØï Kprobes ÁöÑËØùÔºåÂèØ‰ª•Áõ¥Êé•Ë∑≥Ëá≥[##ÊîØÊåÅÁöÑÊû∂ÊûÑ]Á´†ËäÇ„ÄÇ</p>
<!--
## How Does a Kprobe Work?
When a kprobe is registered, Kprobes `makes a copy of` the probed
`instruction` and replaces the first byte(s) of the probed instruction
with a breakpoint instruction (e.g., int3 on i386 and x86_64).
-->
<h3 id="kprobe-Â¶Ç‰ΩïÂ∑•‰Ωú">Kprobe Â¶Ç‰ΩïÂ∑•‰ΩúÔºü</h3>
<p>Kprobes Âú®Ê≥®ÂÜå‰∫Ü‰∏Ä‰∏™ kprobe ÂêéÔºåÂ§çÂà∂Ë¢´Êé¢ÊµãÁöÑÊåá‰ª§ÔºåÂπ∂‰∏îÊääË¢´Êé¢ÊµãÊåá‰ª§ÁöÑÁ¨¨‰∏Ä‰∏™Â≠óËäÇÊõøÊç¢‰∏∫Êñ≠ÁÇπÊåá‰ª§Ôºà‰æãÂ¶ÇÔºöÂú® i386„ÄÅx86_64 Âπ≥Âè∞‰∏äÁöÑ <code>int3</code>Ôºâ„ÄÇ</p>
<!--
When a CPU hits the breakpoint instruction, a trap `occurs`, the CPU‚Äôs
registers are saved, and control passes to Kprobes via the
notifier_call_chain `mechanism`.  Kprobes executes the ‚Äúpre_handler‚Äù
`associated with` the kprobe, passing the handler the addresses of the
kprobe struct and the saved registers.
-->
<p>Âú® CPU ÂëΩ‰∏≠Êñ≠ÁÇπÊåá‰ª§Êó∂Ôºå‰ºöÂèëÁîü‰∏Ä‰∏™ <code>trap</code>ÔºåCPU ÁöÑÂØÑÂ≠òÂô®‰ºöË¢´‰øùÂ≠òÔºåËÄåÊéßÂà∂ÈÄöËøá notifier_call_chain Êú∫Âà∂ËΩ¨ÁßªÂà∞ Kprobes „ÄÇKprobes ÊâßË°å‰∏é kprobe ÂÖ≥ËÅîÁöÑ <code>pre_handler</code>ÔºåÂπ∂‰∏îÂêëÂÆÉ‰º†ÈÄí kprobe ÁªìÊûÑ‰ΩìÂíå‰øùÂ≠òÁöÑÂØÑÂ≠òÂô®Âú∞ÂùÄ„ÄÇ</p>
<!--
Next, Kprobes single-steps its copy of the probed instruction.
(It would be simpler to single-step the actual instruction `in place`,
but then Kprobes would have to temporarily remove the breakpoint
instruction.  This would open a small time window when another CPU
could `sail` right past the probepoint.)
-->
<p>Êé•ÁùÄÔºåKprobes ÂçïÊ≠•ÊâßË°åË¢´Êé¢ÊµãÊåá‰ª§ÁöÑÂâØÊú¨„ÄÇÔºàËôΩÁÑ∂ÂçïÊ≠•ÊâßË°åÂéüÂßãÊåá‰ª§‰ºöÊõ¥ÁÆÄÂçïÔºå‰ΩÜËøáÂêé Kprobes ËøòÂøÖÈ°ªÁßªÈô§Êñ≠ÁÇπÊåá‰ª§„ÄÇÂΩìÂè¶‰∏Ä‰∏™ CPU ÊâßË°åËøáÊé¢ÊµãÁÇπÁöÑÊó∂ÂÄôÔºåÂ∞Ü‰ºöÊâìÂºÄ‰∏Ä‰∏™Â∞èÁöÑÊó∂Èó¥Á™óÂè£„ÄÇÔºâ</p>
<!--
After the instruction is single-stepped, Kprobes executes the
‚Äúpost_handler‚Äù, if any, that is associated with the kprobe.
Execution then continues with the instruction following the probepoint.
-->
<p>Âú®Êåá‰ª§ÂçïÊ≠•ÊâßË°åÂÆå‰πãÂêéÔºåKprobes ‰ºöÊâßË°å‰∏é kprobe ÂÖ≥ËÅîÁöÑ <code>post_handler</code>ÔºåÂ¶ÇÊûúÊúâÁöÑËØù„ÄÇÁÑ∂ÂêéÔºåÁªßÁª≠ÊâßË°åÊé¢ÊµãÁÇπ‰πãÂêéÁöÑÊåá‰ª§„ÄÇ</p>
<!--
## Changing Execution Path
Since kprobes can probe into a running kernel code, it can change the
register set, including instruction pointer. This operation requires
maximum care, such as keeping the stack frame, recovering the execution
path etc. Since it operates on a running kernel and needs deep knowledge
of computer architecture and `concurrent` computing, you can easily shoot
your foot.
-->
<h3 id="ÊîπÂèòÊâßË°åË∑ØÂæÑ">ÊîπÂèòÊâßË°åË∑ØÂæÑ</h3>
<p>kprobes ËÉΩÂ§üÊé¢Êµã‰∏ÄÊÆµÊ≠£Âú®ËøêË°åÁöÑÂÜÖÊ†∏‰ª£Á†ÅÔºåÂõ†Ê≠§ÂÆÉËÉΩÊîπÂèòÂØÑÂ≠òÂô®ÔºåÂåÖÊã¨Êåá‰ª§ÊåáÈíà„ÄÇÁ±ª‰ºº‰øùÂ≠òÊ†àÂ∏ß„ÄÅÊÅ¢Â§çÊâßË°åË∑ØÂæÑÔºåËøôÁ±ªÊìç‰ΩúÈúÄË¶ÅÈùûÂ∏∏Âú∞Â∞èÂøÉÔºåÂõ†‰∏∫ kprobes ‰ΩúÁî®Âú®Ê≠£Âú®ËøêË°åÁöÑÂÜÖÊ†∏‰∏äÈù¢ÔºåÈúÄË¶ÅÊ∑±ÂÖ•ÁöÑ‰∫ÜËß£ËÆ°ÁÆóÁªìÊûÑ‰ΩìÁ≥ªÂíåÂπ∂Ë°åËÆ°ÁÆóÊâçË°å„ÄÇ</p>
<!--
If you change the instruction pointer (and set up other `related`
registers) in pre_handler, you must return !0 `so that` kprobes stops
single stepping and just returns to the given address.
This also means post_handler should not be called anymore.
-->
<p>ÂÅáÂ¶Ç‰Ω†Âú® <code>pre_handler</code> ÂõûË∞ÉÂáΩÊï∞ÂÜÖÊîπÂèòÊåá‰ª§ÊåáÈíàÔºà‰ª•ÂèäËÆæÁΩÆÂÖ∂ÂÆÉÁõ∏ÂÖ≥ÁöÑÂØÑÂ≠òÂô®ÔºâÔºåÈÇ£‰Ω†ÂøÖÈ°ªËøîÂõûÈùûÈõ∂ÂÄºÔºåÂ•ΩËÆ© kprobes ÂÅúÊ≠¢ÂçïÊ≠•ÊâßË°åÂπ∂Á´ãÂç≥ËøîÂõûÂà∞ÊåáÂÆöÂú∞ÂùÄ„ÄÇËøô‰πüË°®Á§∫ <code>post_handler</code> ‰∏çÂ∫îËØ•ÂÜçË¢´Ë∞ÉÁî®„ÄÇ</p>
<!--
Note that this operation may be harder on some architectures which use
TOC (Table of Contents) for function call, `since` you have to setup a new
TOC for your function in your module, and recover the old one after
returning from it.
-->
<p>Ê≥®ÊÑèÔºåÂú®ÈÇ£‰∫õ‰ΩøÁî® TOC ÔºàÁõÆÂΩïÔºâËøõË°åÂáΩÊï∞Ë∞ÉÁî®ÁöÑÊû∂ÊûÑ‰∏äÔºåËøôÁßçÊìç‰ΩúÂèØËÉΩ‰ºöÊõ¥Âõ∞ÈöæÔºåÂõ†‰∏∫‰Ω†ÂøÖÈ°ªÂú®‰Ω†ÁöÑÊ®°Âùó‰∏≠‰∏∫‰Ω†ÁöÑÂáΩÊï∞ËÆæÁΩÆÊñ∞ÁöÑ TOCÔºåÂπ∂‰∏îÂú®ÂáΩÊï∞ËøîÂõû‰πãÂêéËøòË¶ÅÊÅ¢Â§çÂÖàÂâçÁöÑ TOC„ÄÇ</p>
<!--
## Return Probes
How Does a Return Probe Work?

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When you call register_kretprobe(), Kprobes establishes a kprobe at
the entry to the function.  When the probed function is called and this
probe is hit, Kprobes saves a copy of the return address, and replaces
the return address with the address of a ‚Äú`trampoline`.‚Äù  The trampoline
is an `arbitrary` piece of code ‚Äî typically just a nop instruction.
At boot time, Kprobes registers a kprobe at the trampoline.
-->
<h3 id="return-Êé¢Èíà">Return Êé¢Èíà</h3>
<h4 id="return-Êé¢ÈíàÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑ">Return Êé¢ÈíàÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑÔºü</h4>
<p>Âú®‰Ω†Ë∞ÉÁî® <code>register_kretprobe()</code> ÂáΩÊï∞ÁöÑÊó∂ÂÄôÔºå Kprobes ‰ºöÂú®ÂáΩÊï∞ÁöÑÂÖ•Âè£Â§ÑÂª∫Á´ã‰∏Ä‰∏™ kprobe„ÄÇÂú®Ë∞ÉÁî®Ë¢´Êé¢ÊµãÂáΩÊï∞ÁöÑÊó∂ÂÄôÂëΩ‰∏≠Ëøô‰∏™Êé¢ÈíàÔºå Kprobes ‰ºö‰øùÂ≠ò return Âú∞ÂùÄÁöÑ‰∏Ä‰∏™ÂâØÊú¨Ôºå‰∏îÁî®‰∏Ä‰∏™ ‚Äútrampoline‚ÄùÔºàËπ¶Â∫äÔºâÁöÑÂú∞ÂùÄÊõøÊç¢ return Âú∞ÂùÄ„ÄÇtrampoline ÊòØ‰∏ÄÊÆµ‰ªªÊÑèÁöÑ‰ª£Á†Å ‚Äî ÈÄöÂ∏∏Âè™ÊòØ nop Êåá‰ª§„ÄÇÂú®ÂêØÂä®ÁöÑÊó∂ÂÄôÔºå Kprobes Âú®Ëπ¶Â∫äÊ≥®ÂÜå‰∫Ü‰∏Ä‰∏™ kprobe„ÄÇ</p>
<!--
When the probed function executes its return instruction, control
passes to the trampoline and that probe is hit.  Kprobes‚Äô trampoline
handler calls the `user-specified` return handler associated with the
kretprobe, then sets the saved instruction pointer to the saved return
address, and that‚Äôs where execution `resumes` upon return from the trap.
ÁîüËØçÔºöuser-specified, set ... to, resume, uponÔºàÊ≠§ÂêéÁöÑÊÑèÊÄùÔºåË∑üÂú®ÂçïËØçÂêéÈù¢ÁöÑÂè•Â≠êË°®ËææÁöÑ‰∫ãÊÉÖÂÆåÊàê‰πãÂêéÁöÑÊÑèÊÄùÔºâ
-->
<p>Âú®Ë¢´Êé¢ÊµãÁöÑÂáΩÊï∞ÊâßË°å return Êåá‰ª§Êó∂ÔºåÊéßÂà∂ËΩ¨ÁßªÂà∞Ëπ¶Â∫äÂëΩ‰∏≠Êé¢Èíà„ÄÇ Kprobes ÁöÑËπ¶Â∫äÂ§ÑÁêÜÂáΩÊï∞Ë∞ÉÁî®‰∏é kretprobe ÂÖ≥ËÅîÁöÑÁî®Êà∑ÊåáÂÆöÁöÑÂõûË∞ÉÂáΩÊï∞ÔºåÁÑ∂ÂêéÊää‰øùÂ≠òÁöÑÊåá‰ª§ÊåáÈíàËÆæÁΩÆ‰∏∫‰øùÂ≠òÁöÑ return Âú∞ÂùÄÔºå‰∏ÄÊó¶‰ªé trap ËøîÂõûÔºåÊâßË°å‰ºöÂú®ËøôÈáåÊÅ¢Â§ç„ÄÇ</p>
<!--
While the probed function is executing, its return address is
stored in an object of type kretprobe_instance.  Before calling
register_kretprobe(), the user sets the maxactive field of the
kretprobe struct to specify how many instances of the specified
function can be probed `simultaneously`.  register_kretprobe()
pre-allocates the `indicated` number of kretprobe_instance objects.
ÁîüËØçÔºösimultaneous, indicatedÔºàÂΩ¢ÂÆπËØçÔºâ
-->
<p>Âú®Ë¢´Êé¢ÊµãÁöÑÂáΩÊï∞ÊâßË°åÊúüÈó¥ÔºåÂÆÉÁöÑËøîÂõûÂú∞ÂùÄË¢´‰øùÂ≠òÂú®‰∏Ä‰∏™ <code>kretprobe_instance</code> Á±ªÂûãÁöÑÂØπË±°‰∏≠„ÄÇÂú®Ë∞ÉÁî® <code>register_kretprobe()</code> ÂáΩÊï∞ÂâçÔºåÁî®Êà∑ËÆæÁΩÆ kretprobe ÁªìÊûÑ‰ΩìÁöÑ <code>maxactive</code> Â≠óÊÆµË°®Á§∫ÂèØÂêåÊó∂Êé¢ÊµãÊåáÂÆöÂáΩÊï∞ÁöÑÂÆû‰æãÊï∞Èáè„ÄÇ <code>register_kretprobe()</code> ÂáΩÊï∞‰ºöÈ¢ÑÂÖàÂàÜÈÖçËßÑÂÆöÊï∞ÈáèÁöÑ <code>kretprobe_instance</code> ÂØπË±°„ÄÇ</p>
<!--
For example, if the function is non-recursive and is called with a
spinlock held, maxactive = 1 should be enough.  If the function is
non-recursive and can never `relinquish` the CPU (e.g., via a semaphore
or `preemption`), NR_CPUS should be enough.  If maxactive <= 0, it is
set to a default value.  If CONFIG_PREEMPT is enabled, the default
is max(10, 2*NR_CPUS).  Otherwise, the default is NR_CPUS.
ÁîüËØçÔºö with a spinlock held, relinquish, preemption
-->
<p>‰æãÂ¶ÇÔºåÂÅáËÆæËØ•ÂáΩÊï∞ÊòØÈùûÈÄíÂΩíÁöÑÔºå‰∏îÂú®Ëá™ÊóãÈîÅÈîÅ‰ΩèÁöÑÊÉÖÂÜµ‰∏ãË¢´Ë∞ÉÁî®ÔºåÈÇ£ <code>maxactive</code> ÁöÑÂÄº‰∏∫ 1 Â∫îËØ•Ë∂≥Â§ü„ÄÇÂ¶ÇÊûúÂáΩÊï∞ÊòØÈùûÈÄíÂΩíÁöÑÔºå‰∏îÊ∞∏Ëøú‰∏çÊîæÂºÉ CPU Ôºà‰æãÂ¶ÇÔºöÈÄöËøá‰ø°Âè∑ÈáèÊàñÊä¢Âç†ÔºâÔºåÈÇ£ NR_CPUS Â∫îËØ•Ë∂≥Â§ü„ÄÇË¶ÅÊòØ <code>maxactive</code> ÁöÑÂÄºÂ∞è‰∫éÁ≠â‰∫éÈõ∂ÁöÑËØùÔºå‰ºöËÆæÁΩÆÊàêÈªòËÆ§ÂÄº„ÄÇÂ¶ÇÊûúÂºÄÂêØ CONFIG_PREEMPT ÈÄâÈ°πÔºåÈªòËÆ§ÂÄº‰∏∫ <code>max(10, 2*NR_CPUS)</code>ÔºàÂú®‰∏§ÂÄçÁöÑ CPU Êï∞Èáè‰∏é 10 ‰πãÈó¥ÂèñËæÉÂ§ßÁöÑÂÄºÔºâ„ÄÇÂÖ∂‰ªñÊÉÖÂÜµÔºåÈªòËÆ§ÂÄº‰∏∫ NR_CPUSÔºàCPU Êï∞ÈáèÔºâ„ÄÇ</p>
<!--
It‚Äôs not a `disaster` if you set maxactive too low; you‚Äôll just miss
some probes.  In the kretprobe struct, the nmissed field is set to
zero when the return probe is registered, and is `incremented` every
time the probed function is entered but there is no kretprobe_instance
object available for establishing the return probe.
ÁîüËØçÔºödisaster, incremented
-->
<p>Â¶ÇÊûú‰Ω†Êää <code>maxactive</code> ËÆæÁΩÆÁöÑÂæàÂ∞èÁöÑËØùÔºå‰πü‰∏ç‰ºöÊúâ‰ªÄ‰πàÈóÆÈ¢òÔºåÂè™ÊòØ‰ºöÊºèÊéâ‰∏Ä‰∫õÊé¢ÈíàËÄåÂ∑≤„ÄÇÂú® kretprobe ÁªìÊûÑ‰Ωì‰∏≠Ôºåreturn Êé¢ÈíàÊ≥®ÂÜåÂêé <code>nmissed</code> Â≠óÊÆµ‰ºöËÆæÁΩÆ‰∏∫ 0Ôºå‰πãÂêéÂú®ÊØèÊ¨°ËøõÂÖ•Ë¢´Êé¢ÊµãÂáΩÊï∞‰∏îÊ≤°ÊúâÂèØÁî®ÁöÑ <code>kretprobe_instance</code> ÂØπË±°ÂÖ≥ËÅî return Êé¢ÊµãÁöÑÊó∂ÂÄôÁ¥ØÂä†„ÄÇ</p>
<!--
### Kretprobe entry-handler
Kretprobes also provides an optional user-specified handler which runs
on function entry. This handler is specified by setting the entry_handler
field of the kretprobe struct. Whenever the kprobe `placed by` kretprobe at the
function entry is hit, the user-defined entry_handler, if any, is invoked.
If the entry_handler returns 0 (success) then a `corresponding` return handler
is `guaranteed` to be called upon function return. If the entry_handler
returns a non-zero error then Kprobes leaves the return address as is, and
the kretprobe has no further effect for that particular function instance.
ÁîüËØçÔºöplaced by, correspondingÔºàÂΩ¢ÂÆπËØçÔºâ, guarantee, furtherÔºàËøõ‰∏ÄÊ≠•Ôºâ, effectÔºàÊïàÊûúÔºåÂΩ±ÂìçÔºâ
-->
<h4 id="kretprobe-ÂÖ•Âè£ÂõûË∞ÉÂáΩÊï∞">Kretprobe ÂÖ•Âè£ÂõûË∞ÉÂáΩÊï∞</h4>
<p>Kretprobes ËøòÊèê‰æõ‰∏Ä‰∏™ÂèØÈÄâÁöÑÁî®Êà∑ÂõûË∞ÉÂáΩÊï∞ÔºåÂÆÉËøêË°å‰∫éÂáΩÊï∞ÂÖ•Âè£„ÄÇËøô‰∏™ÂõûË∞ÉÂáΩÊï∞ÈÄöËøá kretprobe ÁªìÊûÑ‰Ωì <code>entry_handler</code> Â≠óÊÆµÊåáÂÆö„ÄÇÊØèÂΩìÂëΩ‰∏≠ÊîæÁΩÆÂú®ÂáΩÊï∞ÂÖ•Âè£Â§ÑÁöÑ kprobe Êó∂ÔºåÂ∞±‰ºöË∞ÉÁî®Áî®Êà∑Ëá™ÂÆö‰πâÁöÑ <code>entry_handler</code> ÂáΩÊï∞„ÄÇÂ¶ÇÊûú <code>entry_handler</code> ÂáΩÊï∞ËøîÂõûÈõ∂ÔºàÊàêÂäüÔºâÔºåÈÇ£‰πàÂØπÂ∫îÁöÑ return ÂõûË∞ÉÂáΩÊï∞‰øùËØÅ‰ºöÂú®ÂáΩÊï∞ËøîÂõûÁöÑÊó∂ÂÄôË¢´Ë∞ÉÁî®„ÄÇÂ¶ÇÊûú <code>entry_handler</code> ËøîÂõû‰∏Ä‰∏™ÈùûÈõ∂ÈîôËØØÔºå Kprobes ‰ºö‰øùÁïôËøîÂõûÂú∞ÂùÄÔºåËÄå kretprobe ÂØπÁâπÂÆöÁöÑÂáΩÊï∞ÂÆû‰æãÊ≤°ÊúâÂΩ±Âìç„ÄÇ</p>
<!--
Multiple entry and return handler `invocations` are matched using the unique
kretprobe_instance object associated with them. Additionally, a user
may also specify per return-instance private data to be part of each
kretprobe_instance object. This is especially useful when sharing private
data between corresponding user entry and return handlers. The size of each
private data object can be specified at kretprobe registration time by
setting the data_size field of the kretprobe struct. This data can be
accessed through the data field of each kretprobe_instance object.
ÁîüËØçÔºöinvocationÔºàÂêçËØçÔºåË∞ÉÁî®Ôºâ, corresponding
-->
<p>‰ΩøÁî®‰∏éÂÆÉ‰ª¨ÂÖ≥ËÅîÁöÑÂîØ‰∏ÄÂØπË±° kretprobe_instanceÔºåÂèØ‰ª•ÂåπÈÖçËÆ∏Â§öÁöÑ entry Âíå return ÂõûË∞ÉÂáΩÊï∞Ë∞ÉÁî®„ÄÇÂè¶Â§ñÔºåÁî®Êà∑‰πüÂèØ‰ª•ÊääÊØè‰∏™ return-instace ÁöÑÁßÅÊúâÊï∞ÊçÆÊåáÂÆö‰∏∫ÊØè‰∏™ kretprobe_instance ÂØπË±°ÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇËøôÂú® entry Âíå return ÂõûË∞ÉÂáΩÊï∞‰πãÈó¥ÂÖ±‰∫´ÁßÅÊúâÊï∞ÊçÆÊó∂Â∞§ÂÖ∂ÊúâÁî®„ÄÇÊØè‰∏™ÁßÅÊúâÊï∞ÊçÆÂØπË±°ÁöÑÂ§ßÂ∞èÂèØ‰ª•Âú® kretprobe Ê≥®ÂÜåÊó∂ÈÄöËøá kretprobe ÁªìÊûÑ‰Ωì‰∏≠ÁöÑ data_size Â≠óÊÆµÊåáÂÆö„ÄÇÁßÅÊúâÊï∞ÊçÆÂèØ‰ª•ÈÄöËøáÊØè‰∏™ kretprobe_instance ÂØπË±°ÁöÑ data Â≠óÊÆµËÆøÈóÆ„ÄÇ</p>
<!--
`In case` probed function is entered but there is no kretprobe_instance
object available, then `in addition to` incrementing the nmissed count,
the user entry_handler invocation is also skipped.
-->
<p>Â¶ÇÊûúÂ∑≤ÁªèËøõÂÖ•Ë¢´Êé¢ÊµãÂáΩÊï∞‰ΩÜÊ≤°ÊúâÂèØÁî®ÁöÑ kretprobe_instance ÂØπË±°ÔºåÈÇ£‰πàÈô§‰∫ÜÂ¢ûÂä† <code>nmissed</code> ÁöÑËÆ°Êï∞‰πãÂ§ñÔºåËøò‰ºöË∑≥Ëøá <code>entry_handler</code> Ë∞ÉÁî®„ÄÇ</p>
<!--
.. _kprobes_jump_optimization:
How Does Jump Optimization Work?
---------------------------------
If your kernel is built with CONFIG_OPTPROBES=y (currently this flag
is automatically set ‚Äòy‚Äô on x86/x86-64, non-preemptive kernel) and
the ‚Äúdebug.kprobes_optimization‚Äù kernel parameter is set to 1 (see
sysctl(8)), Kprobes tries to reduce probe-hit `overhead` by using a jump
instruction instead of a breakpoint instruction at each probepoint.
-->
<h3 id="Ë∑≥ËΩ¨‰ºòÂåñÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑ">Ë∑≥ËΩ¨‰ºòÂåñÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑÔºü</h3>
<p>Â¶ÇÊûúÂÜÖÊ†∏‰ΩøÁî® CONFIG_OPTPROBES=y Ôºàx86/x86-64„ÄÅÈùûÊä¢Âç†ÂºèÂÜÖÊ†∏‰∏äËØ•Ê†áËÆ∞Ëá™Âä®Âú∞ËÆæÁΩÆ‰∏∫ yÔºâÁºñËØëÔºå‰∏îÂÜÖÊ†∏ÂèÇÊï∞ ‚Äúdebug.kprobes_optimization‚Äù ËÆæÁΩÆ‰∏∫ 1 ÔºàËßÅ sysctl(8) ÔºâÔºåÈÇ£‰πà Kprobes Â∞ùËØïÂú®ÊØè‰∏™Êé¢ÊµãÁÇπÁî® jump Êåá‰ª§‰ª£Êõø breakpoint Êåá‰ª§Êù•ÂáèÂ∞ëÂëΩ‰∏≠Êé¢ÈíàÁöÑÂºÄÈîÄ„ÄÇ</p>
<!--
Init a Kprobe
^^^^^^^^^^^^^

When a probe is registered, before `attempting` this optimization,
Kprobes inserts an `ordinary`, breakpoint-based kprobe at the specified
address. So, even if it‚Äôs not possible to optimize this particular
probepoint, there‚Äôll be a probe there.
-->
<h4 id="ÂàùÂßãÂåñ-kprobe">ÂàùÂßãÂåñ Kprobe</h4>
<p>Âú®Ê≥®ÂÜå‰∫Ü‰∏Ä‰∏™Êé¢ÈíàËØïÂõæ‰ºòÂåñ‰πãÂâçÔºåKprobes ‰ºöÂú®ÊåáÂÆöÁöÑÂú∞ÂùÄÊèíÂÖ•‰∏Ä‰∏™ÊôÆÈÄöÁöÑÔºåÂü∫‰∫éÊñ≠ÁÇπÁöÑ kprobe„ÄÇÊâÄ‰ª•ÔºåÂç≥‰æø‰∏çËÉΩ‰ºòÂåñËøô‰∏™ÁâπÂÆöÁöÑÊé¢ÊµãÁÇπÔºå‰πü‰ºöÊúâ‰∏Ä‰∏™Êé¢ÈíàÂú®ÈÇ£ÂÑø„ÄÇ</p>
<!--
Safety Check
^^^^^^^^^^^^

Before optimizing a probe, Kprobes `performs` the following safety checks:

	* Kprobes verifies that the `region` that will be replaced by the jump
	instruction (the ‚Äúoptimized region‚Äù) lies entirely within one function.
	(A jump instruction is multiple bytes, and so may `overlay` multiple
	instructions.)

	* Kprobes analyzes the entire function and verifies that there is no
	jump into the optimized region.  Specifically:
		* the function contains no `indirect` jump;
		* the function contains no instruction that causes an exception (since
		the `fixup` code triggered by the exception could jump back into the
		optimized region ‚Äî Kprobes checks the exception tables to verify this);
		* there is no near jump to the optimized region (`other than` to the first
		byte).

	* For each instruction in the optimized region, Kprobes verifies that
	the instruction can be executed `out of line`.
-->
<h4 id="ÂÆâÂÖ®Ê£ÄÊü•">ÂÆâÂÖ®Ê£ÄÊü•</h4>
<p>Âú®ËøõË°å‰ºòÂåñÊé¢Èíà‰πãÂâçÔºåKprobes ‰ºöÂÅö‰ª•‰∏ãÂÆâÂÖ®Ê£ÄÊü•Ôºö</p>
<ul>
<li>
<p>Kprobes Ê†°È™å‰ºöË¢´ jump Êåá‰ª§ÊõøÊç¢ÁöÑÂå∫ÂüüÔºà‚ÄùÂ∑≤‰ºòÂåñÁöÑÂå∫Âüü‚ÄúÔºâÂÆåÂÖ®Â§Ñ‰∫é‰∏Ä‰∏™ÂáΩÊï∞ÂÜÖÈÉ®„ÄÇÔºàjump Êåá‰ª§ÊòØÂ§öÂ≠óËäÇÊåá‰ª§ÔºåÂõ†Ê≠§ÂèØËÉΩ‰ºöË¶ÜÁõñÂ§ö‰∏™Êåá‰ª§Ôºâ</p>
</li>
<li>
<p>Kprobes ÂàÜÊûêÊï¥‰∏™ÂáΩÊï∞ÔºåÂπ∂‰∏îÁ°ÆËÆ§‰∏ç‰ºöË∑≥ÂÖ•Â∑≤‰ºòÂåñÁöÑÂå∫Âüü„ÄÇÁâπÂà´ÊòØÔºö</p>
<ul>
<li>ËØ•ÂáΩÊï∞‰∏çÂåÖÂê´Èó¥Êé•Ë∑≥ËΩ¨</li>
<li>ËØ•ÂáΩÊï∞‰∏çÂåÖÂê´ÂºïËµ∑ÂºÇÂ∏∏ÁöÑÊåá‰ª§ÔºàÂõ†‰∏∫Ë¢´ÂºÇÂ∏∏Ëß¶ÂèëÁöÑÂõ∫ÂÆö‰ª£Á†ÅÂèØËÉΩ‰ºöË∑≥ÂõûÂà∞Â∑≤‰ºòÂåñÁöÑÂå∫Âüü ‚Äî Kprobes ‰ºöÊ£ÄÊü•ÂºÇÂ∏∏Ë°®Êù•È™åËØÅËøô‰∏ÄÁÇπÔºâ</li>
<li>ËØ•ÂáΩÊï∞ÈôÑËøëÊ≤°ÊúâË∑≥ËΩ¨Âà∞Â∑≤‰ºòÂåñÁöÑÂå∫ÂüüÔºàÈô§‰∫ÜÁ¨¨‰∏Ä‰∏™Â≠óËäÇÔºâ</li>
</ul>
</li>
<li>
<p>ÂØπ‰∫éÂ∑≤‰ºòÂåñÂå∫Âüü‰∏≠ÁöÑÊØè‰∏Ä‰∏™Êåá‰ª§ÔºåKprobes ‰ºöÈ™åËØÅÂÆÉ‰ª¨ËÉΩÂê¶Á¶ªÁ∫øÊâßË°å„ÄÇ</p>
</li>
</ul>
<!--
Preparing Detour Buffer
^^^^^^^^^^^^^^^^^^^^^^^

Next, Kprobes prepares a "detour" buffer, which contains the following
instruction sequence:

	- code to push the CPU's registers (emulating a breakpoint trap)
	- a call to the trampoline code which calls user's probe handlers.
	- code to restore registers
	- the instructions from the optimized region
	- a jump back to the original execution path.
-->
<h4 id="ÂáÜÂ§á-detour-ÁºìÂÜ≤Âå∫">ÂáÜÂ§á detour ÁºìÂÜ≤Âå∫</h4>
<blockquote>
<p>detour ÊÑèÊÄùÊòØÂÉè‰∫§ÈÄöËäÇÁÇπÔºàÁéØÂ≤õÔºâÈÇ£Ê†∑</p>
</blockquote>
<p>Êé•ÁùÄÔºåKprobes ÂáÜÂ§á‰∏Ä‰∏™‚ÄúÁéØÂΩ¢‚ÄùÁºìÂÜ≤Âå∫ÔºåÂåÖÂê´‰ª•‰∏ãÊåá‰ª§Â∫èÂàóÔºö</p>
<ul>
<li>Êé®Ëøõ CPU ÂØÑÂ≠òÂô®ÁöÑ‰ª£Á†ÅÔºàÊ®°ÊãüÊñ≠ÁÇπ trapÔºâ</li>
<li>Ë∞ÉÁî®Ëπ¶Â∫ä‰ª£Á†ÅÔºåÂÜçÈó¥Êé•Ë∞ÉÁî®Áî®Êà∑ÁöÑÊé¢ÈíàÂõûË∞ÉÂáΩÊï∞</li>
<li>ÊÅ¢Â§çÂØÑÂ≠òÂô®ÁöÑ‰ª£Á†Å</li>
<li>‰ºòÂåñÂå∫ÂüüÁöÑÊåá‰ª§</li>
<li>Ë∑≥ÂõûÂéüÂßãÊâßË°åË∑ØÂæÑÁöÑÊåá‰ª§</li>
</ul>
<!--
Pre-optimization
^^^^^^^^^^^^^^^^^

After preparing the detour buffer, Kprobes verifies that none of the
following situations exist:

	* The probe has a post_handler.
	* Other instructions in the optimized region are probed.
	* The probe is disabled.
-->
<h4 id="‰ºòÂåñÂâç">‰ºòÂåñÂâç</h4>
<p>Âú®ÂáÜÂ§á detour ÁºìÂÜ≤Âå∫ÂêéÔºå Kprobes ‰ºöÊ£ÄÊü•Á°Æ‰øù‰∏çÂá∫Áé∞‰ª•‰∏ãÊÉÖÂÜµÔºö</p>
<ul>
<li>Êé¢ÈíàÊúâ‰∏Ä‰∏™ post_handler ÂõûË∞ÉÂáΩÊï∞</li>
<li>Âú®‰ºòÂåñÂå∫Âüü‰∏≠ÁöÑÂÖ∂‰ªñÊåá‰ª§Ë¢´Êé¢Êµã‰∫Ü</li>
<li>Â∑≤Á¶ÅÁî®ÁöÑÊé¢Èíà</li>
</ul>
<!--
In any of the above cases, Kprobes won‚Äôt start optimizing the probe.
Since these are temporary situations, Kprobes tries to start
optimizing it again if the situation is changed.
-->
<p>Âú®‰∏äËø∞‰ªª‰Ωï‰∏ÄÁßçÊÉÖÂÜµ‰∏ãÔºåKprobes ÈÉΩ‰∏ç‰ºö‰ºòÂåñÊé¢Èíà„ÄÇÂõ†‰∏∫ËøôÈÉΩÊòØ‰∏¥Êó∂ÊÉÖÂÜµÔºåÂ¶ÇÊûúÊÉÖÂÜµÊúâÂèòÂåñÔºåKprobes ‰ºöÂÜçÊ¨°ËøõË°å‰ºòÂåñ„ÄÇ</p>
<!--
If the kprobe can be optimized, Kprobes enqueues the kprobe to an
optimizing list, and kicks the kprobe-optimizer workqueue to optimize
it.  If the to-be-optimized probepoint is hit before being optimized,
Kprobes returns control to the original instruction path by setting
the CPU‚Äôs instruction pointer to the copied code in the detour buffer
‚Äî thus at least avoiding the single-step.
-->
<p>Â¶ÇÊûú kprobe ÂèØ‰ª•Ë¢´‰ºòÂåñÔºåKprobes ‰ºöÊää kprobe ÂàóÂÖ•‰ºòÂåñÈòüÂàó‰∏≠ÔºåÁÑ∂ÂêéÂêØÂä®Â∑•‰ΩúÈòüÂàó kprobe-optimizer Âéª‰ºòÂåñÂÆÉ„ÄÇÂ¶ÇÊûúË¢´‰ºòÂåñÁöÑ probepoint Âú®‰ºòÂåñ‰πãÂâçÂëΩ‰∏≠Ôºå Kprobes ÈÄöËøáÊää CPU ÁöÑÊåá‰ª§ÊåáÈíàËÆæÁΩÆ‰∏∫ detour ÁºìÂÜ≤Âå∫‰∏≠Ë¢´Â§çÂà∂ÁöÑ‰ª£Á†ÅÔºåÂ∞ÜÊéßÂà∂ÊùÉËøîÂõûÂà∞ÂéüÂßãÊåá‰ª§Ë∑ØÂæÑ ‚Äî ËøôÊ†∑ÂÅöËá≥Â∞ëÈÅøÂÖç‰∫ÜÂçïÊ≠•ÊâßË°å„ÄÇ</p>
<!--
Optimization
^^^^^^^^^^^^^

The Kprobe-optimizer doesn‚Äôt insert the jump instruction immediately;
`rather`, it calls synchronize_rcu() for safety first, because it‚Äôs
possible for a CPU to be interrupted in the middle of executing the
optimized region [^3].  As you know, synchronize_rcu() can ensure
that all interruptions that were active when synchronize_rcu()
was called are done, but only if CONFIG_PREEMPT=n.  So, this version
of kprobe optimization supports only kernels with CONFIG_PREEMPT=n [^4].

After that, the Kprobe-optimizer calls stop_machine() to replace
the optimized region with a jump instruction to the detour buffer,
using text_poke_smp().
-->
<h4 id="‰ºòÂåñ">‰ºòÂåñ</h4>
<p>Kprobe-optimizer Âπ∂‰∏ç‰ºöÁ´ãÂç≥ÊèíÂÖ• jump Êåá‰ª§ÔºåÁõ∏Âèç‰∏∫‰∫ÜÂÆâÂÖ®ÂÆÉ‰ºöÂÖàË∞ÉÁî® <code>synchronize_rcu()</code> ÂáΩÊï∞ÔºåÂõ†‰∏∫Âú®Â§ÑÁêÜ‰ºòÂåñÂå∫ÂüüÁöÑËøáÁ®ã‰∏≠ CPU ÂèØËÉΩ‰ºöË¢´‰∏≠Êñ≠ <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>„ÄÇÂ¶Ç‰Ω†ÊâÄÁü•Ôºå <code>synchronize_rcu()</code> ÂáΩÊï∞ÂèØ‰ª•Á°Æ‰øùÊâÄÊúâÊ¥ªË∑ÉÁöÑ‰∏≠Êñ≠Âú®Ë∞ÉÁî® <code>synchronize_rcu()</code> ÁöÑÊó∂ÂÄôÂ∑≤ÁªèÂÆåÊàêÔºå‰ΩÜÂâçÊèêÊòØ <code>CONFIG_PREEMPT=n</code> ÁöÑÊó∂ÂÄô„ÄÇÊâÄ‰ª•Ôºåkprobe ÁöÑ‰ºòÂåñÁâàÊú¨Âè™ÊîØÊåÅ <code>CONFIG_PREEMPT=n</code> ÁöÑÂÜÖÊ†∏ <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>„ÄÇ</p>
<p>‰πãÂêéÔºå Kprobe-optimizer Ë∞ÉÁî® <code>stop_machine()</code> ÂáΩÊï∞ÊõøÊç¢‰ºòÂåñÂå∫ÂüüÔºåÁî®‰∏Ä‰∏™Ë∑≥ËΩ¨Âà∞ detour ÁºìÂÜ≤Âå∫Êåá‰ª§Ôºå‰ΩøÁî® <code>text_poke_smp()</code> ÂáΩÊï∞„ÄÇ</p>
<!--
Unoptimization
^^^^^^^^^^^^^^^^^
When an optimized kprobe is unregistered, disabled, or blocked by
another kprobe, it will be unoptimized.  If this happens before
the optimization is complete, the kprobe is just `dequeued` from the
optimized list.  If the optimization has been done, the jump is
replaced with the original code (except for an int3 breakpoint in
the first byte) by using text_poke_smp().
-->
<h4 id="ÂèñÊ∂à‰ºòÂåñ">ÂèñÊ∂à‰ºòÂåñ</h4>
<p>ÂΩì‰ºòÂåñÁöÑ kprobe Ë¢´ÂÖ∂‰ªñ kprobe Ê≥®ÈîÄ„ÄÅÁ¶ÅÁî®ÊàñÈòªÂ°ûÁöÑÊó∂ÂÄôÔºåÂÆÉÂ∞Ü‰∏ç‰ºöË¢´‰ºòÂåñ„ÄÇÂ¶ÇÊûúËøôÁßçÊÉÖÂÜµÂú®‰ºòÂåñÂÆåÊàê‰πãÂâçÂèëÁîüÔºåÂàôÂè™ÊòØÂ∞Ü kprobe ‰ªé‰ºòÂåñÈòüÂàó‰∏≠ÁßªÈô§„ÄÇÂ¶ÇÊûú‰ºòÂåñÂ∑≤ÁªèÂÆåÊàêÔºå‰ºöÈÄöËøáË∞ÉÁî® <code>text_poke_smp()</code> ÂáΩÊï∞Êää jump Êåá‰ª§ÊõøÊç¢‰∏∫ÂéüÂßã‰ª£Á†ÅÔºàÈô§‰∫ÜÁ¨¨‰∏Ä‰∏™Â≠óËäÇ‰∏≠ÁöÑ int3 Êñ≠ÁÇπÔºâ„ÄÇ</p>
<!--
[^3]: Please imagine that the 2nd instruction is interrupted and then
the optimizer replaces the 2nd instruction with the jump address
while the interrupt handler is running. When the interrupt returns to
original address, there is no valid instruction, and it causes an unexpected result.
-->
<!--
[^4]: This optimization-safety checking may be replaced with the
stop-machine method that ksplice uses for supporting a CONFIG_PREEMPT=y
kernel.
-->
<!--
NOTE for geeks:
The jump optimization changes the kprobe‚Äôs pre_handler behavior.
Without optimization, the pre_handler can change the kernel‚Äôs execution
path by changing regs->ip and returning 1.  However, when the probe
is optimized, that `modification` is ignored.  `Thus`, if you want to
`tweak` the kernel‚Äôs execution path, you need to `suppress` optimization,
using one of the following techniques:

	* Specify an empty function for the kprobe‚Äôs post_handler.
	or
	* Execute ‚Äòsysctl -w debug.kprobes_optimization=n‚Äô
-->
<p>geeks Ê≥®ÊÑèÔºö<br />
Ë∑≥ËΩ¨‰ºòÂåñÊîπÂèò‰∫Ü kprobe ÁöÑ <code>pre_handler</code> ÁöÑË°å‰∏∫„ÄÇ‰ºòÂåñÂâçÔºå<code>pre_handler</code> ÈÄöËøáÊîπÂèò <code>regs-&gt;ip</code> ÁöÑÂêåÊó∂ËøîÂõû 1 ÂèØ‰ª•ÊîπÂèòÂÜÖÊ†∏ÁöÑÊâßË°åË∑ØÂæÑ„ÄÇÁÑ∂ËÄåÔºåÂú® probe Ë¢´‰ºòÂåñÁöÑÊó∂ÂÄôÔºå‰øÆÊîπ‰ºöË¢´ÂøΩÁï•„ÄÇÂõ†Ê≠§ÔºåÂ¶ÇÊûú‰Ω†ÊÉ≥ÂæÆË∞ÉÂÜÖÊ†∏ÁöÑÊâßË°åË∑ØÂæÑÔºåÈúÄË¶Å‰ΩøÁî®‰∏Ä‰∏™ÊñπÊ≥ïÂéªÊäëÂà∂‰ºòÂåñÔºö</p>
<ul>
<li>Áªô kprobe ÁöÑ post_handler ÊåáÂÆö‰∏Ä‰∏™Á©∫ÂáΩÊï∞</li>
<li>ÊâßË°å <code>sysctl -w debug.kprobes_optimization=n</code> ÂëΩ‰ª§</li>
</ul>
<!--
.. _kprobes_blacklist:
Blacklist
---------
Kprobes can probe most of the kernel except itself. This means
that there are some functions where kprobes cannot probe. Probing
(trapping) such functions can cause a recursive trap (e.g. double
fault) or the `nested` probe handler may never be called.
Kprobes manages such functions as a blacklist.
If you want to add a function into the blacklist, you just need
to (1) include linux/kprobes.h and (2) use NOKPROBE_SYMBOL() macro
to specify a blacklisted function.
Kprobes checks the given probe address `against` the blacklist and
rejects registering it, if the given address is in the blacklist.
-->
<h3 id="ÈªëÂêçÂçï">ÈªëÂêçÂçï</h3>
<p>Kprobes ÂèØ‰ª•Êé¢ÊµãÈô§Ëá™Ë∫´‰ª•Â§ñÁöÑÂ§ßÈÉ®ÂàÜÂÜÖÊ†∏Á©∫Èó¥„ÄÇËøôË°®Á§∫Êúâ‰∏Ä‰∫õÂáΩÊï∞ kprobes Êó†Ê≥ïÊé¢Êµã„ÄÇÊé¢ÊµãÔºàtrappingÔºâËøôÊ†∑ÁöÑÂáΩÊï∞‰ºöÂØºËá¥ÈÄíÂΩí trap ÔºàÊØîÂ¶ÇÔºöÂèåÈáçÊïÖÈöúÔºâÊàñËÄÖÂµåÂ•óÁöÑ probe ÂõûË∞ÉÂáΩÊï∞ÂèØËÉΩÊ∞∏Ëøú‰∏ç‰ºöË¢´Ë∞ÉÁî®„ÄÇÂ¶ÇÊûú‰Ω†ÊÉ≥Ê∑ªÂä†‰∏Ä‰∏™ÂáΩÊï∞Âà∞ÈªëÂêçÂçï‰∏≠ÔºåÂè™ÈúÄË¶Å‰∏§‰∏™Ê≠•È™§ÔºöÈ¶ñÂÖàÔºåÂºïÂÖ•<code> linux/kprobes.h</code> Êñá‰ª∂ÔºõÂÖ∂Ê¨°Ôºå‰ΩøÁî® <code>NOKPROBE_SYMBOL()</code> ÂÆèÊåáÂÆö‰∏Ä‰∏™Ë¶ÅË¢´ÂàóÂÖ•ÈªëÂêçÂçïÁöÑÂáΩÊï∞„ÄÇ Kprobes ÂØπÁÖßÈªëÂêçÂçïÊ£ÄÊü•‰º†ÂÖ•ÁöÑ probe Âú∞ÂùÄÔºåÂ¶ÇÊûú‰º†ÂÖ•ÁöÑÂú∞ÂùÄÂú®ÈªëÂêçÂçï‰∏≠‰ºöÊãíÁªùÊ≥®ÂÜå„ÄÇ</p>
<!--
.. kprobes_archs_supported:
## Architectures Supported
Kprobes and return probes are implemented on the following
architectures:
-->
<h2 id="ÊîØÊåÅÁöÑÊû∂ÊûÑ">ÊîØÊåÅÁöÑÊû∂ÊûÑ</h2>
<p>Kprobes Âíå Kretprobes Â∑≤Âú®‰∏ãÈù¢ÁöÑËøô‰∫õÁªìÊûÑ‰ΩìÁ≥ª‰∏äÂÆûÁé∞Ôºö</p>
<ul>
<li>i386 (Supports jump optimization)ÔºàÊîØÊåÅË∑≥ËΩ¨‰ºòÂåñÔºâ</li>
<li>x86_64 (AMD-64, EM64T) (Supports jump optimization)ÔºàÊîØÊåÅË∑≥ËΩ¨‰ºòÂåñÔºâ</li>
<li>ppc64</li>
<li>ia64 (Does not support probes on instruction slot1.)ÔºàÂú® slot1 Êåá‰ª§‰∏ä‰∏çÊîØÊåÅ probesÔºâ</li>
<li>sparc64 (Return probes not yet implemented.)ÔºàËøîÂõû probes ËøòÊ≤°ÂÆûÁé∞Ôºâ</li>
<li>arm</li>
<li>ppc</li>
<li>mips</li>
<li>s390</li>
<li>parisc</li>
</ul>
<!--
Configuring Kprobes
===================
When configuring the kernel using make menuconfig/xconfig/oldconfig,
ensure that CONFIG_KPROBES is set to ‚Äúy‚Äù. Under ‚ÄúGeneral setup‚Äù, look
for ‚ÄúKprobes‚Äù.

So that you can load and unload Kprobes-based instrumentation modules,
make sure ‚ÄúLoadable module support‚Äù (CONFIG_MODULES) and ‚ÄúModule
unloading‚Äù (CONFIG_MODULE_UNLOAD) are set to ‚Äúy‚Äù.

Also make sure that CONFIG_KALLSYMS and perhaps even CONFIG_KALLSYMS_ALL
are set to ‚Äúy‚Äù, since kallsyms_lookup_name() is used by the in-kernel
kprobe `address` resolution code.
-->
<h2 id="ÈÖçÁΩÆ-kprobes">ÈÖçÁΩÆ Kprobes</h2>
<p>Âú®‰ΩøÁî® <code>make menuconfig/xconfig/oldconfig</code> ÈÖçÁΩÆÂÜÖÊ†∏Êó∂ÔºåÁ°Æ‰øù <code>CONFIG_KPROBES </code> ËÆæÁΩÆ‰∏∫ ‚Äúy‚Äù„ÄÇÂú® ‚ÄúGeneral setup‚Äù Â≠óÁ¨¶ÂêéÊêúÁ¥¢ ‚ÄúKprobes‚Äù„ÄÇ</p>
<p>‰∏∫‰∫ÜÂèØ‰ª•Âä†ËΩΩÂíåÂç∏ËΩΩÂü∫‰∫é Kprobes ÁöÑÊé¢ÊµãÊ®°ÂùóÔºåËØ∑Á°Æ‰øùÂ∞Ü‚ÄúÊîØÊåÅÊ®°ÂùóÂä†ËΩΩ‚ÄùÔºàCONFIG_MODULESÔºâÂíå‚ÄúÊ®°ÂùóÂç∏ËΩΩ‚ÄùÔºàCONFIG_MODULE_UNLOADÔºâËÆæÁΩÆ‰∏∫ ‚Äúy‚Äù„ÄÇ</p>
<p>ËøòË¶ÅÁ°Æ‰øùÂ∞Ü  <code>CONFIG_KALLSYMS </code> ÁîöËá≥ÊòØ <code>CONFIG_KALLSYMS_ALL</code> ÈÉΩËÆæÁΩÆ‰∏∫ ‚Äúy‚ÄùÔºåÂõ†‰∏∫ <code>kallsyms_lookup_name()</code> ÂáΩÊï∞Ë¢´ÂÜÖÊ†∏ÈáåÁöÑ kprobe Âú∞ÂùÄËß£Êûê‰ª£Á†Å‰ΩøÁî®„ÄÇ</p>
<!--
If you need to insert a probe in the middle of a function, you may find
it useful to ‚ÄúCompile the kernel with debug info‚Äù (CONFIG_DEBUG_INFO),
so you can use ‚Äúobjdump -d -l vmlinux‚Äù to see the source-to-object
code mapping.
ÁñëÊÉëÔºöyou may find it useful to ...Ôºàit ‰ª£ËØçÔºåÊåáÂêéÈù¢ÁöÑ‰ªéÂè•Ôºâ
-->
<p>Â¶ÇÊûú‰Ω†ÈúÄË¶ÅÂú®ÂáΩÊï∞‰∏≠Èó¥ÊèíÂÖ• probeÔºå‰πüËÆ∏ÂèëÁé∞‚Äú‰ΩøÁî® debug info ÁºñËØëÂÜÖÊ†∏‚Äù (<code>CONFIG_DEBUG_INFO</code>) ÈùûÂ∏∏ÊúâÁî®ÔºåÂõ†Ê≠§ÂèØ‰ª•‰ΩøÁî® <code>objdump -d -l vmlinux</code> ÂëΩ‰ª§ÂéªÊü•ÁúãÊ∫êÁ†ÅÂà∞ÁõÆÊ†á‰ª£Á†ÅÁöÑÊò†Â∞ÑÂÖ≥Á≥ª„ÄÇ</p>
<!--
API Reference
=============
The Kprobes API includes a ‚Äúregister‚Äù function and an ‚Äúunregister‚Äù
function for each type of probe. The API also includes ‚Äúregister_*probes‚Äù
and ‚Äúunregister_*probes‚Äù functions for (un)registering arrays of probes.
Here are `terse`, mini-man-page specifications for these functions and
the associated probe handlers that you‚Äôll write. See the files in the
samples/kprobes/ sub-directory for examples.
-->
<h2 id="api-ÂèÇËÄÉ">API ÂèÇËÄÉ</h2>
<p>Kprobes API ‰∏∫ÊØèÁßçÊé¢ÈíàÁ±ªÂûãÊèê‰æõ‰∫Ü‰∏Ä‰∏™‚ÄùÊ≥®ÂÜå‚ÄúÂíå‚ÄúÊ≥®ÈîÄ‚ÄùÂáΩÊï∞„ÄÇËøòÂåÖÊã¨ÊâπÈáèÊ≥®ÂÜå„ÄÅÊ≥®ÈîÄÊé¢ÈíàÁöÑ <code>register_*probes</code> Âíå <code>unregister_*probes</code> ÂáΩÊï∞„ÄÇËøôÊúâ‰∫õËø∑‰Ω†ÊâãÂÜå‰ª•ÂèäÂ∞Ü‰ºöÁî®Âà∞ÁöÑÁõ∏ÂÖ≥ÁöÑÊé¢ÈíàÂõûË∞ÉÂáΩÊï∞ÁöÑÁÆÄÁü≠ËØ¥Êòé„ÄÇÁõ∏ÂÖ≥‰æãÂ≠êÔºåÂèØÊü•ÁúãÂú® <code>samples/kprobes/</code> Â≠êÁõÆÂΩïÂÜÖÁöÑÊñá‰ª∂„ÄÇ</p>
<h3 id="register_kprobe">register_kprobe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">register_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Sets a breakpoint at the address kp->addr.  When the breakpoint is
hit, Kprobes calls kp->pre_handler.  After the probed instruction
is single-stepped, Kprobe calls kp->post_handler.  If a fault
occurs during execution of kp->pre_handler or kp->post_handler,
or during single-stepping of the probed instruction, Kprobes calls
kp->fault_handler.  Any or all handlers can be NULL. If kp->flags
is set KPROBE_FLAG_DISABLED, that kp will be registered but disabled,
so, its handlers aren‚Äôt hit until calling enable_kprobe(kp).
-->
<p>Âú® <code>kp-&gt;addr</code> Âú∞ÂùÄËÆæÁΩÆ‰∏Ä‰∏™Êñ≠ÁÇπ„ÄÇÂëΩ‰∏≠Êñ≠ÁÇπÊó∂ÔºåKprobes Ë∞ÉÁî® <code>kp-&gt;pre_handler</code>„ÄÇÂú®Êé¢ÊµãÁöÑÊåá‰ª§ÂçïÊ≠•ÊâßË°åÂêéÔºåKprobe Ë∞ÉÁî® <code>kp-&gt;post_handler</code>„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™ÈîôËØØÂèëÁîüÔºåÂú®ÊâßË°å <code>kp-&gt;pre_handler</code> Êàñ <code>kp-&gt;post_handler</code> ÊúüÈó¥ÔºåÂèàÊàñËÄÖÊòØÂú®ÂçïÊ≠•ÊâßË°åË¢´Êé¢ÊµãÊåá‰ª§ÊúüÈó¥ÔºåKprobes ‰ºöË∞ÉÁî® <code>kp-&gt;fault_handler</code>„ÄÇÊâÄÊúâÂõûË∞ÉÂáΩÊï∞ÈÉΩÂèØ‰ª•ÊòØ <code>NULL</code>„ÄÇÂ¶ÇÊûú <code>kp-&gt;flags</code> ËÆæÁΩÆ‰∏∫  <code>KPROBE_FLAG_DISABLED</code> Ôºå<code>kp</code> Â∞Ü‰ºöË¢´Ê≥®ÂÜå‰∏îÂ§Ñ‰∫éÁ¶ÅÁî®Áä∂ÊÄÅ„ÄÇÊâÄ‰ª• <code>kp</code> ÁöÑÂõûË∞ÉÂáΩÊï∞Âú®Ë∞ÉÁî® <code>enable_kprobe(kp)</code> ‰πãÂâç‰∏ç‰ºöË¢´Ë∞ÉÁî®„ÄÇ</p>
<!--
.. note
	1. With the introduction of the ‚Äúsymbol_name‚Äù field to struct kprobe, the probepoint address resolution will now be taken care of by the kernel. The following will now work:

	kp.symbol_name = "symbol_name";

	(64-bit powerpc `intricacies` such as function descriptors are handled `transparently`)
	2. Use the ‚Äúoffset‚Äù field of struct kprobe if the offset into the symbol
	to install a probepoint is known. This field is used to calculate the
	probepoint.
	3. Specify either the kprobe "symbol_name" OR the "addr". If both are
	specified, kprobe registration will fail with -EINVAL.
	4. With CISC architectures (such as i386 and x86_64), the kprobes code
	does not validate if the kprobe.addr is at an instruction `boundary`.
	Use ‚Äúoffset‚Äù with `caution`.

register_kprobe() returns 0 on success, or a negative errno otherwise.
-->
<p>Ê≥®ÊÑèÔºö</p>
<ol>
<li>
<p>ÈÄöËøáÂºïÂÖ• <code>symbol_name</code> Â≠óÊÆµÊù•ÊûÑÈÄ† kprobeÔºåÊé¢ÊµãÁÇπÂú∞ÂùÄËß£ÊûêÂ∞Ü‰ºöÁî±ÂÜÖÊ†∏Êù•Â§ÑÁêÜ„ÄÇÂèØ‰ª•‰ΩøÁî®‰ª•‰∏ãÂÜÖÂÆπÔºö</p>
<p><code>kp.symbol_name = &quot;symbol_name&quot;;</code></p>
<p>Ôºà64 ‰Ωç powepc ÈîôÁªºÂ§çÊùÇÔºå‰æãÂ¶ÇÈÄèÊòéÂú∞Â§ÑÁêÜÂáΩÊï∞ÊèèËø∞Á¨¶Ôºâ</p>
</li>
<li>
<p>Â¶ÇÊûúÂú®Á¨¶Âè∑‰∏≠Áî®‰∫éÂÆâË£ÖÊé¢ÊµãÁÇπÁöÑÂÅèÁßªÈáèÊòØÂ∑≤Áü•ÁöÑÔºåËØ∑‰ΩøÁî® kprobes ÁªìÊûÑ‰ΩìÁöÑ <code>offset</code> Â≠óÊÆµ„ÄÇËøô‰∏™Â≠óÊÆµÁî®‰∫éËÆ°ÁÆóÊé¢ÊµãÁÇπ„ÄÇ</p>
</li>
<li>
<p>kprobe ÁöÑ <code>symbol_name</code> ÊàñËÄÖ <code>addr</code> Â≠óÊÆµÈÉΩË¢´ÊåáÂÆöÔºåkprobe Ê≥®ÂÜå‰ºöÂ§±Ë¥•‰∏îËøîÂõû <code>EINVAL</code>„ÄÇ</p>
</li>
<li>
<p>‰ΩøÁî® CISC Êû∂ÊûÑÔºàÂ¶ÇÔºöi386Ôºåx86_64ÔºâÔºåkprobes ‰ª£Á†Å‰∏ç‰ºöÈ™åËØÅÔºåÂ¶ÇÊûú <code>kprobe.addr</code> Âú®Êåá‰ª§ËæπÁïå„ÄÇË∞®ÊÖé‰ΩøÁî® <code>offset</code>„ÄÇ</p>
</li>
</ol>
<p><code>register_kprobe()</code> ÂáΩÊï∞ÊàêÂäüËøîÂõû 0ÔºåÂÖ∂‰ªñÊÉÖÂÜµËøîÂõû‰∏Ä‰∏™Ë¥üÁöÑ <code>errno</code>„ÄÇ</p>
<p>Áî®Êà∑ÁöÑ pre-handlerÔºà<code>kp-&gt;pre_handler</code>ÔºâÂáΩÊï∞ÂéüÂûã:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/ptrace.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Called with p pointing to the kprobe associated with the breakpoint,
and regs pointing to the struct containing the registers saved when
the breakpoint was hit.  Return 0 here unless you‚Äôre a Kprobes geek.
-->
<p>Áî®ÊåáÂêë‰∏éÊñ≠ÁÇπÂÖ≥ËÅîÁöÑ kprobe ÊåáÈíà <code>p</code> ‰ª•ÂèäÂëΩ‰∏≠Êñ≠ÁÇπÊó∂‰øùÂ≠òÁöÑÂØÑÂ≠òÂô®ÊåáÈíà <code>regs</code> Ë∞ÉÁî®„ÄÇ</p>
<!-- User‚Äôs post-handler (kp->post_handler): -->
<p>Áî®Êà∑ÁöÑ post-handler Ôºà<code>kp-&gt;post_handler</code>ÔºâÂáΩÊï∞ÂéüÂûãÔºö</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/ptrace.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">post_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
p and regs are as described for the pre_handler.  flags always seems to be zero.
-->
<p><code>p</code> Âíå <code>regs</code> Âêå  <code>pre_handler</code> ÊâÄËø∞„ÄÇ<code>flags</code> ÁúãËµ∑Êù•‰∏ÄÁõ¥ÊòØ 0„ÄÇ</p>
<!--
User‚Äôs fault-handler (kp->fault_handler):
-->
<p>Áî®Êà∑ÁöÑ fault-handler Ôºà<code>kp-&gt;fault_handler</code>ÔºâÂáΩÊï∞ÂéüÂûãÔºö</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/ptrace.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">fault_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapnr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
p and regs are as described for the pre_handler.  trapnr is the
architecture-specific trap number associated with the fault (e.g.,
on i386, 13 for a general protection fault or 14 for a page fault).
Returns 1 if it successfully handled the exception.
-->
<p><code>p</code> Âíå <code>regs</code> Âêå <code>pre_handler</code> ÊâÄËø∞ „ÄÇ <code>trapnr</code> ÊòØÊïÖÈöúÁõ∏ÂÖ≥ÁöÑÁâπÂÆöÊû∂ÊûÑ‰∏ãÁöÑ trap Âè∑Ôºà‰æãÂ¶ÇÔºöÂú® i386 ‰∏äÔºå 13 ‰∏∫ÊôÆÈÄöÈò≤Êä§ÊïÖÈöúÔºå14 ‰∏∫È°µÈù¢ÊïÖÈöúÔºâ„ÄÇÂ¶ÇÊûúÊàêÂäüÁöÑÂ§ÑÁêÜ‰∫ÜÂºÇÂ∏∏ËøîÂõû 1„ÄÇ</p>
<h3 id="register_kretprobe">register_kretprobe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">register_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Establishes a return probe for the function whose address is
rp->kp.addr.  When that function returns, Kprobes calls rp->handler.
You must set rp->maxactive `appropriately` before you call
register_kretprobe(); see ‚ÄúHow Does a Return Probe Work?‚Äù for details.

register_kretprobe() returns 0 on success, or a negative errno otherwise.
-->
<p>‰∏∫ <code>rp-&gt;kp.addr</code> Âú∞ÂùÄÁöÑÂáΩÊï∞Âª∫Á´ã‰∏Ä‰∏™ return Êé¢Èíà„ÄÇÂú®ÂáΩÊï∞ËøîÂõûÊó∂Ôºåkprobes Ë∞ÉÁî® <code>rp-&gt;handler</code> „ÄÇÂú®Ë∞ÉÁî® <code>register_kretprobe()</code> ‰πãÂâçÂøÖÈ°ªËÆæÁΩÆÂêàÈÄÇÁöÑ <code>rp-&gt;maxactive</code>ÔºåÁªÜËäÇÂèÇËÄÉ ‚ÄúReturn Probe Â¶Ç‰ΩïÂ∑•‰ΩúÔºü‚Äù „ÄÇ</p>
<p><code>register_kretprobe()</code> ÊàêÂäüËøîÂõû 0ÔºåÂÖ∂‰ªñÊÉÖÂÜµËøîÂõû‰∏Ä‰∏™Ë¥üÁöÑ <code>errno</code>„ÄÇ</p>
<!--
User‚Äôs return-probe handler (rp->handler):
-->
<p>Áî®Êà∑ÁöÑ return Êé¢ÈíàÂõûË∞ÉÂáΩÊï∞Ôºà<code>rp-&gt;handler</code>ÔºâÂéüÂûãÔºö</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/ptrace.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">kretprobe_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
regs is as described for kprobe.pre_handler.  ri points to the
kretprobe_instance object, of which the following fields may be of interest:

	* ret_addr: the return address
	* rp: points to the corresponding kretprobe object
	* task: points to the corresponding task struct
	* data: points to per return-instance private data; see ‚ÄúKretprobe
	entry-handler‚Äù for details.
-->
<p><code>regs</code> Âêå kprobe.pre_handler ÊèèËø∞ÈÇ£Ê†∑„ÄÇ<code>ri</code> ÊåáÂêë <code>kretprobe_instance</code> ÂØπË±°ÔºåÂÖ∂‰∏≠ÂèØËÉΩÊ∂âÂèä‰ª•‰∏ãÂ≠óÊÆµÔºö</p>
<ul>
<li>ret_addrÔºöËøîÂõûÂú∞ÂùÄ</li>
<li>rpÔºöÊåáÂêëÁõ∏ÂÖ≥ÁöÑ kretprobe ÂØπË±°</li>
<li>taskÔºöÊåáÂêëÁõ∏ÂÖ≥ÁöÑ task ÁªìÊûÑ‰Ωì</li>
<li>dataÔºöÊåáÂêëÊØè‰∏™ return-instace ÁßÅÊúâÊï∞ÊçÆÔºåÁªÜËäÇÂèÇËÄÉ ‚Äúkretprobe entry-handler‚Äù„ÄÇ</li>
</ul>
<!--
The regs_return_value(regs) macro provides a simple abstraction to
`extract` the return value from the `appropriate` register as defined by
the architecture‚Äôs ABI.

The handler‚Äôs return value is currently ignored.
-->
<p><code>regs_return_value(regs)</code> ÂÆèÊèê‰æõ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊäΩË±°ÊñπÊ≥ïÔºå‰ªéÊû∂ÊûÑÁöÑ ABI ÂÆö‰πâÁöÑÂêàÈÄÇÁöÑÂØÑÂ≠òÂô®‰∏≠ÊèêÂèñËøîÂõûÂÄº„ÄÇ</p>
<p>ÁõÆÂâçÔºåÂõûË∞ÉÂáΩÊï∞ÁöÑËøîÂõûÂÄºÊòØË¢´ÂøΩÁï•ÁöÑ„ÄÇ</p>
<h3 id="unregister_probe">unregister_*probe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">	<span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span>	<span class="kt">void</span> <span class="nf">unregister_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="nf">unregister_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Removes the specified probe.  The unregister function can be called
at any time after the probe has been registered.

.. note

	If the functions find an incorrect probe (ex. an unregistered probe),
	they clear the addr field of the probe.
-->
<p>ÁßªÈô§Êé¢Èíà„ÄÇÊ≥®ÈîÄÂáΩÊï∞ÂèØ‰ª•Âú®Êé¢ÈíàË¢´Ê≥®ÂÜåÂêéË∞ÉÁî®„ÄÇ</p>
<p>Ê≥®ÊÑèÔºö<br />
Â¶ÇÊûúËøô‰∫õÂèëÁé∞‰∏Ä‰∏™‰∏çÊ≠£Á°ÆÁöÑÊé¢ÈíàÔºà‰∏çÂåÖÊã¨Êú™Ê≥®ÂÜåÁöÑÊé¢ÈíàÔºâÔºåÂÆÉ‰ª¨‰ºöÊ∏ÖÈô§Êé¢ÈíàÁöÑ <code>addr</code> Â≠óÊÆµ„ÄÇ</p>
<h3 id="register_probes">register_*probes</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">register_kprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">**</span><span class="n">kps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">register_kretprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">**</span><span class="n">rps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Registers each of the num probes in the specified array.  If any
error occurs during registration, all probes in the array, up to
the bad probe, are safely unregistered before the register_*probes
function returns.

	* kps/rps: an array of pointers to `*probe` data structures
	* num: the number of the array entries.

.. note

	You have to allocate(or define) an array of pointers and set all
	of the array entries before using these functions.
-->
<p>Ê≥®ÂÜåÊï∞ÁªÑ‰∏≠ <code>num</code> ‰∏™Êé¢Èíà„ÄÇÂ¶ÇÊûúÂú®Ê≥®ÂÜåÊúüÈó¥ÂèëÁîüÈîôËØØÔºåÂú® <code>register_*probes</code> ÂáΩÊï∞ËøîÂõû‰πãÂâç‰ºöÂÆâÂÖ®Âú∞Ê≥®ÈîÄÊï∞ÁªÑ‰∏≠Â∑≤Ê≥®ÂÜåÁöÑÊé¢ÈíàÔºåÁõ¥Âà∞ÂèëÁîüÈîôËØØÁöÑÊé¢Èíà‰∏∫Ê≠¢„ÄÇ</p>
<ul>
<li><code>kps/rps</code>ÔºöÊåáÂêë <code>*probe</code> Êï∞ÊçÆÁªìÊûÑÁöÑÊåáÈíàÊï∞ÁªÑ</li>
<li><code>num</code>ÔºöÊï∞ÁªÑÁöÑÂ§ßÂ∞è</li>
</ul>
<p>Ê≥®ÊÑèÔºö<br />
ÂøÖÈ°ªÂàÜÈÖçÔºàÊàñÂÆö‰πâÔºâÊåáÈíàÊï∞ÁªÑÔºå‰∏îÂú®‰ΩøÁî®Ëøô‰∫õÂáΩÊï∞‰πãÂâçËÆæÁΩÆÊï∞ÁªÑÁöÑÊâÄÊúâÂÖÉÁ¥†„ÄÇ</p>
<h3 id="unregister_probes">unregister_*probes</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">unregister_kprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">**</span><span class="n">kps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">unregister_kretprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">**</span><span class="n">rps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Removes each of the num probes in the specified array at once.

.. note

	If the functions find some incorrect probes (ex. unregistered
	probes) in the specified array, they clear the addr field of those
	incorrect probes. However, other probes in the array are
	unregistered correctly.
-->
<p>‰∏ÄÊ¨°ÊÄßÁßªÈô§ÊåáÂÆöÊï∞ÁªÑ‰∏≠ <code>num</code> ‰∏™Êé¢Èíà„ÄÇ</p>
<p>Ê≥®ÊÑèÔºö<br />
Â¶ÇÊûúËøô‰∫õÂáΩÊï∞Âú®Êï∞ÁªÑ‰∏≠ÂèëÁé∞‰∏Ä‰∫õ‰∏çÊ≠£Á°ÆÁöÑÊé¢ÈíàÔºàÊØîÂ¶ÇÔºöÊú™Ê≥®ÂÜåÁöÑÊé¢ÈíàÔºâÔºå‰ºöÊ∏ÖÈô§ÈÇ£‰∫õ‰∏çÊ≠£Á°ÆÊé¢ÈíàÁöÑ <code>addr</code> Â≠óÊÆµ„ÄÇÊï∞ÁªÑ‰∏≠ÂÖ∂‰ªñÁöÑÊé¢Èíà‰ºöË¢´Ê≥®ÈîÄÊéâ„ÄÇ</p>
<h3 id="disable_probe">disable_*probe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">disable_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">disable_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Temporarily disables the specified `*probe`. You can enable it again by using enable_*probe(). You must specify the probe which has been registered.
-->
<p>‰∏¥Êó∂Âú∞Á¶ÅÁî®Êüê‰∏™Êé¢Èíà„ÄÇË∞ÉÁî® <code>enable_*probe()</code> ÂáΩÊï∞ÂèØÂÜçÊ¨°ÂêØÁî®„ÄÇÂøÖÈ°ªÊòØÂ∑≤ÁªèÊ≥®ÂÜåÁöÑÊé¢Èíà„ÄÇ</p>
<h3 id="enable_probe">enable_*probe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">enable_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">enable_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Enables <code>*probe</code> which has been disabled by disable_*probe(). You must specify the probe which has been registered.<br />
ÈÄöËøá <code>disable_*probe()</code> ÂêØÁî®Â∑≤ÁªèË¢´Á¶ÅÁî®ÁöÑ <code>*probe</code>„ÄÇÂøÖÈ°ªÊåáÂÆöÂ∑≤ÁªèÊ≥®ÂÜåÁöÑ probe„ÄÇ</p>
<!--
Kprobes Features and Limitations
================================
Kprobes allows multiple probes at the same address. Also,
a probepoint for which there is a post_handler cannot be optimized.
So if you install a kprobe with a post_handler, at an optimized
probepoint, the probepoint will be unoptimized automatically.
-->
<h2 id="kprobes-ÁâπÊÄß‰∏éÈôêÂà∂">Kprobes ÁâπÊÄß‰∏éÈôêÂà∂</h2>
<p>kprobes ÂÖÅËÆ∏Âú®Âêå‰∏Ä‰∏™Âú∞ÂùÄÊèíÂÖ•Â§ö‰∏™Êé¢Èíà„ÄÇÊ≠§Â§ñÔºåÂ∏¶Êúâ <code>post_handler</code> ÁöÑÊé¢ÊµãÁÇπÊó†Ê≥ïË¢´‰ºòÂåñ„ÄÇÊâÄ‰ª•ÔºåÂ¶ÇÊûúÂú®Â∑≤‰ºòÂåñÁöÑÊé¢ÊµãÁÇπÊèíÂÖ•Â∏¶Êúâ <code>post_handler</code> ÂõûË∞ÉÂáΩÊï∞ÁöÑ kprobe Êé¢ÈíàÔºåÊé¢ÊµãÁÇπ‰ºöËá™Âä®Âú∞ÂèòÊàêÊú™‰ºòÂåñÁöÑ„ÄÇ</p>
<!--
In general, you can install a probe anywhere in the kernel.
In particular, you can probe interrupt handlers.  Known exceptions
are discussed in this section.
-->
<p>ÈÄöÂ∏∏ÔºåÂèØ‰ª•Âú®ÂÜÖÊ†∏ÁöÑ‰ªªÊÑè‰ΩçÁΩÆÊèíÂÖ•Êé¢Èíà„ÄÇÁâπÂà´ÁöÑÊòØÔºåÂÆÉÂèØ‰ª•Êé¢Êµã‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞„ÄÇÊú¨ËäÇËÆ®ËÆ∫‰∫ÜÂ∑≤Áü•ÁöÑÂºÇÂ∏∏„ÄÇ</p>
<!--
The register_*probe functions will return -EINVAL if you attempt
to install a probe in the code that implements Kprobes (mostly
kernel/kprobes.c and `arch/*/kernel/kprobes.c`, but also functions such
as do_page_fault and notifier_call_chain).
-->
<p>Â¶ÇÊûúËØïÂõæÂú®ÂÆûÁé∞ Kprobes ÁöÑ‰ª£Á†Å‰∏≠ÊèíÂÖ•‰∏Ä‰∏™Êé¢ÈíàÔºå<code>register_*probe</code> ÂáΩÊï∞Â∞ÜËøîÂõû <code>-EINVAL</code>„ÄÇÔºàÂú® <code>kernel/kprobes.c</code> Âíå <code>arch/*/kernel/kprobes.c</code> Êñá‰ª∂‰∏≠ÔºåËøòÊúâÂÉè <code>do_page_fault</code> Âíå <code>notifier_call_chain</code> ËøôÁ±ªÁöÑÂáΩÊï∞Ôºâ„ÄÇ</p>
<!--
If you install a probe in an inline-able function, Kprobes makes
no attempt to `chase down` all inline instances of the function and
install probes there.  gcc may inline a function without being asked,
so keep this in mind if you‚Äôre not seeing the probe hits you expect.
-->
<p>Â¶ÇÊûúÂú®ÂèØÂÜÖËÅîÁöÑÂáΩÊï∞‰∏≠ÊèíÂÖ•Êé¢ÈíàÔºåKprobes Âπ∂‰∏ç‰ºöÁªôÊâÄÊúâÂÜÖËÅîÂÆû‰æãÊèíÂÖ•Êé¢Èíà„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÂëΩ‰∏≠ÊúüÊúõÁöÑÊé¢ÈíàÔºåËÆ∞‰Ωè‰∏ÄÁÇπÔºå gcc ÂèØËÉΩ‰ºöËá™Âä®ÂÜÖËÅî‰∏Ä‰∏™ÂáΩÊï∞„ÄÇ</p>
<!--
A probe handler can modify the environment of the probed function
-- e.g., by modifying kernel data structures, or by modifying the
contents of the pt_regs struct (which are restored to the registers
upon return from the breakpoint).  So Kprobes can be used, for example,
to install a bug fix or to inject faults for testing.  Kprobes, of
course, has no way to `distinguish` the `deliberately` injected faults
from the accidental ones.  Don't drink and probe.
-->
<p>Êé¢ÈíàÂõûË∞ÉÂáΩÊï∞ÂèØ‰ª•‰øÆÊîπË¢´Ê£ÄÊµãÂáΩÊï∞ÁöÑÁéØÂ¢É &ndash; ‰æãÂ¶ÇÔºåÊîπÂèòÂÜÖÊ†∏Êï∞ÊçÆÁªìÊûÑÊàñËÄÖ <code>pt_regs</code> Êï∞ÊçÆÁªìÊûÑÁöÑÂÜÖÂÆπÔºà‰ªéÊñ≠ÁÇπËøîÂõûÊó∂ÊÅ¢Â§çÂà∞ÂØÑÂ≠òÂô®‰∏≠Ôºâ„ÄÇÂõ†Ê≠§ÔºåKprobes ÂèØÁî®‰∫éÂÆâË£Ö bug ‰øÆÂ§çÊàñÊµãËØïÊó∂Ê≥®ÂÖ•ÈîôËØØ„ÄÇÂΩìÁÑ∂Ôºå Kprobes ÊòØÊ≤°ÊúâÂäûÊ≥ïÊääÊïÖÊÑèÂú∞Ê≥®ÂÖ•ÁöÑÈîôËØØ‰∏éÊÑèÂ§ñÁöÑÈîôËØØÂå∫ÂàÜÂºÄ„ÄÇ‰∏çË¶ÅÂñùÂ§ß‰∫ÜÊêû‰∫ãÊÉÖ„ÄÇ</p>
<!--
Kprobes makes no attempt to prevent probe handlers from stepping on
each other ‚Äî e.g., probing printk() and then calling printk() from a
probe handler.  If a probe handler hits a probe, that second probe‚Äôs
handlers won‚Äôt be run in that instance, and the kprobe.nmissed member
of the second probe will be incremented.
-->
<p>Kprobes ‰∏ç‰ºöÈòªÊ≠¢Êé¢ÈíàÂõûË∞ÉÂáΩÊï∞‰πãÈó¥ÁöÑÁõ∏‰∫í‰ΩúÁî® &ndash; ÊØîÂ¶ÇÔºåÂÖàÁªô <code>printk()</code> ÂáΩÊï∞ÊèíÂÖ•Êé¢ÈíàÔºåÊé•ÁùÄÂèà‰ªéÂè¶‰∏Ä‰∏™Êé¢ÈíàÂõûË∞ÉÂáΩÊï∞‰∏≠Ë∞ÉÁî® <code>printk()</code> ÂáΩÊï∞„ÄÇÂ¶ÇÊûúÊé¢ÈíàÂõûË∞ÉÂáΩÊï∞ÂëΩ‰∏≠‰∏Ä‰∏™Êé¢ÈíàÔºåÈÇ£‰πàËøôÁ¨¨‰∫å‰∏™Êé¢ÈíàÁöÑÂõûË∞ÉÂáΩÊï∞‰∏ç‰ºöÊâßË°åÔºåÂ∞ÜÂè™‰ºöÁ¥ØÂä†Êé¢ÈíàÁöÑ <code>kprobe.nmissed</code> ÂÄº„ÄÇ</p>
<!--
As of Linux v2.6.15-rc1, multiple handlers (or multiple instances of
the same handler) may run concurrently on different CPUs.
-->
<p>Ëá™ Linux v2.6.15-rc1 ÂºÄÂßãÔºåÂ§ö‰∏™ÂõûË∞ÉÂáΩÊï∞ÔºàÊàñËÄÖÁõ∏ÂêåÂõûË∞ÉÂáΩÊï∞ÁöÑÂ§ö‰∏™ÂÆû‰æãÔºâÂèØ‰ª•ÂêåÊó∂Âú®‰∏çÂêåÁöÑ CPU ‰∏äËøêË°å„ÄÇ</p>
<!--
Kprobes does not use `mutexes` or allocate memory except during
registration and unregistration.
-->
<p>Èô§‰∫ÜÊ≥®ÂÜåÂíåÊ≥®ÈîÄÊé¢Èíà‰πãÂ§ñÔºåKprobes ‰∏ç‰ºöÁî®‰∫íÊñ•ÈîÅÊàñÂàÜÈÖçÂÜÖÂ≠ò„ÄÇ</p>
<!--
Probe handlers are run with preemption disabled or interrupt disabled,
which depends on the architecture and optimization state.  (e.g.,
kretprobe handlers and optimized kprobe handlers run without interrupt
disabled on x86/x86-64).  In any case, your handler should not yield
the CPU (e.g., by attempting to `acquire` a `semaphore`, or waiting I/O).
-->
<p>Êé¢ÈíàÂõûË∞ÉÂáΩÊï∞Âú®Á¶ÅÁî®Êä¢Âç†ÊàñËÄÖÁ¶ÅÁî®‰∏≠Êñ≠ÁöÑÊÉÖÂÜµ‰∏ãËøêË°åÔºåËøôÂèñÂÜ≥‰∫éÊû∂ÊûÑ‰ª•Âèä‰ºòÂåñÁä∂ÊÄÅÔºà‰æãÂ¶ÇÔºåkretprobe Âíå‰ºòÂåñÁöÑ kprobe ÂõûË∞ÉÂáΩÊï∞Âú® x86/x86-64 ‰∏äËøêË°åÊó∂Ê≤°ÊúâÁ¶ÅÁî®‰∏≠Êñ≠Ôºâ„ÄÇ‰∏çÁÆ°Â¶Ç‰ΩïÔºå‰Ω†ÁöÑÂõûË∞ÉÂáΩÊï∞ÈÉΩ‰∏çÂ∫îËØ•ËÆ©Âá∫ CPU ÔºàÊØîÂ¶ÇÔºåËØïÂõæËé∑Âèñ‰ø°Âè∑ÈáèÊàñÁ≠âÂæÖ I/OÔºâ„ÄÇ</p>
<!--
Since a return probe is implemented by replacing the return
address with the trampoline's address, stack `backtraces` and calls
to __builtin_return_address() will typically yield the trampoline‚Äôs
address instead of the real return address for kretprobed functions.
(As far as we can tell, __builtin_return_address() is used only for instrumentation
and error reporting.)
-->
<p>Âõ†‰∏∫ return Êé¢ÈíàÊòØÈÄöËøáÊääËπ¶Â∫äÁöÑÂú∞ÂùÄÊõøÊç¢‰∏∫ËøîÂõûÂú∞ÂùÄÊù•ÂÆûÁé∞ÁöÑÔºåÊâÄ‰ª•Â†ÜÊ†àÂõûÊ∫Ø‰ª•ÂèäË∞ÉÁî®  <code>__builtin_return_address()</code> ÂáΩÊï∞ÂæóÂà∞ÁöÑÊòØËπ¶Â∫äÁöÑÂú∞ÂùÄÔºåËÄå‰∏çÊòØ kretprobed ÂáΩÊï∞ÂÆûÈôÖ return Âú∞ÂùÄÔºàÂ∞±ÁõÆÂâçÊàë‰ª¨Áü•ÈÅìÁöÑËÄåË®ÄÔºå<code>__builtin_return_address()</code> ÂáΩÊï∞Âè™Áî®‰∫éÊµãËØïÂ∑•ÂÖ∑ÂíåÊä•ÂëäÈîôËØØÔºâ„ÄÇ</p>
<!--
If the number of times a function is called does not match the number
of times it returns, registering a return probe on that function may
produce `undesirable` results. In such a case, a line:
kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c
gets printed. With this information, one will be able to `correlate` the
exact instance of the kretprobe that caused the problem. We have the
do_exit() case covered. do_execve() and do_fork() are not an issue.
We‚Äôre `unaware of` other specific cases where this could be a problem.
-->
<p>Â¶ÇÊûú‰∏Ä‰∏™ÂáΩÊï∞ÁöÑË∞ÉÁî®Ê¨°Êï∞‰∏çËÉΩÂåπÈÖçËøîÂõûÁöÑÊ¨°Êï∞ÔºåÂú®ÈÇ£‰∏™ÂáΩÊï∞‰∏äÊ≥®ÂÜåÁöÑÊé¢ÈíàÂèØËÉΩ‰∫ßÁîü‰∏çÊÉ≥Ë¶ÅÁöÑÁªìÊûú„ÄÇËøôÁßçÊÉÖÂÜµÔºå‰ºöËæìÂá∫‰∏ÄË°å <code>kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c</code>„ÄÇÊúâ‰∫ÜËøôË°å‰ø°ÊÅØÔºåÂ∞±ÂèØ‰ª•ÂÖ≥ËÅîÂØºËá¥ÈóÆÈ¢òÁöÑ kretprobe ÂÆû‰æã„ÄÇÊ∂µÁõñ‰∫Ü <code>do_exit()</code> ÂáΩÊï∞ÁöÑÊÉÖÂÜµ„ÄÇ <code>do_execve()</code> Âíå <code>do_fork()</code> ÂáΩÊï∞ÈÉΩ‰∏çÊòØÈóÆÈ¢ò„ÄÇÊàë‰ª¨‰∏çÁü•ÈÅìÁöÑÂÖ∂‰ªñÁâπÂÆöÁöÑÊÉÖÂÜµÔºåÂèØËÉΩ‰ºöÂá∫Áé∞ÈóÆÈ¢ò„ÄÇ</p>
<!--
If, upon entry to or exit from a function, the CPU is running on
a stack other than that of the current task, registering a return
probe on that function may produce undesirable results.  For this
reason, Kprobes doesn‚Äôt support return probes (or kprobes)
on the x86_64 version of __switch_to(); the registration functions
return -EINVAL.
-->
<p>Â¶ÇÊûúÂú®ËøõÂÖ•ÊàñËÄÖÈÄÄÂá∫Êüê‰∏™ÂáΩÊï∞Êó∂ÔºåCPU Âú®Èô§ÂΩìÂâç task ‰ª•Â§ñÁöÑÂ†ÜÊ†à‰∏äËøêË°åÔºåÈÇ£Âú®Ëøô‰∏™ÂáΩÊï∞‰∏äÊ≥®ÂÜå return Êé¢ÈíàÂèØËÉΩ‰ºö‰∫ßÁîü‰∏çÊÉ≥Ë¶ÅÁöÑÁªìÊûú„ÄÇÂõ†‰∏∫Ëøô‰∏™ÂéüÂõ†ÔºåKprobes ‰∏çÊîØÊåÅ <code>__switch_to()</code> ÂáΩÊï∞ x86_64 ÁâàÊú¨ÁöÑ return Êé¢ÈíàÔºàÊàñ kprobesÔºâÔºåÊ≥®ÂÜåÂáΩÊï∞‰ºöËøîÂõû <code>-EINVAL</code> „ÄÇ</p>
<!--
On x86/x86-64, since the Jump Optimization of Kprobes modifies
instructions widely, there are some limitations to optimization. To
explain it, we introduce some `terminology`. Imagine a 3-instruction
sequence consisting of a two 2-byte instructions and one 3-byte
instruction.
-->
<p>Âú® x86/x86-64 Êû∂ÊûÑ‰∏äÔºåÁî±‰∫é Kprobes Ë∑≥ËΩ¨‰ºòÂåñ‰øÆÊîπÊåá‰ª§ÊôÆÈÅçÂ≠òÂú®Ôºå‰ºöÂØπ‰ºòÂåñÊúâ‰∏Ä‰∫õÈôêÂà∂„ÄÇ‰∏∫Ëß£ÈáäËøô‰∏ÄÁÇπÔºåÊàë‰ª¨ÂºïÂÖ•‰∫õÊúØËØ≠„ÄÇÊÉ≥Ë±°‰∏Ä‰∏ãÔºå‰∏Ä‰∏™Áî± 2 Â≠óËäÇÊåá‰ª§Âíå 3 Â≠óËäÇÊåá‰ª§ÁªÑÊàêÁöÑ 3 ‰∏™Êåá‰ª§Â∫èÂàó„ÄÇ</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">	    <span class="n">IA</span>
	    <span class="o">|</span>
<span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">5</span><span class="p">][</span><span class="mi">6</span><span class="p">][</span><span class="mi">7</span><span class="p">]</span>
	    <span class="p">[</span><span class="n">ins1</span><span class="p">][</span><span class="n">ins2</span><span class="p">][</span>  <span class="n">ins3</span> <span class="p">]</span>
	    <span class="p">[</span><span class="o">&lt;-</span>     <span class="n">DCR</span>       <span class="o">-&gt;</span><span class="p">]</span>
	    <span class="p">[</span><span class="o">&lt;-</span> <span class="n">JTPR</span> <span class="o">-&gt;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">ins1</span><span class="p">:</span> <span class="mi">1</span><span class="n">st</span> <span class="n">Instruction</span>
<span class="nl">ins2</span><span class="p">:</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">Instruction</span>
<span class="nl">ins3</span><span class="p">:</span> <span class="mi">3</span><span class="n">rd</span> <span class="n">Instruction</span>
<span class="nl">IA</span><span class="p">:</span>  <span class="n">Insertion</span> <span class="n">Address</span>
<span class="nl">JTPR</span><span class="p">:</span> <span class="n">Jump</span> <span class="n">Target</span> <span class="n">Prohibition</span> <span class="n">Region</span>
<span class="nl">DCR</span><span class="p">:</span> <span class="n">Detoured</span> <span class="n">Code</span> <span class="n">Region</span>
</code></pre></td></tr></table>
</div>
</div><!--
The instructions in DCR are copied to the out-of-line buffer
of the kprobe, because the bytes in DCR are replaced by
a 5-byte jump instruction. So there are several limitations.

	a) The instructions in DCR must be relocatable.
	b) The instructions in DCR must not include a call instruction.
	c) JTPR must not be targeted by any jump or call instruction.
	d) DCR must not `straddle` the border between functions.

Anyway, these limitations are checked by the in-kernel instruction
decoder, so you don‚Äôt need to worry about that.
-->
<p>DCR ÂÜÖÁöÑÊåá‰ª§Ë¢´Â§çÂà∂Âà∞ kprobe ÁöÑÁ¶ªÁ∫øÁºìÂÜ≤Âå∫‰∏≠ÔºåÂõ†‰∏∫ DCR ÂÜÖÁöÑÂ≠óËäÇË¢´ 5 Â≠óËäÇ jump Êåá‰ª§Êõø‰ª£‰∫Ü„ÄÇÊâÄ‰ª•ÔºåËøôÂÑø‰ºöÊúâÂá†‰∏™ÈôêÂà∂„ÄÇ</p>
<ul>
<li>DCR ÂÜÖÁöÑÊåá‰ª§‰∏ÄÂÆöÊòØÂèØÈáçÂÆö‰ΩçÁöÑ</li>
<li>DCR ÂÜÖÁöÑÊåá‰ª§‰∏ÄÂÆö‰∏çËÉΩÂåÖÂê´ <code>call</code> Êåá‰ª§</li>
<li>JTPR ‰∏çËÉΩ‰Ωú‰∏∫ <code>jump</code> Êàñ <code>call</code> Êåá‰ª§ÁöÑÁõÆÊ†á</li>
<li>DCR ‰∏çËÉΩË∑®Ë∂äÂáΩÊï∞‰πãÈó¥ÁöÑËæπÁïå</li>
</ul>
<p>‰∏çËøáÔºåËøô‰∫õÈôêÂà∂Áî±ÂÜÖÊ†∏ÁöÑÊåá‰ª§Ëß£Á†ÅÂô®Ê£ÄÊü•ÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅÂÖ≥ÂøÉËøô‰∫õÈôêÂà∂„ÄÇ</p>
<!--
Probe Overhead
==============
On a typical CPU in use in 2005, a kprobe hit takes 0.5 to 1.0
microseconds to process.  Specifically, a benchmark that hits the same
probepoint repeatedly, firing a simple handler each time, reports 1-2
million hits per second, depending on the architecture.  A return-probe
hit typically takes 50-75% longer than a kprobe hit.
When you have a return probe set on a function, adding a kprobe at
the entry to that function adds `essentially` no overhead.

Here are sample overhead `figures` (in usec) for different architectures:
-->
<h2 id="Êé¢ÈíàÁöÑÂºÄÈîÄ">Êé¢ÈíàÁöÑÂºÄÈîÄ</h2>
<p>Âú® 2005 Âπ¥Â∏∏ËßÅÁöÑ CPU ‰∏äÔºåÂ§ÑÁêÜÂëΩ‰∏≠ kprobe Ë¶ÅËä±Ë¥π 0.5 - 1.0 ÂæÆÁßí„ÄÇÂÖ∑‰Ωì‰∏ÄÁÇπÔºåÂü∫ÂáÜÊµãËØïÂèçÂ§çÂëΩ‰∏≠Âêå‰∏Ä‰∏™Êé¢ÊµãÁÇπÔºåÊØè‰∏ÄÊ¨°Ëß¶ÂèëÁÆÄÂçïÁöÑÂõûË∞ÉÂáΩÊï∞ÔºåÊØèÁßí 1-2 Áôæ‰∏áÊ¨°ÂëΩ‰∏≠ÔºåÂÖ∑‰ΩìÊï∞ÂÄºÂèñÂÜ≥‰∫é CPU Êû∂ÊûÑ„ÄÇÈÄöÂ∏∏ÔºåÂëΩ‰∏≠ return Êé¢ÈíàÊØîÂëΩ‰∏≠ kprobe Â§öËä±Ë¥π 50-75% ÁöÑÊó∂Èó¥„ÄÇÂΩì‰Ω†Êää‰∏Ä‰∏™ kretprobe ÊèíÂÖ•Âà∞‰∏Ä‰∏™ÂáΩÊï∞ÁöÑÊó∂ÂÄôÔºåÂÆûÈôÖÊòØÂú®ÂáΩÊï∞ÂÖ•Âè£Â§ÑÊ∑ªÂä†‰∏Ä‰∏™ kprobeÔºåÂü∫Êú¨‰∏ä‰∏äÂáΩÊï∞‰∏ç‰ºöÂ¢ûÂä†ÂºÄÈîÄ„ÄÇ</p>
<p>‰∏ãÈù¢Êúâ‰∫õ‰∏çÂêåÊû∂ÊûÑÂºÄÈîÄÁöÑÊ†∑Êú¨ÔºàÂæÆÁßíÔºâÔºö</p>
<pre><code>k = kprobe; r = return probe; kr = kprobe + return probe
on same function

i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips
k = 0.57 usec; r = 0.92; kr = 0.99

x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips
k = 0.49 usec; r = 0.80; kr = 0.82

ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU)
k = 0.77 usec; r = 1.26; kr = 1.45
</code></pre>
<!--
Optimized Probe Overhead
========================
Typically, an optimized kprobe hit takes 0.07 to 0.1 microseconds to
process. Here are sample overhead figures (in usec) for x86 architectures:
-->
<h2 id="Â∑≤‰ºòÂåñÊé¢ÈíàÂºÄÈîÄ">Â∑≤‰ºòÂåñÊé¢ÈíàÂºÄÈîÄ</h2>
<p>ÈÄöÂ∏∏ÔºåÂëΩ‰∏≠Â∑≤‰ºòÂåñÁöÑ kprobe Ë¶ÅËä±Ë¥π 0.07 - 0.1 ÂæÆÂ¶ôÊù•Â§ÑÁêÜ„ÄÇËøôÊòØ x86 Êû∂ÊûÑÂºÄÈîÄÁöÑÊ†∑Êú¨ÔºàÂæÆÂ¶ôÔºâÔºö</p>
<pre><code>k = unoptimized kprobe, b = boosted (single-step skipped), o = optimized kprobe,
r = unoptimized kretprobe, rb = boosted kretprobe, ro = optimized kretprobe.

i386: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips
k = 0.80 usec; b = 0.33; o = 0.05; r = 1.10; rb = 0.61; ro = 0.33

x86-64: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips
k = 0.99 usec; b = 0.43; o = 0.06; r = 1.24; rb = 0.68; ro = 0.30
</code></pre>
<h2 id="todo">TODO</h2>
<!--
a. SystemTap (http://sourceware.org/systemtap): Provides a simplified
programming interface for probe-based instrumentation.  Try it out.
b. Kernel return probes for sparc64.
c. Support for other architectures.
d. User-space probes.
e. Watchpoint probes (which fire on data references).
-->
<pre><code>1. [SystemTap](http://sourceware.org/systemtap)ÔºöÁªôÂü∫‰∫éÊé¢ÈíàÁöÑÊé¢ÊµãÂ∑•ÂÖ∑Êèê‰æõ‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÁöÑÁºñÁ®ãÊé•Âè£„ÄÇÂèØ‰ª•ËØï‰∏Ä‰∏ã
2. sparc64 Êû∂ÊûÑÁöÑ kretprobe
3. ÊîØÊåÅÂÖ∂‰ªñÊû∂ÊûÑ
4. Áî®Êà∑Á©∫Èó¥ÁöÑÊé¢Èíà
5. ËßÇÂØüÁÇπÊé¢ÈíàÔºàÂú®Êï∞ÊçÆÂºïÁî®Êó∂Ëß¶ÂèëÔºâ
</code></pre>
<h2 id="kprobes-‰æãÂ≠ê">Kprobes ‰æãÂ≠ê</h2>
<p>ËßÅ <a href="https://github.com/torvalds/linux/blob/master/samples/kprobes/kprobe_example.c">samples/kprobes/kprobe_example.c</a> Êñá‰ª∂</p>
<h2 id="kretprobes-‰æãÂ≠ê">Kretprobes ‰æãÂ≠ê</h2>
<p>ËßÅ <a href="https://github.com/torvalds/linux/blob/master/samples/kprobes/kretprobe_example.c">samples/kprobes/kretprobe_example.c</a> Êñá‰ª∂</p>
<!--
For additional information on Kprobes, `refer to` the following URLs:
-->
<p>ÊúâÂÖ≥ Kprobes ÁöÑÂÖ∂‰ªñ‰ø°ÊÅØÔºåËØ∑ÂèÇËÄÉ‰ª•‰∏ã URL ÈìæÊé•Ôºö</p>
<ul>
<li><a href="http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe">http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe</a></li>
<li><a href="http://www.redhat.com/magazine/005mar05/features/kprobes/">http://www.redhat.com/magazine/005mar05/features/kprobes/</a></li>
<li><a href="http://www-users.cs.umn.edu/~boutcher/kprobes/">http://www-users.cs.umn.edu/~boutcher/kprobes/</a></li>
<li><a href="http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf">http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf</a> (pages 101-115)</li>
</ul>
<!--
Deprecated Features
===================
Jprobes is now a `deprecated` feature. People who are depending on it should
migrate to other tracing features or use older kernels. Please consider to
migrate your tool to one of the following options:

* Use trace-event to trace target function with arguments.

  trace-event is a low-overhead (and almost no visible overhead if it
  is off) statically defined event interface. You can define new events
  and trace it via ftrace or any other tracing tools.

  See the following urls:

    - https://lwn.net/Articles/379903/
    - https://lwn.net/Articles/381064/
    - https://lwn.net/Articles/383362/

* Use ftrace dynamic events (kprobe event) with perf-probe.

  If you build your kernel with debug info (CONFIG_DEBUG_INFO=y), you can
  find which register/stack is assigned to which local variable or arguments
  by using perf-probe and set up new event to trace it.

  See following documents:

	* Documentation/trace/kprobetrace.rst
	* Documentation/trace/events.rst
	* tools/perf/Documentation/perf-probe.txt
-->
<h2 id="Â∑≤ÂºÉÁî®ÁöÑÊú∫Âà∂">Â∑≤ÂºÉÁî®ÁöÑÊú∫Âà∂</h2>
<p>Áé∞Âú® Jprobes ÊòØ‰∏Ä‰∏™‰∏çË¢´Êé®ËçêÁöÑÊú∫Âà∂„ÄÇ‰æùËµñÂÆÉÁöÑÂ∫îËØ•ËøÅÁßªÂà∞ÂÖ∂‰ªñËøΩË∏™Êú∫Âà∂Êàñ‰ΩøÁî®ÊóßÁöÑÂÜÖÊ†∏„ÄÇËØ∑ËÄÉËôëÊää‰Ω†ÁöÑÂ∑•ÂÖ∑ËøÅÁßªÂà∞‰ª•‰∏ãÂ∑•ÂÖ∑‰∏≠Ôºö</p>
<ul>
<li>‰ΩøÁî® trace-event ËøΩË∏™Â∏¶ÂèÇÊï∞ÁöÑÂáΩÊï∞</li>
</ul>
<blockquote>
<p>trace-event ÊòØ‰∏™‰ΩéÂºÄÈîÄÁöÑÈùôÊÄÅÂÆö‰πâÁöÑ‰∫ã‰ª∂Êé•Âè£ÔºàÂ¶ÇÊûúÂÖ≥Èó≠ÔºåÊ≤°ÊúâÊòéÊòæÁöÑÂºÄÈîÄÔºâ„ÄÇ‰Ω†ÂèØ‰ª•ÂÆö‰πâÊñ∞‰∫ã‰ª∂ÔºåÈÄöËøá ftrace ÊàñËÄÖÂÖ∂‰ªñËøΩË∏™Â∑•ÂÖ∑ËøΩË∏™ÂÆÉ„ÄÇ<br />
ÂèÇËÄÉ‰ª•‰∏ã URL ÈìæÊé•Ôºö<br />
- <a href="https://lwn.net/Articles/379903/">https://lwn.net/Articles/379903/</a><br />
- <a href="https://lwn.net/Articles/381064/">https://lwn.net/Articles/381064/</a><br />
- <a href="https://lwn.net/Articles/383362/">https://lwn.net/Articles/383362/</a></p>
</blockquote>
<ul>
<li>‰ΩøÁî® ftrace Âä®ÊÄÅ‰∫ã‰ª∂Ôºàkprobe ‰∫ã‰ª∂ÔºâÂíå perf-probe</li>
</ul>
<blockquote>
<p>Â¶ÇÊûú‰Ω†‰ΩøÁî®Ë∞ÉËØï‰ø°ÊÅØÔºà<code>CONFIG_DEBUG_INFO=y</code>ÔºâÁºñËØë‰Ω†ÁöÑÂÜÖÊ†∏ÔºåÂèØ‰ª•Áî® perf-probe ËÆæÁΩÆÊñ∞‰∫ã‰ª∂ÂéªËøΩË∏™ÂÆÉÔºåËÉΩÂèëÁé∞ÂØÑÂ≠òÂô®/Ê†àË¢´ÂàÜÈÖçÁªô‰∫ÜÂì™‰∏™Êú¨Âú∞ÂèòÈáèÊàñËÄÖÂèÇÊï∞„ÄÇ<br />
ÂèÇËÄÉ‰ª•‰∏ãÊñáÊ°£Ôºö<br />
- <a href="https://github.com/torvalds/linux/blob/master/Documentation/trace/kprobetrace.rst">Documentation/trace/kprobetrace.rst</a><br />
- <a href="https://github.com/torvalds/linux/blob/master/Documentation/trace/events.rst">Documentation/trace/events.rst</a><br />
- <a href="https://github.com/torvalds/linux/blob/master/tools/perf/Documentation/perf-probe.txt">tools/perf/Documentation/perf-probe.txt</a></p>
</blockquote>
<!--
The kprobes debugfs interface
=============================
With recent kernels (> 2.6.20) the list of registered kprobes is visible
under the /sys/kernel/debug/kprobes/ directory (assuming debugfs is mounted at //sys/kernel/debug).

/sys/kernel/debug/kprobes/list: Lists all registered probes on the system:
-->
<h2 id="kprobes-debugfs-Êé•Âè£">kprobes debugfs Êé•Âè£</h2>
<p>ÊúÄÊñ∞ÁöÑÂÜÖÊ†∏Ôºà&gt; 2.6.20ÔºâÔºåÂ∑≤ÁªèÊ≥®ÂÜåÁöÑ kprobes ÂàóË°®‰Ωç‰∫é <code>/sys/kernel/debug/kprobes/</code> ÁõÆÂΩï‰πã‰∏ãÔºàÂÅáËÆæ debugfs Ë¢´ÊåÇËΩΩÂà∞ <code>/sys/kernel/debug</code> ÁõÆÂΩïÔºâ„ÄÇ</p>
<p><code>/sys/kernel/debug/kprobes/list</code>ÔºöÂàóÂá∫Âú®Á≥ªÁªü‰∏äÊâÄÊúâÂ∑≤Ê≥®ÂÜåÁöÑ probesÔºö</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">c015d71a</span>  <span class="n">k</span>  <span class="n">vfs_read</span><span class="o">+</span><span class="mh">0x0</span>
<span class="n">c03dedc5</span>  <span class="n">r</span>  <span class="n">tcp_v4_rcv</span><span class="o">+</span><span class="mh">0x0</span>
</code></pre></td></tr></table>
</div>
</div><!--
The first column provides the kernel address where the probe is inserted.
The second column identifies the type of probe (k - kprobe and r - kretprobe)
while the third column specifies the symbol+offset of the probe.
If the probed function belongs to a module, the module name is also
specified. Following columns show probe status. If the probe is on
a virtual address that is no longer valid (module init sections, module
virtual addresses that correspond to modules that‚Äôve been unloaded),
such probes are marked with [GONE]. If the probe is temporarily disabled,
such probes are marked with [DISABLED]. If the probe is optimized, it is
marked with [OPTIMIZED]. If the probe is ftrace-based, it is marked with
[FTRACE].
-->
<p>Á¨¨‰∏ÄÂàóÔºåÊòØÂ∑≤ÊèíÂÖ•Êé¢ÈíàÁöÑÂÜÖÊ†∏Âú∞ÂùÄ„ÄÇÁ¨¨‰∫åÂàóÔºåÊòØË°®Á§∫Êé¢ÈíàÁöÑÁ±ªÂûãÔºàk - kprobeÔºår - kretprobeÔºâ„ÄÇÁ¨¨‰∏âÂàóÔºåÊòØÊåáÂÆöÊé¢ÈíàÁöÑÁ¨¶Âè∑+ÂÅèÁßªÈáèÔºàsymbol+offsetÔºâ„ÄÇÂ¶ÇÊûúË¢´Êé¢ÊµãÁöÑÂáΩÊï∞Â±û‰∫é‰∏Ä‰∏™Ê®°ÂùóÔºåÈÇ£‰πàËøô‰∏™Ê®°ÂùóÁöÑÂêçÂ≠ó‰πü‰ºöË¢´ÂàóÂá∫Êù•„ÄÇÈöèÂêéÁöÑÂá†ÂàóÊòæÁ§∫Êé¢ÈíàÁöÑÁä∂ÊÄÅ„ÄÇÂ¶ÇÊûúÊé¢ÈíàÂú®ËôöÊãüÂú∞ÂùÄ‰∏äÔºåÂπ∂‰∏îÂú∞ÂùÄÊó†ÊïàÔºàÊ®°ÂùóÂàùÂßãÂåñÈÉ®ÂàÜÔºåÊ®°ÂùóËôöÊãüÂú∞ÂùÄÔºåÂØπÂ∫îÁöÑÊ®°ÂùóÂ∑≤ÁªèÂç∏ËΩΩÔºâÔºåËøôÁ±ªÊé¢Èíà‰ºöË¢´Ê†áËÆ∞‰∏∫ [GONE]„ÄÇÂ¶ÇÊûúÊé¢Èíà‰∏¥Êó∂Ë¢´Á¶ÅÁî®Ôºå‰ºöË¢´Ê†áËÆ∞‰∏∫ [DISABLED]„ÄÇÂ¶ÇÊûúÊé¢ÈíàË¢´‰ºòÂåñ‰∫ÜÔºå‰ºöË¢´Ê†áËÆ∞‰∏∫ [OPTIMIZED]„ÄÇÂ¶ÇÊûúÊé¢ÈíàÊòØÂü∫‰∫é ftrace ÁöÑÔºå‰ºöË¢´Ê†áËÆ∞‰∏∫ [FTRACE]„ÄÇ</p>
<!--
/sys/kernel/debug/kprobes/enabled: Turn kprobes ON/OFF forcibly.
-->
<p><code>/sys/kernel/debug/kprobes/enabled</code>ÔºöÂº∫Âà∂ÂºÄÂêØ/ÂÖ≥Èó≠ kprobes„ÄÇ</p>
<!--
Provides a knob to globally and forcibly turn registered kprobes ON or OFF.
By default, all kprobes are enabled. By echoing ‚Äú0‚Äù to this file, all
registered probes will be `disarmed`, till such time a ‚Äú1‚Äù is echoed to this
file. Note that this knob just disarms and arms all kprobes and doesn‚Äôt
change each probe‚Äôs disabling state. This means that disabled kprobes (marked
[DISABLED]) will be not enabled if you turn ON all kprobes by this knob.
-->
<p>Êèê‰æõ‰∏Ä‰∏™ÂÖ®Â±ÄÊåâÈíÆÔºåÂº∫Âà∂ÁöÑÂºÄÂêØÊàñÂÖ≥Èó≠Â∑≤Ê≥®ÂÜåÁöÑ kprobes„ÄÇÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåÊâÄÊúâ kprobes ÊòØÂºÄÂêØÁöÑ„ÄÇËæìÂá∫ ‚Äú0‚Äù Âà∞Ëøô‰∏™Êñá‰ª∂ÔºåÊâÄÊúâÂ∑≤Ê≥®ÂÜåÁöÑÊé¢Èíà‰ºöË¢´Âç∏ËΩΩÔºåËæìÂá∫ ‚Äú1‚Äù Âà∞Ëøô‰∏™Êñá‰ª∂ÔºåÂèàÈáçÊñ∞Âä†ËΩΩ„ÄÇËØ∑Ê≥®ÊÑèÔºåËøô‰∏™ÊåâÈíÆÂè™ÊòØÂç∏ËΩΩÂíåÂä†ËΩΩÊâÄÊúâ kprobesÔºåÂπ∂‰∏ç‰ºöÊîπÂèòÊØè‰∏™Êé¢ÈíàÁöÑÁ¶ÅÁî®Áä∂ÊÄÅ„ÄÇÊÑèÊÄùÊòØÔºåÂ∑≤ÁªèÁ¶ÅÁî®ÁöÑÊé¢ÈíàÔºàÊ†áËÆ∞‰∏∫ [DISABLED]ÔºâÊòØ‰∏ç‰ºöË¢´ÊøÄÊ¥ªÁöÑ„ÄÇ</p>
<!--
The kprobes sysctl interface
============================
/proc/sys/debug/kprobes-optimization: Turn kprobes optimization ON/OFF.

When CONFIG_OPTPROBES=y, this sysctl interface `appears` and it provides
a knob to globally and forcibly turn jump optimization (see section
:ref:`kprobes_jump_optimization`) ON or OFF. By default, jump optimization
is allowed (ON). If you echo ‚Äú0‚Äù to this file or set
‚Äúdebug.kprobes_optimization‚Äù to 0 via sysctl, all optimized probes will be
unoptimized, and any new probes registered after that will not be optimized.

Note that this knob changes the optimized state. This means that optimized
probes (marked [OPTIMIZED]) will be unoptimized ([OPTIMIZED] tag will be
removed). If the knob is turned on, they will be optimized again.
-->
<h2 id="kprobes-sysctl-Êé•Âè£">kprobes sysctl Êé•Âè£</h2>
<p><code>/proc/sys/debug/kprobes-optimization</code>Ôºö kprobes ‰ºòÂåñÂºÄÂÖ≥„ÄÇ</p>
<p>Âú® <code>CONFIG_OPTPROBES=y</code> ÁöÑÊó∂ÂÄôÔºå <code>sysctl</code> Êé•Âè£Êèê‰æõ‰∏Ä‰∏™ÂÖ®Â±ÄÊåâÈíÆÔºåÂº∫Âà∂ÁöÑÂºÄÂêØÊàñÂÖ≥Èó≠Ë∑≥ËΩ¨‰ºòÂåñÔºàÊü•ÁúãË∑≥ËΩ¨Á´†ËäÇÔºâ„ÄÇÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåË∑≥ËΩ¨‰ºòÂåñÊòØÂºÄÂêØÁöÑ„ÄÇÂ¶ÇÊûúËæìÂá∫ ‚Äú0‚Äù Âà∞Ëøô‰∏™Êñá‰ª∂ÊàñËÄÖÈÄöËøá <code>sysctl</code> ËÆæÁΩÆ <code>debug.kprobes_optimization</code> ‰∏∫ 0 ÔºåÊâÄÊúâ‰ºòÂåñÁöÑÊé¢ÈíàÂ∞Ü‰ºöÂèòÊàêÊú™‰ºòÂåñÁöÑÔºåËÄå‰∏îÂú®Ëøô‰πãÂêé‰ªª‰ΩïÊñ∞ÁöÑË¢´Ê≥®ÂÜåÁöÑÊé¢ÈíàÈÉΩ‰∏ç‰ºöË¢´‰ºòÂåñ„ÄÇ</p>
<p>Ê≥®ÊÑèÔºåËøô‰∏™ÊåâÈíÆ‰ºöÊîπÂèò‰ºòÂåñÁä∂ÊÄÅ„ÄÇË°®Á§∫Â∑≤‰ºòÂåñÁöÑÊé¢ÈíàÔºàÊ†áËÆ∞‰∏∫ [OPTIMIZED]ÔºâÂ∞ÜÂèòÊàêÊú™‰ºòÂåñÁöÑÔºàÊ†áËÆ∞ [OPTIMIZED] ‰ºöË¢´ÁßªÈô§Ôºâ„ÄÇÂ¶ÇÊûúÊåâÈíÆË¢´ÊâìÂºÄÔºåÊé¢ÈíàÂ∞ÜÂÜçÊ¨°Ë¢´‰ºòÂåñ„ÄÇ</p>
<div class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn:1" role="doc-endnote">
<p>ÊúâÈÉ®ÂàÜÂÜÖÊ†∏‰ª£Á†ÅÊòØ‰∏çËÉΩË¢´ÊçïËé∑ÁöÑÔºåËØ¶ÊÉÖËßÅ<a href="#%E9%BB%91%E5%90%8D%E5%8D%95">ÈªëÂêçÂçï</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>ËØ∑ÊÉ≥Ë±°Á¨¨‰∫å‰∏™Êåá‰ª§Ë¢´‰∏≠Êñ≠ÔºåÁÑ∂Âêé‰ºòÂåñÂô®Âú®‰∏≠Êñ≠ÂõûË∞ÉÂáΩÊï∞Ê≠£Âú®ËøêË°åÁöÑÊó∂ÂÄôÁî®Ë∑≥ËΩ¨Âú∞ÂùÄÊõøÊç¢ÂÆÉ„ÄÇÂΩì‰∏≠Êñ≠ËøîÂõûÂà∞ÂéüÂßãÂú∞ÂùÄÊó∂ÔºåÊ≤°ÊúâÊúâÊïàÊåá‰ª§ÔºåËøô‰ºöÂØºËá¥‰∏Ä‰∏™ÊÑèÂ§ñÁöÑÁªìÊûú„ÄÇ <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>‰ºòÂåñÂÆâÂÖ®Ê£ÄÊü•Âú® ksplice Áî®‰∫éÊîØÊåÅ <code>CONFIG_PREEMPT=y</code> ÂÜÖÊ†∏‰∏äÂèØ‰ª•Áî® stop-machine ÊñπÊ≥ïÊõøÊç¢„ÄÇ <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </article>
    
    <script>
  'use strict';
  
  function wrap(el, wrapper) {
    el.parentNode.insertBefore(wrapper, el);
    wrapper.appendChild(el);
  }

  (function () {
    var singleContentsElem = document.querySelector('.single__contents');
    singleContentsElem ? 
    singleContentsElem.querySelectorAll('pre > code').forEach(function(elem) {
      var dataLang = elem.getAttribute('data-lang');
      var dataLangWrapper = document.createElement('div');
      var code = null;
      var codeTitle = null;

      if (dataLang && dataLang.includes(':')) {
        code = dataLang.split(':')[0];
        codeTitle = dataLang.split(':')[1];

        dataLangWrapper.className = 'language-' + code;
        dataLangWrapper.setAttribute('data-lang', codeTitle);

        elem.className = 'language-' + code;
        elem.setAttribute('data-lang', codeTitle);
        elem.setAttribute('id', codeTitle);
      } else if (!dataLang) {
        dataLangWrapper.setAttribute('data-lang', 'Code');
        dataLangWrapper.className = 'language-code';
      }

      if (!dataLang || codeTitle) {
        wrap(elem.parentNode, dataLangWrapper);
      }

    }) : null;
  })();

  var langCodeElem = document.querySelectorAll('.language-code');
  langCodeElem ? langCodeElem.forEach(function (elem) {
    var newElem = document.createElement('span');
    newElem.className = 'copy-to-clipboard';
    newElem.setAttribute('title', 'Copy to clipboard');
    elem.append(newElem);
  }) : null;
  
</script>
    
    
    

    <section class="related">
    
    
    <h1 class="related__title">
      <hr class="hr-dots"/>
      <div>
        See Also
      </div>
      <hr class="hr-dots"/>
    </h1>
    <ul class="related-ul">
        
        <li>
          <a href="/public/posts/trace/an-introduction-to-kprobes/" class="related__link">ËØëÔΩú2005ÔΩú An Introduction to Kprobes</a>
        </li>
        
    </ul>
    
  </section>
    <div class="grow"></div>
<nav class="pagination-single">
  
    
      <a href="https://jayce.github.io/public/posts/trace/an-introduction-to-kprobes/" class="pagination-single__left">
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z"/></svg>
        </div>
        <div class="pagination-single__left-title">ËØëÔΩú2005ÔΩú An Introduction to Kprobes</div>      
      </a>
    
    <div class="grow"></div>
    
      <a href="https://jayce.github.io/public/posts/trace/user-space-probes/" class="pagination-single__right">      
        <div class="pagination-single__right-title">ËØëÔΩú2008ÔΩúUser-Space Probes (Uprobes)</div>
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M5 13h11.17l-4.88 4.88c-.39.39-.39 1.03 0 1.42.39.39 1.02.39 1.41 0l6.59-6.59c.39-.39.39-1.02 0-1.41l-6.58-6.6c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41L16.17 11H5c-.55 0-1 .45-1 1s.45 1 1 1z"/></svg>
        </div>
      </a>
    
  
</nav>
    
  

    <div class="modal micromodal-slide" id="modal" aria-hidden="true">
  <div class="modal__overlay" tabindex="-1" data-micromodal-close>
    <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      
      <div class="modal__content" id="modal-content">
        <div id="mySwipe" class="swipe">
          <div class="swipe-wrap">
          </div>
        </div>
      </div>

      <span class="modal__items">
        
        <span class="modal__header">
          <div class="modal__paging" title="Page Info" aria-label="Current Page">
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--close" title="Close" aria-label="Close Button" data-micromodal-close>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="25" height="25"><path fill="currentColor" d="M 21.734375 19.640625 L 19.636719 21.734375 C 19.253906 22.121094 18.628906 22.121094 18.242188 21.734375 L 13 16.496094 L 7.761719 21.734375 C 7.375 22.121094 6.746094 22.121094 6.363281 21.734375 L 4.265625 19.640625 C 3.878906 19.253906 3.878906 18.628906 4.265625 18.242188 L 9.503906 13 L 4.265625 7.761719 C 3.882813 7.371094 3.882813 6.742188 4.265625 6.363281 L 6.363281 4.265625 C 6.746094 3.878906 7.375 3.878906 7.761719 4.265625 L 13 9.507813 L 18.242188 4.265625 C 18.628906 3.878906 19.257813 3.878906 19.636719 4.265625 L 21.734375 6.359375 C 22.121094 6.746094 22.121094 7.375 21.738281 7.761719 L 16.496094 13 L 21.734375 18.242188 C 22.121094 18.628906 22.121094 19.253906 21.734375 19.640625 Z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--full" title="Full Screen" aria-label="Full Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="25" height="25"><path fill="currentColor" d="M 5 3 C 3.9069372 3 3 3.9069372 3 5 L 3 8 A 1.0001 1.0001 0 1 0 5 8 L 5 5 L 8 5 A 1.0001 1.0001 0 1 0 8 3 L 5 3 z M 16 3 A 1.0001 1.0001 0 1 0 16 5 L 19 5 L 19 8 A 1.0001 1.0001 0 1 0 21 8 L 21 5 C 21 3.9069372 20.093063 3 19 3 L 16 3 z M 3.984375 14.986328 A 1.0001 1.0001 0 0 0 3 16 L 3 19 C 3 20.093063 3.9069372 21 5 21 L 8 21 A 1.0001 1.0001 0 1 0 8 19 L 5 19 L 5 16 A 1.0001 1.0001 0 0 0 3.984375 14.986328 z M 19.984375 14.986328 A 1.0001 1.0001 0 0 0 19 16 L 19 19 L 16 19 A 1.0001 1.0001 0 1 0 16 21 L 19 21 C 20.093063 21 21 20.093063 21 19 L 21 16 A 1.0001 1.0001 0 0 0 19.984375 14.986328 z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--normal" title="Normal Screen" aria-label="Normal Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="25" height="25"><path fill="currentColor" d="M 16.96875 4.972656 C 15.867188 4.988281 14.984375 5.894531 15 7 L 15 15 L 7 15 C 6.277344 14.988281 5.609375 15.367188 5.246094 15.992188 C 4.878906 16.613281 4.878906 17.386719 5.246094 18.007813 C 5.609375 18.632813 6.277344 19.011719 7 19 L 19 19 L 19 7 C 19.007813 6.460938 18.796875 5.941406 18.414063 5.558594 C 18.03125 5.175781 17.511719 4.964844 16.96875 4.972656 Z M 32.96875 4.972656 C 31.921875 4.988281 31.0625 5.8125 31.003906 6.859375 C 31 6.90625 31 6.953125 31 7 L 31 19 L 43 19 C 43.066406 19 43.132813 19 43.199219 18.992188 C 44.269531 18.894531 45.070313 17.972656 45.015625 16.902344 C 44.964844 15.828125 44.074219 14.988281 43 15 L 35 15 L 35 7 C 35.007813 6.460938 34.796875 5.941406 34.414063 5.558594 C 34.03125 5.175781 33.511719 4.964844 32.96875 4.972656 Z M 7 31 C 6.277344 30.988281 5.609375 31.367188 5.246094 31.992188 C 4.878906 32.613281 4.878906 33.386719 5.246094 34.007813 C 5.609375 34.632813 6.277344 35.011719 7 35 L 15 35 L 15 43 C 14.988281 43.722656 15.367188 44.390625 15.992188 44.753906 C 16.613281 45.121094 17.386719 45.121094 18.007813 44.753906 C 18.632813 44.390625 19.011719 43.722656 19 43 L 19 31 Z M 31 31 L 31 43 C 30.988281 43.722656 31.367188 44.390625 31.992188 44.753906 C 32.613281 45.121094 33.386719 45.121094 34.007813 44.753906 C 34.632813 44.390625 35.011719 43.722656 35 43 L 35 35 L 43 35 C 43.722656 35.011719 44.390625 34.632813 44.753906 34.007813 C 45.121094 33.386719 45.121094 32.613281 44.753906 31.992188 C 44.390625 31.367188 43.722656 30.988281 43 31 Z"/></svg>
          </div>
        </span>
        
        <div class="modal__icon modal__arrow modal__arrow--left" title="Arrow Left" aria-label="Arrow Left Button">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 23.28125 11 L 10 10 L 10 6.851563 C 10 6.523438 9.839844 6.277344 9.519531 6.03125 C 9.199219 5.949219 8.878906 5.949219 8.640625 6.113281 C 5.359375 8.410156 2.238281 12.257813 2.160156 12.421875 C 2.082031 12.578125 2.007813 12.8125 2.003906 12.976563 C 2.003906 12.980469 2 12.988281 2 12.992188 C 2 13.15625 2.078125 13.402344 2.160156 13.484375 C 2.238281 13.648438 5.28125 17.507813 8.640625 19.804688 C 8.960938 19.96875 9.28125 20.050781 9.519531 19.886719 C 9.839844 19.722656 10 19.476563 10 19.148438 L 10 16 L 23.28125 15 C 23.679688 14.679688 24 13.875 24 12.992188 C 24 12.195313 23.761719 11.320313 23.28125 11 Z"/></svg>
        </div>
        
        <div class="modal__icon modal__arrow modal__arrow--right" title="Arrow Right" aria-label="Arrow Right Button">

          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 2.71875 11.023438 L 16 10.023438 L 16 6.875 C 16 6.546875 16.160156 6.300781 16.480469 6.054688 C 16.800781 5.972656 17.121094 5.972656 17.359375 6.136719 C 20.640625 8.433594 23.761719 12.28125 23.839844 12.445313 C 23.917969 12.601563 23.992188 12.835938 23.996094 13 C 23.996094 13.003906 24 13.011719 24 13.015625 C 24 13.179688 23.921875 13.425781 23.839844 13.507813 C 23.761719 13.671875 20.71875 17.53125 17.359375 19.828125 C 17.039063 19.992188 16.71875 20.074219 16.480469 19.910156 C 16.160156 19.746094 16 19.5 16 19.171875 L 16 16.023438 L 2.71875 15.023438 C 2.320313 14.703125 2 13.898438 2 13.015625 C 2 12.21875 2.238281 11.34375 2.71875 11.023438 Z"/></svg>
        </div>

        <div class="modal__caption">
          <div class="modal__caption--text">
          </div>
        </div>

      </span>
    </div>
  </div>
</div>


<script defer src="/public/js/swipe.min.08ff2be1b74347bad9e267f732f1388d271b2f9d97b6a8a87bd6a510f17c5ad2.js"></script>

<script defer src="/public/js/micromodal.min.de01b44b2f383056bbcaf6ee921fd385d79108ec1129afd0eb2f3f5a07e11f45.js"></script>

<script defer src="/public/js/helper/fadeinout.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
  
   
  var docElem = document.documentElement;

   
  function openFullscreen() {
    if (docElem.requestFullscreen) {
      docElem.requestFullscreen();
    } else if (docElem.mozRequestFullScreen) {  
      docElem.mozRequestFullScreen();
    } else if (docElem.webkitRequestFullscreen) {  
      docElem.webkitRequestFullscreen();
    } else if (docElem.msRequestFullscreen) {  
      docElem.msRequestFullscreen();
    }
  }

   
  function closeFullscreen() {
    if (document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {  
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {  
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {  
        document.msExitFullscreen();
      }
    }
  }

  var modal = document.getElementById('modal');
  var galleryContainerElem = document.querySelector('.gallery__container');
  var swipeWrapElem = document.querySelector('.swipe-wrap');
  var mySwipeElem = document.getElementById('mySwipe');
  var arrowLeftElem = document.querySelector('.modal__arrow--left');
  var arrowRightElem = document.querySelector('.modal__arrow--right');
  var closeElem = document.querySelector('.modal__toolbar--close');
  var fullElem = document.querySelector('.modal__toolbar--full');
  var normalElem = document.querySelector('.modal__toolbar--normal');
  var captionElem = document.querySelector('.modal__caption');
  var pagingElem = document.querySelector('.modal__paging');
  var itemsElem = document.querySelector('.modal__items');
  var imgTotalNum = null;
  var myFadeTimeout = null;
  var mySwipe = null;
  var keydownFunction = function (e) {
    if (e.key === 'ArrowRight') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.next();
      }
    } else if (e.key === 'ArrowLeft') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.prev();
      }
    }
  }

  if (galleryContainerElem) {
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  } else {
    galleryContainerElem = document.querySelector('.single__contents');
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  }

  MicroModal.init({
    onClose: function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
        closeFullscreen();
      }
      window.removeEventListener('keydown', keydownFunction);
    },
    disableScroll: true,
    disableFocus: true,
    awaitOpenAnimation: false,
    awaitCloseAnimation: false,
    debugMode: false,
  });

  var imageLoad = function(src) {
    return new Promise(function(resolve, reject) {
      var newImg = new Image;
      newImg.onload = function() {
        resolve(newImg);
      }
      newImg.onerror = reject;
      newImg.src = src;
    });
  }

  galleryContainerElem.querySelectorAll('img').forEach(function (elem, idx) {
    elem.style.cursor = 'pointer';

    var clonedElem = elem.cloneNode(true);
    clonedElem.style.maxHeight = '100%';
    clonedElem.style.maxWidth = '100%';
    clonedElem.onclick = function (e) {
      e.stopPropagation();
    }

    var wrapper = document.createElement('div');
    wrapper.style.width = '100%';
    wrapper.style.height = '100vh';
    wrapper.setAttribute('data-micromodal-close', '');
    wrapper.onclick = function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
    }
    wrapper.onmouseenter = function () {
      clearTimeout(myFadeTimeout);
      fadeIn(itemsElem, 200);
    };
    wrapper.onmouseleave = function () {
      myFadeTimeout = setTimeout(function () {
        fadeOut(itemsElem, 200);
      }, 2500);
    }
    wrapper.ontouchstart = function() {
      fadeIn(itemsElem, 200);
    }
    wrapper.append(clonedElem);
    swipeWrapElem.append(wrapper);

    elem.addEventListener('click', async function (e) {
      MicroModal.show('modal');
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }

      var imgSrc = e.target.getAttribute('data-src') || e.target.getAttribute('src');
      var img = await imageLoad(imgSrc);
      clonedElem.style.width = img.width + 'px';
      clonedElem.style.height = img.height + 'px';
      
      
      mySwipe = new Swipe(mySwipeElem, {
        startSlide: idx,
        draggable: true,
        autoRestart: false,
        continuous: false,
        disableScroll: true,
        stopPropagation: true,
        callback: async function (index, element) {
          
          var imgElem = element.querySelector('img');
          var imgSrc = imgElem.getAttribute('data-src') || imgElem.getAttribute('src');
          var img = await imageLoad(imgSrc);
          imgElem.style.width = img.width + 'px';
          imgElem.style.height = img.height + 'px';

          
          if (captionElem && imgElem) {
            var caption = null;
            if (imgElem.getAttribute('data-caption')) {
              caption = imgElem.getAttribute('data-caption');
            } else if (imgElem.getAttribute('title')) {
              caption = imgElem.getAttribute('title');
            } else if (imgElem.getAttribute('alt')) {
              caption = imgElem.getAttribute('alt');
            } else {
              caption = imgElem.getAttribute('src');
            }

            captionElem.querySelector('.modal__caption--text').innerText = caption;
            pagingElem.innerText = (index + 1) + ' / ' + imgTotalNum;

            clearTimeout(myFadeTimeout);
            fadeIn(itemsElem, 200);
          }
        },
      });

      fadeIn(itemsElem);

      
      if (captionElem) {
        var caption = null;
        if (e.target.getAttribute('data-caption')) {
          caption = e.target.getAttribute('data-caption');
        } else if (e.target.getAttribute('title')) {
          caption = e.target.getAttribute('title');
        } else if (e.target.getAttribute('alt')) {
          caption = e.target.getAttribute('alt');
        } else {
          caption = e.target.getAttribute('src');
        }

        captionElem.querySelector('.modal__caption--text').innerText = caption;
        pagingElem.innerText = (idx + 1) + ' / ' + imgTotalNum;
      }

      if (normalElem && fullElem) {
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
      }
    });

    window.addEventListener('keydown', keydownFunction);
  });

  arrowLeftElem ?
    arrowLeftElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.prev();
      }
    }) : null;
  arrowRightElem ?
    arrowRightElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.next();
      }
    }) : null;

  closeElem ?
    closeElem.addEventListener('click', function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
      closeFullscreen();
      MicroModal.close('modal');
    }) : null;

  fullElem ?
    fullElem.addEventListener('click', function (e) {
      openFullscreen();
      if (normalElem) {
        normalElem.style.zIndex = 25;
        normalElem.style.opacity = 1;
        fullElem.style.zIndex = -1;
        fullElem.style.opacity = 0;
      }
    }) : null;

  normalElem ?
    normalElem.addEventListener('click', function (e) {
      closeFullscreen();
      if (fullElem) {
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
      }
    }) : null;
  
});
</script>

    <div class="hide">
      

<div class="search">
  <span class="icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
  </span>
  <input id="search" aria-label="Site Search" class="input" type="text" placeholder="Search" autocomplete="off">
  <div id="search-results" class="dropdown">
    <div id="search-menu" class="dropdown-menu" role="menu">
    </div>
  </div>
</div>


    </div>
  </div>
</main>


<aside class="single__side main-side">
  


<section class="sidebar hide">
  <script>document.querySelector('.sidebar').classList.remove('hide')</script>
  <div class="toc__flexbox" data-position="fixed">
    <h6 class="toc__title" data-ani="true">What&#39;s on this Page</h6>
    
      <label class="switch" data-ani="true">
        <input id="toggle-toc" aria-label="Toggle TOC" type="checkbox" checked>
        <span class="slider round"></span>
      </label>
    
  </div>
  <div class="toc " data-dir="ltr" data-folding="false" data-ani="true">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#ËØëËÄÖÂ∫è">ËØëËÄÖÂ∫è</a></li>
    <li><a href="#Ê¶ÇÂøµ-kprobes-Âíå-return-probes">Ê¶ÇÂøµÔºö Kprobes Âíå Return Probes</a>
      <ul>
        <li><a href="#kprobe-Â¶Ç‰ΩïÂ∑•‰Ωú">Kprobe Â¶Ç‰ΩïÂ∑•‰ΩúÔºü</a></li>
        <li><a href="#ÊîπÂèòÊâßË°åË∑ØÂæÑ">ÊîπÂèòÊâßË°åË∑ØÂæÑ</a></li>
        <li><a href="#return-Êé¢Èíà">Return Êé¢Èíà</a>
          <ul>
            <li><a href="#return-Êé¢ÈíàÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑ">Return Êé¢ÈíàÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑÔºü</a></li>
            <li><a href="#kretprobe-ÂÖ•Âè£ÂõûË∞ÉÂáΩÊï∞">Kretprobe ÂÖ•Âè£ÂõûË∞ÉÂáΩÊï∞</a></li>
          </ul>
        </li>
        <li><a href="#Ë∑≥ËΩ¨‰ºòÂåñÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑ">Ë∑≥ËΩ¨‰ºòÂåñÂ¶Ç‰ΩïÂ∑•‰ΩúÁöÑÔºü</a>
          <ul>
            <li><a href="#ÂàùÂßãÂåñ-kprobe">ÂàùÂßãÂåñ Kprobe</a></li>
            <li><a href="#ÂÆâÂÖ®Ê£ÄÊü•">ÂÆâÂÖ®Ê£ÄÊü•</a></li>
            <li><a href="#ÂáÜÂ§á-detour-ÁºìÂÜ≤Âå∫">ÂáÜÂ§á detour ÁºìÂÜ≤Âå∫</a></li>
            <li><a href="#‰ºòÂåñÂâç">‰ºòÂåñÂâç</a></li>
            <li><a href="#‰ºòÂåñ">‰ºòÂåñ</a></li>
            <li><a href="#ÂèñÊ∂à‰ºòÂåñ">ÂèñÊ∂à‰ºòÂåñ</a></li>
          </ul>
        </li>
        <li><a href="#ÈªëÂêçÂçï">ÈªëÂêçÂçï</a></li>
      </ul>
    </li>
    <li><a href="#ÊîØÊåÅÁöÑÊû∂ÊûÑ">ÊîØÊåÅÁöÑÊû∂ÊûÑ</a></li>
    <li><a href="#ÈÖçÁΩÆ-kprobes">ÈÖçÁΩÆ Kprobes</a></li>
    <li><a href="#api-ÂèÇËÄÉ">API ÂèÇËÄÉ</a>
      <ul>
        <li><a href="#register_kprobe">register_kprobe</a></li>
        <li><a href="#register_kretprobe">register_kretprobe</a></li>
        <li><a href="#unregister_probe">unregister_*probe</a></li>
        <li><a href="#register_probes">register_*probes</a></li>
        <li><a href="#unregister_probes">unregister_*probes</a></li>
        <li><a href="#disable_probe">disable_*probe</a></li>
        <li><a href="#enable_probe">enable_*probe</a></li>
      </ul>
    </li>
    <li><a href="#kprobes-ÁâπÊÄß‰∏éÈôêÂà∂">Kprobes ÁâπÊÄß‰∏éÈôêÂà∂</a></li>
    <li><a href="#Êé¢ÈíàÁöÑÂºÄÈîÄ">Êé¢ÈíàÁöÑÂºÄÈîÄ</a></li>
    <li><a href="#Â∑≤‰ºòÂåñÊé¢ÈíàÂºÄÈîÄ">Â∑≤‰ºòÂåñÊé¢ÈíàÂºÄÈîÄ</a></li>
    <li><a href="#todo">TODO</a></li>
    <li><a href="#kprobes-‰æãÂ≠ê">Kprobes ‰æãÂ≠ê</a></li>
    <li><a href="#kretprobes-‰æãÂ≠ê">Kretprobes ‰æãÂ≠ê</a></li>
    <li><a href="#Â∑≤ÂºÉÁî®ÁöÑÊú∫Âà∂">Â∑≤ÂºÉÁî®ÁöÑÊú∫Âà∂</a></li>
    <li><a href="#kprobes-debugfs-Êé•Âè£">kprobes debugfs Êé•Âè£</a></li>
    <li><a href="#kprobes-sysctl-Êé•Âè£">kprobes sysctl Êé•Âè£</a></li>
  </ul>
</nav>
  </div>
</section>



</aside>

<script>
  
  
  

  var enableToc = JSON.parse("true");
  var toc = JSON.parse("null");
  var tocPosition = JSON.parse("null");
  
  var singleMainElem = document.querySelector('.single__main');
  var singleSideElem = document.querySelector('.single__side');

  enquire.register("screen and (max-width: 769px)", {
    match: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        if (singleMainElem && singleSideElem) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
          singleSideElem.classList.remove('main-side');
          singleSideElem.classList.add('hide');
        }
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }
    },
    unmatch: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        singleMainElem.classList.remove('main');
        singleMainElem.classList.add('main-main');
        singleSideElem.classList.remove('hide');
        singleSideElem.classList.add('main-side');
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }

      var navCollapseBtn = document.querySelector('.navbar__burger');
      var navCollapse = document.getElementsByClassName('navbarm__collapse')[0];
      if (navCollapse) {
        navCollapse.setAttribute('data-open', false);
        navCollapse.style.maxHeight = 0;
        navCollapseBtn.classList.remove('is-active');
      }
      document.getElementsByClassName('navbar__menu')[0].classList.remove('is-active');
      document.getElementsByClassName('mobile-search')[0].classList.add('hide');
    },
    setup: function () { },
    deferSetup: true,
    destroy: function () { },
  });
</script>




<script defer src="/public/js/clipboard.min.1626706afc88d95ebe1173b553ec732c6dc82a576989315fdf5e7779af738a44.js"></script>

<script defer src="/public/js/helper/getParents.min.js"></script>

<script defer src="/public/js/helper/closest.min.js"></script>

<script defer src="/public/js/helper/prev.min.js"></script>

<script defer src="/public/js/helper/prop.min.js"></script>

<script defer src="/public/js/helper/fadeinout.min.js"></script>

















<script>
  'use strict';

  window.onload = function() {
    var navbar = document.querySelector('.navbar');
    var singleContentsElem = document.querySelector('.single__contents');

    
    
    
    var enableBusuanzi = JSON.parse("false");
    var busuanziPagePV = JSON.parse("true");
    
    if (enableBusuanzi && busuanziPagePV) {
      var pagePvElem = document.querySelector('#busuanzi_value_page_pv');
      pagePvElem.textContent = pagePvElem.textContent.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    }    
    


    
    
    
    
    
    
    var enableToc = JSON.parse("true");
    var toc = JSON.parse("null");
    var hideToc = JSON.parse("false");
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var tocFolding = JSON.parse("null");
    
    if ((enableToc || toc) && document.querySelector('.toc')) {
      var tableOfContentsElem = document.querySelector('.toc').querySelector('#TableOfContents');

      if (false === tocFolding) {

      } else {
        tableOfContentsElem.querySelectorAll('ul') ?
          tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
            rootUl.querySelectorAll('li').forEach(function (liElem) {
              liElem.querySelectorAll('ul').forEach(function (ulElem) {
                ulElem.style.display = 'none';
              });
            });
          }) : null;
      }

      if (tableOfContentsElem) {
        if (tableOfContentsElem.querySelectorAll('a').length > 0) {
          tableOfContentsElem.querySelectorAll('a').forEach(function (elem) {
            elem.addEventListener('click', function () {
              var id = elem.getAttribute('id');
              navbar.classList.remove('navbar--show');
              navbar.classList.remove('navbar--hide');
              navbar.classList.add('navbar--hide');

              document.querySelector('.toc').querySelectorAll('a').forEach(function (elem) {
                elem.classList.remove('active');
              });
              elem.classList.add('active');

              var curElem = tableOfContentsElem.querySelector('[href="#' + id + '"]');
              if (curElem && curElem.nextElementSibling) {
                curElem.nextElementSibling.style.display = 'block';
              }
              if (curElem) {
                getParents(curElem, 'ul') ?
                  getParents(curElem, 'ul').forEach(function (elem) {
                    elem.style.display = 'block';
                  }) : null;
              }
            });
          });
        } else {
          if (tocFlexbox) {
            tocFlexbox.setAttribute('data-position', '');
            if (!tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
          }
          if (tocFlexboxOuter) {
            tocFlexboxOuter.setAttribute('data-position', '');
            if (!tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
        }
      }

      
      var toggleTocElem = document.getElementById("toggle-toc");
      var visibleTocElem = document.getElementById('visible-toc');
      var tocElem = document.querySelector('.toc');
      var mainElem = document.querySelector('main');
      var sideElem = document.querySelector('side');
      var tocFlexboxElem = document.querySelector('.toc__flexbox');

      toggleTocElem ? 
      toggleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'fixed');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main-main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'absolute');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        }
      }) : null;

      visibleTocElem ?
      visibleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
        }
      }) : null;
    }
    


    
    var tables = document.querySelectorAll('.single__contents > table');
    for (let i = 0; i < tables.length; i++) {
      var table = tables[i];
      var wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';
      table.parentElement.replaceChild(wrapper, table);
      wrapper.appendChild(table);
    }
    


    
    var text, clip = new ClipboardJS('.anchor');
    var headers = singleContentsElem.querySelectorAll("h1, h2, h3, h4");

    
    var languagedir = JSON.parse("\"ltr\"");

    headers ? 
    headers.forEach(function (elem) {
      var url = encodeURI(document.location.origin + document.location.pathname);
      var link = url + "#" + elem.getAttribute('id');
      var newElemOuter = document.createElement('span');
      newElemOuter.classList.add('anchor');
      newElemOuter.classList.add('hide');
      newElemOuter.setAttribute('data-clipboard-text', link);
      newElemOuter.style.position = 'relative';

      var newElemInner = document.createElement('span');
      newElemInner.style.fontSize = '1rem';
      newElemInner.style.position = 'absolute';
      newElemInner.style.top = '50%';
      newElemInner.style.transform = 'translateY(-50%)';
      newElemInner.innerText = "üîó";

      if (languagedir === "rtl") {
        newElemInner.style.left = '-2rem';
      } else {
        newElemInner.style.right = '-2rem';
      }

      newElemOuter.append(newElemInner);
      elem.append(newElemOuter);

      elem.addEventListener('mouseenter', function() {
        this.querySelector('.anchor').classList.remove('hide');
      });
      elem.addEventListener('mouseleave', function () {
        this.querySelector('.anchor').classList.add('hide');
      });
    }) : null;

    document.querySelectorAll('.anchor').forEach(function(elem) {
      elem.addEventListener('mouseleave', function() {
        elem.setAttribute('aria-label', null);
        elem.classList.remove('tooltipped');
        elem.classList.remove('tooltipped-s');
        elem.classList.remove('tooltipped-w');
      });
    });

    clip.on('success', function (e) {
      e.clearSelection();
      e.trigger.setAttribute('aria-label', 'Link copied to clipboard!');
      e.trigger.classList.add('tooltipped');
      e.trigger.classList.add('tooltipped-s');
    });
    


    
    var clipInit = false;
    var preChromaElem = document.querySelectorAll('pre.chroma');
    var langCodeElem = document.querySelectorAll('.language-code');
    var dollarCodeElem = document.querySelectorAll('div.language-\\$');
    var gtCodeElem = document.querySelectorAll('div.language-\\>');

    var makeClipboard = function(elem) {
      var code = elem,
        text = elem.textContent;
        
      if (text.length > 15) {
        if (!clipInit) {
          var text, clip = new ClipboardJS('.copy-to-clipboard', {
            text: function (trigger) {
              var codeElem = prev(trigger).querySelectorAll('code');
              if (codeElem.length > 1) {
                text = prev(trigger).querySelector('code[class^="language-"]').textContent;
              } else {
                text = prev(trigger).querySelector('code').textContent;
              }

              return text.replace(/^\$\s/gm, '');
            }
          });

          var inPre;
          clip.on('success', function (e) {
            e.clearSelection();
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', 'Copied to clipboard!');
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clip.on('error', function (e) {
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', e.action.toString());
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clipInit = true;
        }

        var notAllowedClass = ['language-mermaid', 'language-viz', 'language-wave', 'language-chart', 'language-msc', 'language-flowchart'];
        var isNotAllowedIncluded = false;
        var curClassName = code.getAttribute('class');

        for (var i = 0; i < notAllowedClass.length; i++) {
          if (curClassName && curClassName.startsWith(notAllowedClass[i])) {
            isNotAllowedIncluded = true;
            break;
          }
        }

        if (!isNotAllowedIncluded) {
          if (curClassName) {
            var newClipboardElem = document.createElement('span');
            newClipboardElem.setAttribute('class', 'copy-to-clipboard');
            newClipboardElem.setAttribute('title', 'Copy to clipboard');
            elem.parentNode.parentNode.insertBefore(newClipboardElem, elem.parentNode.nextElementSibling);
          }
        }
      }
    }

    var makeSymbolClipboard = function(elem) {
      var clipboardSpan = document.createElement('span');
      clipboardSpan.setAttribute('class', 'copy-to-clipboard');
      clipboardSpan.setAttribute('title', 'Copy to clipboard');
      elem.parentNode.parentNode.insertBefore(clipboardSpan, elem.parentNode.nextElementSibling);
    }

    preChromaElem ? 
    preChromaElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function(codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;
    
    langCodeElem ? 
    langCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;

    dollarCodeElem ? 
    dollarCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;

    gtCodeElem ?
    gtCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;
    


    
    dollarCodeElem ?
    dollarCodeElem.forEach(function(elem) {
      var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
      lnts ? 
      lnts.forEach(function(lnt) {
        lnt.innerHTML = '$<br/>';
      }) : null;
    }) : null;

    gtCodeElem ?
    gtCodeElem.forEach(function(elem) {
      var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
      lnts ? 
      lnts.forEach(function(lnt) {
        lnt.innerHTML = '><br/>';
      }) : null;
    }) : null;
    


    
    
    var lib = JSON.parse("null");

    if (lib && lib.includes('mermaid')) {
      
      var themeVariant = localStorage.getItem('theme') || JSON.parse("\"light\"");

      if (themeVariant === "dark" || themeVariant === "hacker") {
        mermaid.initialize({ theme: 'dark' });
      } else {
        mermaid.initialize({ theme: 'default' });
      }
      
      var mermaids = [];
      [].push.apply(mermaids, document.getElementsByClassName('language-mermaid'));
      mermaids.forEach(function(elem) {
        var elemParentNode = elem.parentNode;

        if (elemParentNode !== document.body) {
          elemParentNode.parentNode.insertBefore(elem, elemParentNode);
          elemParentNode.parentNode.removeChild(elemParentNode);
        }

        var newElemWrapper = document.createElement('div');
        newElemWrapper.classList.add('mermaid');
        newElemWrapper.style.padding = '34px 4px 6px';
        newElemWrapper.innerHTML = elem.innerHTML;
        elem.replaceWith(newElemWrapper);
      });
    }
    
    

    
    if (lib && lib.includes('katex')) {
      var mathElements = document.getElementsByClassName('math');
      var options = {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\[", right: "\\]", display: true },
          { left: "$", right: "$", display: false },
          { left: "\\(", right: "\\)", display: false }
        ],
      };

      renderMathInElement(document.querySelector('.single__contents'), options);
    }
    


    
    if (lib && lib.includes('flowchartjs')) {
      
      var options = JSON.parse("{\"arrow-end\":\"block\",\"element-color\":\"black\",\"fill\":\"white\",\"flowstate\":{\"approved\":{\"fill\":\"#58C4A3\",\"font-size\":12,\"no-text\":\"n/a\",\"yes-text\":\"APPROVED\"},\"current\":{\"fill\":\"yellow\",\"font-color\":\"red\",\"font-weight\":\"bold\"},\"future\":{\"fill\":\"#FFFF99\"},\"invalid\":{\"fill\":\"#444444\"},\"past\":{\"fill\":\"#CCCCCC\",\"font-size\":12},\"rejected\":{\"fill\":\"#C45879\",\"font-size\":12,\"no-text\":\"REJECTED\",\"yes-text\":\"n/a\"},\"request\":{\"fill\":\"blue\"}},\"font-color\":\"black\",\"font-size\":14,\"line-color\":\"black\",\"line-length\":50,\"line-width\":3,\"no-text\":\"no\",\"scale\":1,\"symbols\":{\"end\":{\"class\":\"end-element\"},\"start\":{\"element-color\":\"green\",\"fill\":\"yellow\",\"font-color\":\"red\"}},\"text-margin\":10,\"x\":0,\"y\":0,\"yes-text\":\"yes\"}");
      var jsonContent = null;

      var flowchartPrefix = "language-flowchart";
      var index = 0;
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + flowchartPrefix + "]"), function(x){
          x.style.display = 'none'
          x.parentNode.style.backgroundColor = "transparent"
          jsonContent = x.innerText;

          var node0 = document.createElement('div');
          node0.id = 'flowchart' + index;
          x.parentNode.insertBefore(node0, x);

          var diagram = flowchart.parse(jsonContent);
          diagram.drawSVG("flowchart"+index, options);

          index +=1;
      });      
    }
    


    
    document.querySelectorAll("mjx-container").forEach(function (x) {
      x.parentElement.classList += 'has-jax'
    });
    


    
    if (lib && lib.includes('msc')) {
      
      var options = JSON.parse("{\"theme\":\"hand\"}");
      var jsonContent = null;

      var index = 0;
      var chartPrefix = "language-msc";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        node0.id = 'msc' + index;
        x.parentNode.insertBefore(node0, x);
        var diagram = Diagram.parse(jsonContent);
        diagram.drawSVG("msc" + index, options);
        index += 1;
      });
    }
    


    
    if (lib && lib.includes('chart')) {
      var borderColor = "#666";
      var bgColor = "#ddd";
      var borderWidth = 2;

      Chart.defaults.global.elements.rectangle.borderWidth = borderWidth;
      Chart.defaults.global.elements.rectangle.borderColor = borderColor;
      Chart.defaults.global.elements.rectangle.backgroundColor = bgColor;

      Chart.defaults.global.elements.line.borderWidth = borderWidth;
      Chart.defaults.global.elements.line.borderColor = borderColor;
      Chart.defaults.global.elements.line.backgroundColor = bgColor;

      Chart.defaults.global.elements.point.borderWidth = borderWidth;
      Chart.defaults.global.elements.point.borderColor = borderColor;
      Chart.defaults.global.elements.point.backgroundColor = bgColor;

      var chartPrefix = "language-chart";
      var index = 0;
      var jsonContent = null;

      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('canvas');
        var source = null;
        node0.height = 200;
        node0.style.height = 200;
        node0.id = 'myChart' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        var ctx = document.getElementById('myChart' + index).getContext('2d');
        var myChart = new Chart(ctx, source);
        index += 1;
      });            
    }
    


    
    if (lib && lib.includes('wavedrom')) {
      var wavePrefix = "language-wave";
      var index = 0;
      var jsonContent = null;
      
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + wavePrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        var source = null;
        node0.id = 'WaveDrom_Display_' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        WaveDrom.RenderWaveForm(index, source, "WaveDrom_Display_");
        index += 1;
      });
    }
    


    
    if (lib && lib.includes('viz')) {
      var vizPrefix = "language-viz-";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        var engine;
        x.getAttribute("class").split(" ").forEach(function (cls) {
          if (cls.startsWith(vizPrefix)) {
            engine = cls.substr(vizPrefix.length);
          }
        });
        var viz = new Viz();
        viz.renderSVGElement(x.innerText, { engine: engine })
          .then(function (element) {
            element.style.width = "100%";
            x.parentNode.insertBefore(element, x);
          })
      });
    }
    
    
  }
</script>


            
            <footer class="footer">
    
    
<div class="footer__social">
  <div class="social">
    
            
    
            
    
            
    
            
    
      
      <a href="https://github.com/jayce" title="github" aria-label="github">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 24 24" version="1.1">
<g id="surface3680">
<path fill="currentColor" d="M 10.898438 2.101562 C 6.300781 2.601562 2.601562 6.300781 2.101562 10.800781 C 1.601562 15.5 4.300781 19.699219 8.398438 21.300781 C 8.699219 21.398438 9 21.199219 9 20.800781 L 9 19.199219 C 9 19.199219 8.601562 19.300781 8.101562 19.300781 C 6.699219 19.300781 6.101562 18.101562 6 17.398438 C 5.898438 17 5.699219 16.699219 5.398438 16.398438 C 5.101562 16.300781 5 16.300781 5 16.199219 C 5 16 5.300781 16 5.398438 16 C 6 16 6.5 16.699219 6.699219 17 C 7.199219 17.800781 7.800781 18 8.101562 18 C 8.5 18 8.800781 17.898438 9 17.800781 C 9.101562 17.101562 9.398438 16.398438 10 16 C 7.699219 15.5 6 14.199219 6 12 C 6 10.898438 6.5 9.800781 7.199219 9 C 7.101562 8.800781 7 8.300781 7 7.601562 C 7 7.199219 7 6.601562 7.300781 6 C 7.300781 6 8.699219 6 10.101562 7.300781 C 10.601562 7.101562 11.300781 7 12 7 C 12.699219 7 13.398438 7.101562 14 7.300781 C 15.300781 6 16.800781 6 16.800781 6 C 17 6.601562 17 7.199219 17 7.601562 C 17 8.398438 16.898438 8.800781 16.800781 9 C 17.5 9.800781 18 10.800781 18 12 C 18 14.199219 16.300781 15.5 14 16 C 14.601562 16.5 15 17.398438 15 18.300781 L 15 20.898438 C 15 21.199219 15.300781 21.5 15.699219 21.398438 C 19.398438 19.898438 22 16.300781 22 12.101562 C 22 6.101562 16.898438 1.398438 10.898438 2.101562 Z M 10.898438 2.101562 "/>
</g>
</svg>

      </a>
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
    
  
  
    
      <a href="https://jayce.github.io/public/posts/index.xml" type="application/rss+xml" title="RSS" aria-label="RSS Feed Link">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><circle fill="currentColor" cx="6.18" cy="17.82" r="2.18"/><path fill="currentColor" d="M5.59 10.23c-.84-.14-1.59.55-1.59 1.4 0 .71.53 1.28 1.23 1.4 2.92.51 5.22 2.82 5.74 5.74.12.7.69 1.23 1.4 1.23.85 0 1.54-.75 1.41-1.59-.68-4.2-3.99-7.51-8.19-8.18zm-.03-5.71C4.73 4.43 4 5.1 4 5.93c0 .73.55 1.33 1.27 1.4 6.01.6 10.79 5.38 11.39 11.39.07.73.67 1.28 1.4 1.28.84 0 1.5-.73 1.42-1.56-.73-7.34-6.57-13.19-13.92-13.92z"/></svg>
      </a>
    
  


  </div>
</div>

    
<div id="gtt">
  <div class="gtt">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M8.12 14.71L12 10.83l3.88 3.88c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L12.7 8.71c-.39-.39-1.02-.39-1.41 0L6.7 13.3c-.39.39-.39 1.02 0 1.41.39.38 1.03.39 1.42 0z"/></svg>
  </div>
</div>

    <hr />

    <div class="basicflex">
        
    </div>

    <div class="footer__poweredby">
        
                
            <p class="caption">
                
                    ¬©2020, All Rights Reserved
                
            </p>
        

        
            <p class="caption">Powered by <a href="https://gohugo.io/" target="_blank" rel="noreferrer">Hugo</a> and the <a href="https://github.com/zzossig/hugo-theme-zzo" target="_blank" rel="noreferrer">Zzo theme</a></p>
        
        
    </div> 
</footer>
        </div>
        





<div class="wrapper__right hide" data-pad="true" dir="ltr">
  <script>document.querySelector('.wrapper__right').classList.remove('hide')</script>
  
</div>

    </div>
</body>

</html>