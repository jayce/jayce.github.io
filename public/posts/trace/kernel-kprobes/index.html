<!DOCTYPE html>
<html lang="en" dir="ltr">

<head prefix="og: http://ogp.me/ns#">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>è¯‘ï½œ2019ï½œKernel Probes (Kprobes) â€“ Blog</title>
    


  
  <script defer src="/public/js/fuse.min.32195737929df2c8096e855a5789cbb3f1331224d9169e8705493e7008f47df8.js"></script>



<script src="/public/js/enquire.min.dfb99dee1e029d51d6cfb672d847929890b1585402de17f5ed092edd72a688b4.js"></script>

<script defer src="/public/js/lazysizes.min.fb649fcae62177dfe63e67081ddceb830b5ce1f05a4184e9bbb7d87ac4b8f4e5.js"></script>

<script defer src="/public/js/helper/getParents.min.1618c696be7c98933f9a92677f518b512a74e55bdbb976b09936b4182e93181b.js"></script>

<script defer src="/public/js/helper/fadeinout.min.efa35f4c090622130b3f4cfae6971448b5ffb61c5f0a8f21cdfd157fa712abc4.js"></script>

<script defer src="/public/js/helper/closest.min.js"></script>
  
<script>
  "use strict";

  
  
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  
  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (search instanceof RegExp) {
        throw TypeError('first argument must not be a RegExp');
      }
      if (start === undefined) { start = 0; }
      return this.indexOf(search, start) !== -1;
    };
  }

  
  Document.prototype.append = Element.prototype.append = function append() {
    this.appendChild(_mutation(arguments));
  };
  function _mutation(nodes) {
    if (!nodes.length) {
      throw new Error('DOM Exception 8');
    } else if (nodes.length === 1) {
      return typeof nodes[0] === 'string' ? document.createTextNode(nodes[0]) : nodes[0];
    } else {
      var
      fragment = document.createDocumentFragment(),
      length = nodes.length,
      index = -1,
      node;

      while (++index < length) {
        node = nodes[index];

        fragment.appendChild(typeof node === 'string' ? document.createTextNode(node) : node);
      }

      return fragment;
    }
  }

  
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    };
  }
  


  document.addEventListener('DOMContentLoaded', function () {
    
    var navCollapseBtn = document.querySelector('.navbar__burger');
    navCollapseBtn ? navCollapseBtn.addEventListener('click', function (e) {
      var navCollapse = document.querySelector('.navbarm__collapse');

      if (navCollapse) {
        var dataOpen = navCollapse.getAttribute('data-open');

        if (dataOpen === 'true') {
          navCollapse.setAttribute('data-open', 'false');
          navCollapse.style.maxHeight = 0;
          navCollapseBtn.classList.remove('is-active');
        } else {
          navCollapse.setAttribute('data-open', 'true');
          navCollapse.style.maxHeight = navCollapse.scrollHeight + "px";
          navCollapseBtn.classList.add('is-active');
        }
      }
    }) : null;
    


    
    var tables = document.querySelectorAll('.single__contents > table');
    for (let i = 0; i < tables.length; i++) {
      var table = tables[i];
      var wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';
      table.parentElement.replaceChild(wrapper, table);
      wrapper.appendChild(table);
    }
    


    
    var footNoteRefs = document.querySelectorAll('.footnote-ref');
    var footNoteBackRefs = document.querySelectorAll('.footnote-backref');

    footNoteRefs ? 
    footNoteRefs.forEach(function(elem, idx) {
      elem.onmouseenter = function () {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      elem.onmouseleave = function () {
        if (!navbar.classList.contains('scrolling')) {
          setTimeout(function () {
            navbar.classList.add('scrolling');
          }, 100);
        }
      }

      elem.onclick = function () {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.remove('navbar--show');
          navbar.classList.remove('navbar--hide');
          navbar.classList.add('navbar--hide');
        }
      }
    }) : null;

    footNoteBackRefs ? 
    footNoteBackRefs.forEach(function(elem, idx) {
      elem.onmouseenter = function () {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      elem.onmouseleave = function () {
        if (!navbar.classList.contains('scrolling')) {
          setTimeout(function() {
            navbar.classList.add('scrolling');
          }, 100);
        }
      }

      elem.onclick = function () {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.remove('navbar--show');
          navbar.classList.remove('navbar--hide');
          navbar.classList.add('navbar--hide');
        }
      }
    }) : null;
    


    
    var summaryContainer = document.querySelector('.summary__container');
    var searchResult = document.querySelector('.search-result');
    var searchResultCloseBtn = document.querySelector('.search-result__close');
    searchResultCloseBtn ? searchResultCloseBtn.addEventListener('click', function (e) {
      searchResult.setAttribute('data-display', 'none');
      summaryContainer.setAttribute('data-display', 'block');
    }) : null;
    


    
    document.querySelectorAll('.tab') ? 
    document.querySelectorAll('.tab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var tabLinks = elem.querySelectorAll('.tab__link');
      var tabContents = elem.querySelectorAll('.tab__content');
      var ids = [];

      tabLinks && tabLinks.length > 0 ?
      tabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                tabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              tabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    document.querySelectorAll('.codetab') ? 
    document.querySelectorAll('.codetab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var codetabLinks = elem.querySelectorAll('.codetab__link');
      var codetabContents = elem.querySelectorAll('.codetab__content');
      var ids = [];

      codetabLinks && codetabLinks.length > 0 ?
      codetabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                codetabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              codetabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    var gttBtn = document.getElementById("gtt");
    gttBtn.style.display = "none";
    gttBtn.addEventListener('click', function () {
      if (window.document.documentMode) {
        document.documentElement.scrollTop = 0;
      } else {
        scrollToTop(250);
      }
    });

    function scrollToTop(scrollDuration) {
      var scrollStep = -window.scrollY / (scrollDuration / 15);
      var scrollInterval = setInterval(function () {
        if (window.scrollY != 0) {
          window.scrollBy(0, scrollStep);
        }
        else clearInterval(scrollInterval);
      }, 15);
    }

    var scrollFunction = function () {
      if (document.body.scrollTop > 250 || document.documentElement.scrollTop > 250) {
        gttBtn.style.display = "block";
      } else {
        gttBtn.style.display = "none";
      }
    }
    


    
    var expandBtn = document.querySelectorAll('.expand__button');

    for (let i = 0; i < expandBtn.length; i++) {
      expandBtn[i].addEventListener("click", function () {
        var content = this.nextElementSibling;
        if (content.style.maxHeight) {
          content.style.maxHeight = null;
          this.querySelector('svg').classList.add('expand-icon__right');
          this.querySelector('svg').classList.remove('expand-icon__down');
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
          this.querySelector('svg').classList.remove('expand-icon__right');
          this.querySelector('svg').classList.add('expand-icon__down');
        }
      });
    }
    


    
    var lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
    var tocElem = document.querySelector('.toc');
    var tableOfContentsElem = tocElem ? tocElem.querySelector('#TableOfContents') : null;
    var toggleTocElem = document.getElementById('toggle-toc');
    var singleContentsElem = document.querySelector('.single__contents');
    var navbar = document.querySelector('.navbar');
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var expandContents = document.querySelectorAll('.expand__content');
    var boxContents = document.querySelectorAll('.box');
    var notAllowedTitleIds = null;

    
    var tocFolding = JSON.parse("null");
    
    var tocLevels = JSON.parse("null");
    
    if (tocLevels) {
      tocLevels = tocLevels.toString();
    } else {
      tocLevels = "h1, h2, h3, h4, h5, h6";
    }

    
    singleContentsElem && singleContentsElem.querySelectorAll(".tab") ?
    singleContentsElem.querySelectorAll(".tab").forEach(function (elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    expandContents ? expandContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    boxContents ? boxContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    window.onscroll = function () {
      scrollFunction();
      
      var st = window.pageYOffset || document.documentElement.scrollTop;
      if (st > lastScrollTop) { 
        if (st < 250) {
          gttBtn.style.display = "none";
        } else {
          gttBtn.style.display = "block";
        }

        if (st < 45) {
          return null;
        }

        if (navbar.classList.contains('scrolling')) {
          if (!navbar.classList.contains('navbar--hide')) {
            navbar.classList.add('navbar--hide');
          } else if (navbar.classList.contains('navbar--show')) {
            navbar.classList.remove('navbar--show');
          }
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }

              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }
              
              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox) {
              tocFlexbox.setAttribute('data-position', '');
              if (!tocFlexbox.classList.contains('hide')) {
                tocFlexbox.classList.add('hide');
              }
            }
            if (tocFlexboxOuter) {
              tocFlexboxOuter.setAttribute('data-position', '');
              if (!tocFlexboxOuter.classList.contains('hide')) {
                tocFlexboxOuter.classList.add('hide');
              }
            }
          }
        }
      } else { 
        if (st < 250) {
          gttBtn.style.display = "none";
        }

        if (navbar.classList.contains('scrolling')) {
          if (navbar.classList.contains('navbar--hide')) {
            navbar.classList.remove('navbar--hide');
          } else if (!navbar.classList.contains('navbar--show')) {
            navbar.classList.add('navbar--show');
          }
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }
              
              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }

              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox && !tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
            if (tocFlexboxOuter && !tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
          
        }

        if (tableOfContentsElem && document.documentElement.scrollTop < 250) {
          if (false === tocFolding) {

          } else {
            tableOfContentsElem.querySelector('ul') ?
              tableOfContentsElem.querySelector('ul').querySelectorAll('li').forEach(function (liElem) {
                liElem.querySelectorAll('ul').forEach(function (ulElem) {
                  ulElem.style.display = 'none';
                });
              }) : null;
          }
        }
      }
      lastScrollTop = st <= 0 ? 0 : st;
    };
  


  
    var localTheme = localStorage.getItem('theme');
    var rootEleme = document.getElementById('root');
    var selectThemeElem = document.querySelectorAll('.select-theme');
    var selectThemeItemElem = document.querySelectorAll('.select-theme__item');
    
    
    var skinDarkCode = JSON.parse("\"dark\"");
    
    var skinLightCode = JSON.parse("\"light\"");
    
    var skinHackerCode = JSON.parse("\"hacker\"");
    
    var skinSolarizedCode = JSON.parse("\"solarized\"");
    
    var skinKimbieCode = JSON.parse("\"kimbie\"");

    var setMetaColor = function(themeColor) {
      var metaMsapplicationTileColor = document.getElementsByName('msapplication-TileColor')[0];
      var metaThemeColor = document.getElementsByName('theme-color')[0];
      var metaMsapplicationNavbuttonColor = document.getElementsByName('msapplication-navbutton-color')[0];
      var metaAppleMobileWebAappStatusBarStyle = document.getElementsByName('apple-mobile-web-app-status-bar-style')[0];

      if (themeColor.includes('dark')) {
        metaMsapplicationTileColor.setAttribute('content', '#fcfcfa');
        metaThemeColor.setAttribute('content', '#403E41');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#403E41');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#403E41');
      } else if (themeColor.includes('light')) {
        metaMsapplicationTileColor.setAttribute('content', '#555');
        metaThemeColor.setAttribute('content', '#eee');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee');
      } else if (themeColor.includes('hacker')) {
        metaMsapplicationTileColor.setAttribute('content', '#e3cd26');
        metaThemeColor.setAttribute('content', '#252526');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#252526');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#252526');
      } else if (themeColor.includes('solarized')) {
        metaMsapplicationTileColor.setAttribute('content', '#d3af86');
        metaThemeColor.setAttribute('content', '#51412c');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#51412c');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#51412c');
      } else if (themeColor.includes('kimbie')) {
        metaMsapplicationTileColor.setAttribute('content', '#586e75');
        metaThemeColor.setAttribute('content', '#eee8d5');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee8d5');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee8d5');
      }
    }

    var parseSkinCode = function(themeText) {
      if (themeText === skinDarkCode) {
        return 'dark';
      } else if (themeText === skinLightCode) {
        return 'light';
      } else if (themeText === skinHackerCode) {
        return 'hacker';
      } else if (themeText === skinSolarizedCode) {
        return 'solarized';
      } else if (themeText === skinKimbieCode) {
        return 'kimbie';
      }
    }
    
    if (localTheme) {
      selectThemeItemElem ? 
      selectThemeItemElem.forEach(function (elem) {
        if (elem.text.trim() === localTheme) {
          elem.classList.add('is-active');
        } else {
          elem.classList.remove('is-active');
        }
      }) : null;

      setMetaColor(localTheme);
    } else {
      setMetaColor(rootEleme.className);
    }

    selectThemeItemElem ? 
    selectThemeItemElem.forEach(function (v, i) {
      v.addEventListener('click', function (e) {
        var selectedThemeVariant = parseSkinCode(e.target.text.trim());
        localStorage.setItem('theme', selectedThemeVariant);
        setMetaColor(selectedThemeVariant);

        rootEleme.removeAttribute('class');
        rootEleme.classList.add('theme__' + selectedThemeVariant);
        selectThemeElem.forEach(function(rootElem) {
          rootElem.querySelectorAll('a').forEach(function (elem) {
            if (elem.classList) {
              if (elem.text.trim() === selectedThemeVariant) {
                if (!elem.classList.contains('is-active')) {
                  elem.classList.add('is-active');
                }
              } else {
                if (elem.classList.contains('is-active')) {
                  elem.classList.remove('is-active');
                }
              }
            }
          });
        });

        if (window.mermaid) {
          if (selectedThemeVariant === "dark" || selectedThemeVariant === "hacker") {
            mermaid.initialize({ theme: 'dark' });
            location.reload();
          } else {
            mermaid.initialize({ theme: 'default' });
            location.reload();
          }
        }

        var utterances = document.getElementById('utterances');
        if (utterances) {
          utterances.querySelector('iframe').contentWindow.postMessage({
            type: 'set-theme',
            theme: selectedThemeVariant === "dark" || selectedThemeVariant === "hacker" ? 'photon-dark' : selectedThemeVariant === 'kimbie' ? 'github-dark-orange' : 'github-light',
          }, 'https://utteranc.es');
        }

        var twitterCards = document.querySelectorAll('.twitter-timeline');
        if (twitterCards) {
          window.postMessage({
            type: 'set-twitter-theme',
            theme: selectedThemeVariant === 'light' || selectedThemeVariant === 'solarized' ? 'light' : 'dark',
          });
        }
      });
    }) : null;
  


  
    
    var baseurl = JSON.parse("\"https://jayce.github.io/public/\"");
    
    var permalink = JSON.parse("\"https://jayce.github.io/public/posts/trace/kernel-kprobes/\"");
    
    var langprefix = JSON.parse("\"\"");
    var searchResults = null;
    var searchMenu = null;
    var searchText = null;
    
    
    var enableSearch = JSON.parse("true");
    
    var enableSearchHighlight = JSON.parse("true");
    
    var searchResultPosition = JSON.parse("null");
    
    var sectionType = JSON.parse("\"posts\"");
    
    var kind = JSON.parse("\"page\"");
    
    var fuse = null;

    if (enableSearch) {
      (function initFuse() {
        var xhr = new XMLHttpRequest();
        if (sectionType === "publication" && kind !== "page") {
          xhr.open('GET', permalink + "index.json");
        } else {
          xhr.open('GET', baseurl + langprefix + "/index.json");
        }
        
        xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
        xhr.onload = function () {
          if (xhr.status === 200) {
            fuse = new Fuse(JSON.parse(xhr.response.toString('utf-8')), {
              keys: sectionType.includes('publication') ? ['title', 'abstract'] : ['title', 'description', 'content'],
              includeMatches: enableSearchHighlight,
              shouldSort: true, 
              threshold: 0.4, 
              location: 0, 
              distance: 100, 
              maxPatternLength: 32,
              minMatchCharLength: 1,
              isCaseSensitive: false, 
              findAllMatches: false, 
              useExtendedSearch: false, 
            });
            window.fuse = fuse;
          }
          else {
            console.error('[' + xhr.status + ']Error:', xhr.statusText);
          }
        };
        xhr.send();
      })();
    }

    function makeLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      
      var a = document.createElement('a');
      a.innerHTML = obj.item.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.item.permalink);

      var descDiv = document.createElement('div');
      descDiv.setAttribute('class', 'search-result__item--desc');
      if (obj.item.description) {
        descDiv.innerHTML = obj.item.description;
      } else if (obj.item.content) {
        descDiv.innerHTML = obj.item.content.substring(0, 225);
      }
      
      li.appendChild(a);
      li.appendChild(descDiv);
      ulElem.appendChild(li);
    }

    function makeHighlightLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      var descDiv = null;

      var a = document.createElement('a');
      a.innerHTML = obj.item.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.item.uri);

      if (obj.matches && obj.matches.length) {
        for (var i = 0; i < obj.matches.length; i++) {
          if ('title' === obj.matches[i].key) {
            a = document.createElement('a');
            a.innerHTML = generateHighlightedText(obj.matches[i].value, obj.matches[i].indices);
            a.setAttribute('class', 'search-result__item--title');
            a.setAttribute('href', obj.item.uri);
          }
          
          if ('description' === obj.matches[i].key) {
            descDiv = document.createElement('div');
            descDiv.setAttribute('class', 'search-result__item--desc');
            descDiv.innerHTML = generateHighlightedText(obj.item.description, obj.matches[i].indices);
          } else if ('content' === obj.matches[i].key) {
            if (!descDiv) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = generateHighlightedText(obj.item.content.substring(0, 150), obj.matches[i].indices);
            }
          } else {
            if (obj.item.description) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.description;
            } else {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.content.substring(0, 150);
            }
          }
        }

        li.appendChild(a);
        if (descDiv) {
          li.appendChild(descDiv);
        }
        if (li) {
          ulElem.appendChild(li);
        }
      }
    }

    function renderSearchResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');
      
      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          a.setAttribute('href', result.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.title;
          titleDiv.setAttribute('class', 'menu-item__title');

          var descDiv = document.createElement('div');
          descDiv.setAttribute('class', 'menu-item__desc');
          if (result.description) {
            descDiv.innerHTML = result.description;
          } else if (result.content) {
            descDiv.innerHTML = result.content.substring(0, 150);
          }

          li.appendChild(titleDiv);
          li.appendChild(descDiv);
          ul.appendChild(a);
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      
      searchMenu.appendChild(ul);
    }

    function renderSearchHighlightResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');

      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'menu-item__title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'menu-item__desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      searchMenu.appendChild(ul);
    }

    function renderSearchResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var content = document.createElement('div');
      content.setAttribute('class', 'mobile-search__content');

      if (results.length > 0) {
        results.forEach(function (result) {
          var item = document.createElement('a');
          item.setAttribute('href', result.uri);
          item.innerHTML = '<div class="mobile-search__item"><div class="mobile-search__item--title">ðŸ“„ ' + result.title + '</div><div class="mobile-search__item--desc">' + (result.description ? result.description : result.content) + '</div></div>';
          content.appendChild(item);
        });
      } else {
        var item = document.createElement('span');
        content.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(content);      
    }

    function renderSearchHighlightResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var ul = document.createElement('div');
      ul.setAttribute('class', 'mobile-search__content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.appendChild(li);
          li.setAttribute('class', 'mobile-search__item');

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'mobile-search__item--title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'mobile-search__item--desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var item = document.createElement('span');
        ul.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(ul);
    }

    function generateHighlightedText(text, regions) {
      if (!regions) {
        return text;
      }

      var content = '', nextUnhighlightedRegionStartingIndex = 0;

      regions.forEach(function(region) {
        if (region[0] === region[1]) {
          return null;
        }
        
        content += '' +
          text.substring(nextUnhighlightedRegionStartingIndex, region[0]) +
          '<span class="search__highlight">' +
            text.substring(region[0], region[1] + 1) +
          '</span>' +
        '';
        nextUnhighlightedRegionStartingIndex = region[1] + 1;
      });

      content += text.substring(nextUnhighlightedRegionStartingIndex);

      return content;
    };

    var searchElem = document.getElementById('search');
    var searchMobile = document.getElementById('search-mobile');
    var searchResultsContainer = document.getElementById('search-results');

    searchElem ?
    searchElem.addEventListener('input', function(e) {
      if (!e.target.value | window.innerWidth < 770) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      
      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }
        
        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function(item) {
          item.addEventListener('mousedown', function(e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    searchElem ? 
    searchElem.addEventListener('blur', function() {
      if (window.innerWidth < 770) {
        return null;
      }
      searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
    }) : null;

    searchElem ? 
    searchElem.addEventListener('click', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }
      if (!e.target.value) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);

      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else{
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }

        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function (item) {
          item.addEventListener('mousedown', function (e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    var searchMenuElem = document.getElementById("search-menu");
    var activeItem = document.querySelector('#search-menu .dropdown-item.is-active');
    var activeIndex = null;
    var items = null;
    var searchContainerMaxHeight = 350;

    searchElem ? 
    searchElem.addEventListener('keydown', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }

      if (e.key === 'Escape') {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      }

      var items = document.querySelectorAll('#search-menu .dropdown-item');
      var keyCode = e.which || e.keyCode;

      if (!items || !items.length) {
        return null;
      }
      
      if (e.key === 'ArrowDown' || keyCode === 40) {
        if (activeIndex === null) {
          activeIndex = 0;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === items.length - 1 ? 0 : activeIndex + 1;
        }
        items[activeIndex].classList.add('is-active');

        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel > 0) {
          document.querySelector(".search-content").scrollTop += items[activeIndex].getBoundingClientRect().height;
        } else if (activeIndex === 0) {
          document.querySelector(".search-content").scrollTop = 0;
        }
      } else if (e.key === 'ArrowUp' || keyCode === 38) {
        if (activeIndex === null) {
          activeIndex = items.length - 1;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === 0 ? items.length - 1 : activeIndex - 1;
        }
        items[activeIndex].classList.add('is-active');
        
        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel < 0) {
          document.querySelector(".search-content").scrollTop -= items[activeIndex].getBoundingClientRect().height;
        } else {
          document.querySelector(".search-content").scrollTop = overflowedPixel + items[activeIndex].getBoundingClientRect().height;
        }
      } else if (e.key === 'Enter' || keyCode === 13) {
        if (items[activeIndex] && items[activeIndex].getAttribute('href')) {
          location.href = items[activeIndex].getAttribute('href');
        }
      } else if (e.key === 'Escape' || keyCode === 27) {
        e.target.value = null;
        if (searchResults) {
          searchResults.classList.remove('is-active');
        }
      }
    }) : null;

    searchMobile ? 
    searchMobile.addEventListener('input', function(e) {
      if (!e.target.value) {
        let wrap = document.getElementById('search-mobile-results');
        while (wrap.firstChild) {
          wrap.removeChild(wrap.firstChild);
        }
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      renderSearchResultsMobile(searchText, results);
      if (enableSearchHighlight) {
        renderSearchHighlightResultsMobile(searchText, results);
      } else {
        renderSearchResultsMobile(searchText, results);
      }
    }) : null;
  


  
    var mobileSearchInputElem = document.querySelector('#search-mobile');
    var mobileSearchClassElem = document.querySelector('.mobile-search');
    var mobileSearchBtnElems = document.querySelectorAll('.navbar-search');
    var mobileSearchCloseBtnElem = document.querySelector('#search-mobile-close');
    var mobileSearchContainer = document.querySelector('#search-mobile-container');
    var mobileSearchResultsElem = document.querySelector('#search-mobile-results');
    var htmlElem = document.querySelector('html');

    if (mobileSearchClassElem) {
      mobileSearchClassElem.style.display = 'none';
    }

    mobileSearchBtnElems ? 
    mobileSearchBtnElems.forEach(function (elem, idx) {
      elem.addEventListener('click', function () {
        if (mobileSearchContainer) {
          mobileSearchContainer.style.display = 'block';
        }

        if (mobileSearchInputElem) {
          mobileSearchInputElem.focus();
        }

        if (htmlElem) {
          htmlElem.style.overflowY = 'hidden';
        }
      });
    }) : null;

    mobileSearchCloseBtnElem ? 
    mobileSearchCloseBtnElem.addEventListener('click', function() {
      if (mobileSearchContainer) {
        mobileSearchContainer.style.display = 'none';
      }

      if (mobileSearchInputElem) {
        mobileSearchInputElem.value = '';
      }
      
      if (mobileSearchResultsElem) {
        while (mobileSearchResultsElem.firstChild) {
          mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
        }
      }

      if (htmlElem) {
        htmlElem.style.overflowY = 'visible';
      }
    }) : null;

    mobileSearchInputElem ?
    mobileSearchInputElem.addEventListener('keydown', function(e) {
      var keyCode = e.which || e.keyCode;
      if (e.key === 'Escape' || keyCode === 27) {
        if (mobileSearchContainer) {
          mobileSearchContainer.style.display = 'none';
        }
        
        if (mobileSearchInputElem) {
          mobileSearchInputElem.value = '';
        }

        if (mobileSearchResultsElem) {
          while (mobileSearchResultsElem.firstChild) {
            mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
          }
        }
        if (htmlElem) {
          htmlElem.style.overflowY = 'visible';
        }
      }
    }) : null;
  


  
    function renderSearchResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');
      
      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }

    function renderSearchHighlightResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');

      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeHighlightLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }
  
  });
</script>    
    


<link rel="stylesheet" href="/public/css/main.min.css">


    
<meta name="description" content="" />


<meta name="keywords" content="kprobe,trace">

<meta name="created" content="2020-05-19T11:03:35&#43;0800">
<meta name="modified" content="2020-05-19T11:03:35&#43;0800">
<meta property="article:published_time" content="2020-05-19T11:03:35&#43;0800">

<meta name="author" content="jayce">


<meta property="og:site_name" content="Blog">
<meta property="og:title" content="è¯‘ï½œ2019ï½œKernel Probes (Kprobes)">
<meta property="og:url" content="https://jayce.github.io/public/posts/trace/kernel-kprobes/">
<meta property="og:type" content="article">
<meta property="og:description" content="">

<meta name="generator" content="Hugo 0.68.3" />
<meta name="msapplication-TileColor" content="#fff">

<meta name="theme-color" content="#fff">

<meta name="msapplication-navbutton-color" content="#fff">

<meta name="apple-mobile-web-app-status-bar-style" content="#fff">

<link rel="canonical" href="https://jayce.github.io/public/posts/trace/kernel-kprobes/">

<link rel="manifest" href="/public/manifest.json">

  <link rel="apple-touch-icon" sizes="57x57" href="/public/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/public/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/public/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/public/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/public/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/public/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/public/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/public/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/public/favicon/android-icon-512x512.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/public/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/public/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/public/favicon/favicon-16x16.png">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">


    <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "headline": "è¯‘ï½œ2019ï½œKernel Probes (Kprobes)",
    "datePublished": "2020-05-19T11:03:35+08:00",
    "dateModified": "2020-05-19T11:03:35+08:00",
    "url" : "https://jayce.github.io/public/posts/trace/kernel-kprobes/",
    "description": "è¯‘è€…åº è¿™ç¯‡æ–‡ç« ç¿»è¯‘è‡ª Linux å†…æ ¸æºç æ ‘ä¸­çš„ kprobes.txt æ–‡ä»¶ï¼Œæ­¤æ–‡ä»¶æè¿°äº† Kprobes çš„æ¦‚å¿µã€å·¥ä½œåŽŸç†ã€é™åˆ¶ç­‰å†…å®¹ã€‚å› ä¸ºæ–‡ä»¶çš„æœ€åŽä¸€æ¬¡æäº¤æ˜¯åœ¨ 2019 å¹´ï¼Œæ‰€ä»¥æ–‡ç« æ ‡é¢˜ä¸­çš„å¹´ä»½",
    "keywords": ["kprobe","trace"],
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://jayce.github.io/public/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Blog",
      "url": "https://jayce.github.io/public/"
    }
  }
</script>

    
  
  







    
</head>

<body id="root" class="theme__light">
    <script>
        var localTheme = localStorage.getItem('theme');
        if (localTheme) {
            document.getElementById('root').className = 'theme__' + localTheme;
        }
    </script>
    <div id="container">
        





        <div class="wrapper" data-type="posts" data-kind="page">
            <nav class="navbar scrolling" role="navigation" aria-label="main navigation" data-dir="ltr">
  <div class="navbar__brand">
    
    <a href="/public/" title="Home" rel="home" class="navbar__logo-link">
      <img src="/public/logo.png" alt="Home" class="navbar__logo">
    </a>
    
    
      <a href="/public/" title="Home" rel="home" class="navbar__title-link">
        <h6 class="navbar__title">Jayce</h6>
      </a>
    
  </div>

  
<div class="theme theme-mobile" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" style="" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          dark
        </a>
        
      
    </div>
  </div>
</div>


<div class="mobile-search__btn navbar-search" data-ani="true">
  <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
</div>

<div id="search-mobile-container" class="mobile-search hide" data-dir="ltr">
  <div class="mobile-search__top">
    <input id="search-mobile" type="text" aria-label="Mobile Search" placeholder="Search" class="mobile-search__top--input"/>
    <div id="search-mobile-close" class="mobile-search__top--icon">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path opacity=".87" fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.59-13L12 10.59 8.41 7 7 8.41 10.59 12 7 15.59 8.41 17 12 13.41 15.59 17 17 15.59 13.41 12 17 8.41z"/></svg>
    </div>
  </div>
  <div id="search-mobile-results" class="mobile-search__body">
    
  </div>
</div>


<a role="button" class="navbar__burger" aria-label="menu" aria-expanded="false"
  data-ani="true">
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
</a>
<div class="navbarm__collapse" data-open="false">
  <ul dir="ltr">
    
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/public/about">about</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/public/archive">archive</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item active">
          <a href="/public/posts">posts</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="https://github.com/jayce">Github</a>
        </li>
      
      
    

    
  </ul>
</div>
  <div class="navbar__menu">
  
  
  
<div class="theme" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          dark
        </a>
        
      
    </div>
  </div>
</div>

  
  
  
  
  
  
  
  <a href="/public/about" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">about</a>
  
  
  
  
  
  
  
  <a href="/public/archive" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">archive</a>
  
  
  
  
  
  
  
  <a href="/public/posts" class="navbar__menu-item navbar__slide-down active" dir="ltr" data-ani="true">posts</a>
  
  
  
  
  
  
  
  <a href="https://github.com/jayce" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">Github</a>
  
  
</div>
</nav>
            
            

<main class="single__main main-main">
  
    <nav class="breadcrumb hide" aria-label="breadcrumbs">
  <script>document.querySelector('.breadcrumb').classList.remove('hide')</script>
  <ol>
    
  
  
  
  
  
  <li >
    
      <a href="https://jayce.github.io/public/" class="capitalize">Blog</a>
    
  </li>
  
  
  <li >
    
      <a href="https://jayce.github.io/public/posts/" class="capitalize">Posts</a>
    
  </li>
  
  
  <li  class="is-active" >
    
      <span>è¯‘ï½œ2019ï½œKernel Probes (Kprobes)</span>
    
  </li>
  
  </ol>
  
</nav>
  
  
  <div class="single ">
    <div class="single__nojs">This page looks best with JavaScript enabled</div>
    <script>document.querySelector('.single').classList.remove('hide'); document.querySelector('.single__nojs').classList.add('hide');</script>
    <h2 class="single__title" data-ani="true">è¯‘ï½œ2019ï½œKernel Probes (Kprobes)</h2>
    <h3 class="single__subtitle"></h3>
    <div class="single__meta">
      
<div class="single__infos">
  <time class="single__info" title="Written At">ðŸ“…&nbsp;May 19, 2020 </time>
  
  &nbsp;&middot;&nbsp; <span class="single__info" title="Reading Time"> â˜•&nbsp;18&nbsp;min read </span>
  
  <span class="single__info">
    
  </span>
</div>

      
<ul class="single__tags caption">
  
  ðŸ·ï¸
  

  <li><a href="https://jayce.github.io/public/tags/trace/" class="single__tag" title="trace">#trace</a></li>

  <li><a href="https://jayce.github.io/public/tags/kprobe/" class="single__tag" title="kprobe">#kprobe</a></li>

</ul>

    </div>
    <article class="single__contents" data-dir="ltr" data-ani="true">
      
      <!--
## å¯¹äºŽæ–‡ä¸­ä¸€äº›ç–‘æƒ‘ï¼š**
* trap æ€Žä¹ˆç†è§£ï¼Ÿé™·é˜±ï¼Ÿè°ƒè¯•ï¼Ÿæ•æ‰ï¼Ÿ
* notifier_call_chain æœºåˆ¶ï¼Ÿ
* routine ç¿»è¯‘ä¸ºå‡½æ•°æˆ–è€…ç¨‹åº
* debug ç¿»è¯‘ä¸ºè°ƒè¯•
* probepoint ç¿»è¯‘ä¸ºæŽ¢æµ‹ç‚¹
* æŸ¥æŸ¥ä»¥ TOC ä½œä¸ºå‡½æ•°è°ƒç”¨çš„æž¶æž„ï¼ŒåŠå…¶åŽŸç†
* CPU å¦‚ä½•åŒºåˆ†äºŒè¿›åˆ¶ä¸­çš„æŒ‡ä»¤å’Œæ•°æ®ï¼Œæˆ–è€…è¯´æ˜¯å¯æ‰§è¡Œæ–‡ä»¶å¦‚ä½•å­˜å‚¨æŒ‡ä»¤ä»¥åŠæ•°æ®çš„ï¼Ÿ
* æŒ‡ä»¤ä¸Žå‡½æ•°æ€Žä¹ˆå¯¹åº”ï¼Ÿç¼–è¯‘åŽŸç†ï¼Ÿ
-->
<h2 id="è¯‘è€…åº">è¯‘è€…åº</h2>
<p>è¿™ç¯‡æ–‡ç« ç¿»è¯‘è‡ª Linux å†…æ ¸æºç æ ‘ä¸­çš„ <a href="https://github.com/torvalds/linux/blob/master/Documentation/kprobes.txt">kprobes.txt</a> æ–‡ä»¶ï¼Œæ­¤æ–‡ä»¶æè¿°äº† Kprobes çš„æ¦‚å¿µã€å·¥ä½œåŽŸç†ã€é™åˆ¶ç­‰å†…å®¹ã€‚å› ä¸ºæ–‡ä»¶çš„æœ€åŽä¸€æ¬¡æäº¤æ˜¯åœ¨ 2019 å¹´ï¼Œæ‰€ä»¥æ–‡ç« æ ‡é¢˜ä¸­çš„å¹´ä»½ä¹Ÿå°±æ˜¯æŒ‡è¿™ä¸ªæ„æ€çš„ã€‚</p>
<p>ä¸‹é¢çš„è¡¨æ ¼æ˜¯å¯¹å…³é”®è¯çš„ä¸€ç‚¹è§£é‡Šï¼Œæ¦‚å¿µå…¶å®žå°±è¿™å‡ ä¸ªã€‚</p>
<table>
<thead>
<tr>
<th>å…³é”®è¯</th>
<th>è§£é‡Š</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kprobes</td>
<td>æŒ‡çš„æ˜¯å†…æ ¸çš„æŽ¢æµ‹æœºåˆ¶ã€æ¡†æž¶ï¼Œä¾èµ–äºŽç¡¬ä»¶çš„ç‰¹å®šåŠŸèƒ½å®žçŽ°çš„ï¼Œæ¯”å¦‚ int3 æŒ‡ä»¤</td>
</tr>
<tr>
<td>kprobe</td>
<td>æŒ‡çš„æ˜¯ Kprobes çš„å¯¹è±¡æˆ–ç»“æž„ä½“ï¼Œå…³è”æŽ¢æµ‹ç‚¹å’ŒæŽ¢é’ˆ</td>
</tr>
<tr>
<td>probepoint</td>
<td><strong>æŽ¢æµ‹ç‚¹</strong>ï¼Œä¸€ä¸ªå¯ç”¨äºŽè§‚å¯Ÿã€ç›‘è§†ç›®çš„çš„å…·ä½“ä½ç½®ï¼Œæ¯”å¦‚ï¼šä¸€ä¸ªå‡½æ•°çš„å…¥å£ã€è¿”å›žåœ°å€</td>
</tr>
<tr>
<td>probe</td>
<td><strong>æŽ¢é’ˆ</strong>ï¼Œåœ¨æŽ¢æµ‹ç‚¹åšå…·ä½“äº‹æƒ…çš„å¯¹è±¡ï¼Œæ¯”å¦‚ï¼šåˆ†æžã€è¿½è¸ª</td>
</tr>
</tbody>
</table>
<p><strong>å¦‚æžœç”¨ä¸€å¥è¯è§£é‡Š Kprobes åŽŸç†å°±æ˜¯</strong>ï¼šKprobes åœ¨æŽ¢æµ‹ç‚¹ä¸Šæ³¨å†Œäº†ä¸€äº›æŽ¢é’ˆï¼Œå½“ CPU æ‰§è¡Œåˆ°æŽ¢æµ‹ç‚¹çš„æ—¶å€™ Kprobes ä¼šè°ƒç”¨æ‰€æœ‰ç›¸å…³æŽ¢é’ˆçš„å›žè°ƒå‡½æ•°ã€‚CPU æ˜¯æ€Žä¹ˆä»Žæ‰§è¡Œæµè½¬åˆ° Kprobes çš„å‘¢ï¼Ÿ</p>
<p><strong>æ³¨ï¼šå› ä¸ºæ°´å¹³æœ‰é™ï¼Œæ–‡ä¸­éš¾å…å­˜åœ¨é—æ¼æˆ–è€…é”™è¯¯çš„åœ°æ–¹ã€‚å¦‚æœ‰ç–‘é—®ï¼Œå»ºè®®ç›´æŽ¥é˜…è¯»åŽŸæ–‡ã€‚</strong></p>
<hr />
<!--
Concepts: Kprobes and Return Probes
===================================

Kprobes `enables you to dynamically break into` any kernel `routine` and
collect debugging and performance information `non-disruptively`. You
can trap at almost any kernel code address [1]_, specifying a handler
routine to be `invoked` when the breakpoint is hit.

.. [1] some parts of the kernel code can not be trapped, see

       :ref:`kprobes_blacklist`)
-->
<h2 id="æ¦‚å¿µ-kprobes-å’Œ-return-probes">æ¦‚å¿µï¼š Kprobes å’Œ Return Probes</h2>
<p>Kprobes èƒ½å¤Ÿè®©ä½ åŠ¨æ€çš„ä»‹å…¥å†…æ ¸çš„ä»»æ„å‡½æ•°ï¼Œä¸”æ— ä¸­æ–­çš„æ”¶é›†è°ƒè¯•å’Œæ€§èƒ½ä¿¡æ¯ã€‚åŸºæœ¬ä¸Šï¼Œä½ å¯ä»¥æ•èŽ·å†…æ ¸çš„ä»»æ„åœ°å€<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>ï¼ŒæŒ‡å®šä¸€ä¸ªåœ¨æ–­ç‚¹å‘½ä¸­å€™è°ƒç”¨å›žè°ƒå‡½æ•°ã€‚</p>
<!--
There are currently two types of probes: kprobes, and kretprobes
(also called return probes).  A kprobe can be inserted on `virtually`
any `instruction` in the kernel.  A return probe `fires` when a specified
function returns.
-->
<p>ç›®å‰ï¼ŒæŽ¢é’ˆæœ‰ä¸¤ç§ç±»åž‹ï¼škprobes ï¼Œkretprobesï¼ˆä¹Ÿè¢«ç§°ä¸º <code>return</code> æŽ¢é’ˆï¼‰ã€‚åŸºæœ¬ä¸Šï¼Œ kprobe å¯ä»¥å®‰æ’åˆ°ä»»æ„æŒ‡ä»¤ä¸Šã€‚å½“ä¸€ä¸ªæŒ‡å®šçš„å‡½æ•°è¿”å›žæ—¶è§¦å‘ <code>return</code> æŽ¢é’ˆã€‚</p>
<!--
In the typical case, Kprobes-based `instrumentation` is packaged as
a kernel module.  The moduleâ€™s init function installs (â€œregistersâ€)
one or more probes, and the exit function unregisters them.  A
`registration` function such as register_kprobe() specifies where
the probe is to be inserted and what handler is to be called when
the probe is hit.
-->
<p>é€šå¸¸ï¼ŒåŸºäºŽ Kprobes çš„æŽ¢æµ‹å·¥å…·è¢«æ‰“åŒ…æˆäº†ä¸€ä¸ªå†…æ ¸æ¨¡å—ã€‚æ¨¡å—çš„åˆå§‹åŒ–å‡½æ•°ä¼šå®‰è£…ï¼ˆæ³¨å†Œï¼‰ä¸€ä¸ªæˆ–å¤šä¸ªæŽ¢é’ˆï¼Œè€Œæ¨¡å—çš„å¸è½½å‡½æ•°ä¼šæ³¨é”€å®ƒä»¬ã€‚ <code>register_kprobe()</code> æ³¨å†Œå‡½æ•°æŒ‡æ˜ŽæŽ¢é’ˆè¦æ’å…¥åˆ°ä»€ä¹ˆä½ç½®ï¼ŒæŽ¢é’ˆå‘½ä¸­çš„æ—¶å€™è¦è°ƒç”¨ä»€ä¹ˆæ ·çš„å‡½æ•°ã€‚</p>
<!--
There are also `register_/unregister_*probes()` functions for `batch`
registration/unregistration of a group of `*probes`. These functions
can `speed up` unregistration process when you have to unregister
a lot of probes at once.
-->
<p>ä¹Ÿæœ‰ä¸€äº›ç”¨æ¥æ‰¹é‡æ³¨é”€æˆ–æ³¨å†Œä¸€ç»„æŽ¢é’ˆçš„ <code>register_/unregister_*probes()</code> å‡½æ•°ã€‚åœ¨å¿…é¡»ä¸€æ¬¡æ€§æ³¨é”€å¤§é‡æŽ¢é’ˆçš„æ—¶å€™ï¼Œè¿™äº›å‡½æ•°å¯ä»¥åŠ å¿«æ³¨é”€è¿‡ç¨‹ã€‚</p>
<!--
The next four subsections explain how the different types of
probes work and how jump optimization works.  They explain certain
things that youâ€™ll need to know in order to make the best use of
Kprobes â€” e.g., the difference between a pre_handler and
a post_handler, and how to use the maxactive and nmissed fields of
a kretprobe.  But if youâ€™re in a hurry to start using Kprobes, you
can skip ahead to :ref:`kprobes_archs_supported`.
-->
<p>æŽ¥ä¸‹æ¥çš„å››ä¸ªå°èŠ‚ä¼šè§£é‡Šä¸åŒç±»åž‹çš„æŽ¢é’ˆåŠè·³è½¬ä¼˜åŒ–æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚è¿™äº›å†…å®¹è®²äº†ä¸€äº›å¿…é¡»è¦çŸ¥é“çš„äº‹é¡¹ï¼Œä»¥ä¾¿å……åˆ†åˆ©ç”¨ Kprobes ï¼Œä¾‹å¦‚ï¼š <code>pre_handler</code> ä¸Ž <code>post_handler</code> ä¹‹é—´çš„åŒºåˆ«ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨ kretprobes çš„ <code>maxactive</code> ã€ <code>nmissed</code> å­—æ®µã€‚ä¸è¿‡ï¼Œå‡å¦‚ä½ æƒ³é©¬ä¸Šè¯•è¯• Kprobes çš„è¯ï¼Œå¯ä»¥ç›´æŽ¥è·³è‡³[##æ”¯æŒçš„æž¶æž„]ç« èŠ‚ã€‚</p>
<!--
## How Does a Kprobe Work?
When a kprobe is registered, Kprobes `makes a copy of` the probed
`instruction` and replaces the first byte(s) of the probed instruction
with a breakpoint instruction (e.g., int3 on i386 and x86_64).
-->
<h3 id="kprobe-å¦‚ä½•å·¥ä½œ">Kprobe å¦‚ä½•å·¥ä½œï¼Ÿ</h3>
<p>Kprobes åœ¨æ³¨å†Œäº†ä¸€ä¸ª kprobe åŽï¼Œå¤åˆ¶è¢«æŽ¢æµ‹çš„æŒ‡ä»¤ï¼Œå¹¶ä¸”æŠŠè¢«æŽ¢æµ‹æŒ‡ä»¤çš„ç¬¬ä¸€ä¸ªå­—èŠ‚æ›¿æ¢ä¸ºæ–­ç‚¹æŒ‡ä»¤ï¼ˆä¾‹å¦‚ï¼šåœ¨ i386ã€x86_64 å¹³å°ä¸Šçš„ <code>int3</code>ï¼‰ã€‚</p>
<!--
When a CPU hits the breakpoint instruction, a trap `occurs`, the CPUâ€™s
registers are saved, and control passes to Kprobes via the
notifier_call_chain `mechanism`.  Kprobes executes the â€œpre_handlerâ€
`associated with` the kprobe, passing the handler the addresses of the
kprobe struct and the saved registers.
-->
<p>åœ¨ CPU å‘½ä¸­æ–­ç‚¹æŒ‡ä»¤æ—¶ï¼Œä¼šå‘ç”Ÿä¸€ä¸ª <code>trap</code>ï¼ŒCPU çš„å¯„å­˜å™¨ä¼šè¢«ä¿å­˜ï¼Œè€ŒæŽ§åˆ¶é€šè¿‡ notifier_call_chain æœºåˆ¶è½¬ç§»åˆ° Kprobes ã€‚Kprobes æ‰§è¡Œä¸Ž kprobe å…³è”çš„ <code>pre_handler</code>ï¼Œå¹¶ä¸”å‘å®ƒä¼ é€’ kprobe ç»“æž„ä½“å’Œä¿å­˜çš„å¯„å­˜å™¨åœ°å€ã€‚</p>
<!--
Next, Kprobes single-steps its copy of the probed instruction.
(It would be simpler to single-step the actual instruction `in place`,
but then Kprobes would have to temporarily remove the breakpoint
instruction.  This would open a small time window when another CPU
could `sail` right past the probepoint.)
-->
<p>æŽ¥ç€ï¼ŒKprobes å•æ­¥æ‰§è¡Œè¢«æŽ¢æµ‹æŒ‡ä»¤çš„å‰¯æœ¬ã€‚ï¼ˆè™½ç„¶å•æ­¥æ‰§è¡ŒåŽŸå§‹æŒ‡ä»¤ä¼šæ›´ç®€å•ï¼Œä½†è¿‡åŽ Kprobes è¿˜å¿…é¡»ç§»é™¤æ–­ç‚¹æŒ‡ä»¤ã€‚å½“å¦ä¸€ä¸ª CPU æ‰§è¡Œè¿‡æŽ¢æµ‹ç‚¹çš„æ—¶å€™ï¼Œå°†ä¼šæ‰“å¼€ä¸€ä¸ªå°çš„æ—¶é—´çª—å£ã€‚ï¼‰</p>
<!--
After the instruction is single-stepped, Kprobes executes the
â€œpost_handlerâ€, if any, that is associated with the kprobe.
Execution then continues with the instruction following the probepoint.
-->
<p>åœ¨æŒ‡ä»¤å•æ­¥æ‰§è¡Œå®Œä¹‹åŽï¼ŒKprobes ä¼šæ‰§è¡Œä¸Ž kprobe å…³è”çš„ <code>post_handler</code>ï¼Œå¦‚æžœæœ‰çš„è¯ã€‚ç„¶åŽï¼Œç»§ç»­æ‰§è¡ŒæŽ¢æµ‹ç‚¹ä¹‹åŽçš„æŒ‡ä»¤ã€‚</p>
<!--
## Changing Execution Path
Since kprobes can probe into a running kernel code, it can change the
register set, including instruction pointer. This operation requires
maximum care, such as keeping the stack frame, recovering the execution
path etc. Since it operates on a running kernel and needs deep knowledge
of computer architecture and `concurrent` computing, you can easily shoot
your foot.
-->
<h3 id="æ”¹å˜æ‰§è¡Œè·¯å¾„">æ”¹å˜æ‰§è¡Œè·¯å¾„</h3>
<p>kprobes èƒ½å¤ŸæŽ¢æµ‹ä¸€æ®µæ­£åœ¨è¿è¡Œçš„å†…æ ¸ä»£ç ï¼Œå› æ­¤å®ƒèƒ½æ”¹å˜å¯„å­˜å™¨ï¼ŒåŒ…æ‹¬æŒ‡ä»¤æŒ‡é’ˆã€‚ç±»ä¼¼ä¿å­˜æ ˆå¸§ã€æ¢å¤æ‰§è¡Œè·¯å¾„ï¼Œè¿™ç±»æ“ä½œéœ€è¦éžå¸¸åœ°å°å¿ƒï¼Œå› ä¸º kprobes ä½œç”¨åœ¨æ­£åœ¨è¿è¡Œçš„å†…æ ¸ä¸Šé¢ï¼Œéœ€è¦æ·±å…¥çš„äº†è§£è®¡ç®—ç»“æž„ä½“ç³»å’Œå¹¶è¡Œè®¡ç®—æ‰è¡Œã€‚</p>
<!--
If you change the instruction pointer (and set up other `related`
registers) in pre_handler, you must return !0 `so that` kprobes stops
single stepping and just returns to the given address.
This also means post_handler should not be called anymore.
-->
<p>å‡å¦‚ä½ åœ¨ <code>pre_handler</code> å›žè°ƒå‡½æ•°å†…æ”¹å˜æŒ‡ä»¤æŒ‡é’ˆï¼ˆä»¥åŠè®¾ç½®å…¶å®ƒç›¸å…³çš„å¯„å­˜å™¨ï¼‰ï¼Œé‚£ä½ å¿…é¡»è¿”å›žéžé›¶å€¼ï¼Œå¥½è®© kprobes åœæ­¢å•æ­¥æ‰§è¡Œå¹¶ç«‹å³è¿”å›žåˆ°æŒ‡å®šåœ°å€ã€‚è¿™ä¹Ÿè¡¨ç¤º <code>post_handler</code> ä¸åº”è¯¥å†è¢«è°ƒç”¨ã€‚</p>
<!--
Note that this operation may be harder on some architectures which use
TOC (Table of Contents) for function call, `since` you have to setup a new
TOC for your function in your module, and recover the old one after
returning from it.
-->
<p>æ³¨æ„ï¼Œåœ¨é‚£äº›ä½¿ç”¨ TOC ï¼ˆç›®å½•ï¼‰è¿›è¡Œå‡½æ•°è°ƒç”¨çš„æž¶æž„ä¸Šï¼Œè¿™ç§æ“ä½œå¯èƒ½ä¼šæ›´å›°éš¾ï¼Œå› ä¸ºä½ å¿…é¡»åœ¨ä½ çš„æ¨¡å—ä¸­ä¸ºä½ çš„å‡½æ•°è®¾ç½®æ–°çš„ TOCï¼Œå¹¶ä¸”åœ¨å‡½æ•°è¿”å›žä¹‹åŽè¿˜è¦æ¢å¤å…ˆå‰çš„ TOCã€‚</p>
<!--
## Return Probes
How Does a Return Probe Work?

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When you call register_kretprobe(), Kprobes establishes a kprobe at
the entry to the function.  When the probed function is called and this
probe is hit, Kprobes saves a copy of the return address, and replaces
the return address with the address of a â€œ`trampoline`.â€  The trampoline
is an `arbitrary` piece of code â€” typically just a nop instruction.
At boot time, Kprobes registers a kprobe at the trampoline.
-->
<h3 id="return-æŽ¢é’ˆ">Return æŽ¢é’ˆ</h3>
<h4 id="return-æŽ¢é’ˆå¦‚ä½•å·¥ä½œçš„">Return æŽ¢é’ˆå¦‚ä½•å·¥ä½œçš„ï¼Ÿ</h4>
<p>åœ¨ä½ è°ƒç”¨ <code>register_kretprobe()</code> å‡½æ•°çš„æ—¶å€™ï¼Œ Kprobes ä¼šåœ¨å‡½æ•°çš„å…¥å£å¤„å»ºç«‹ä¸€ä¸ª kprobeã€‚åœ¨è°ƒç”¨è¢«æŽ¢æµ‹å‡½æ•°çš„æ—¶å€™å‘½ä¸­è¿™ä¸ªæŽ¢é’ˆï¼Œ Kprobes ä¼šä¿å­˜ return åœ°å€çš„ä¸€ä¸ªå‰¯æœ¬ï¼Œä¸”ç”¨ä¸€ä¸ª â€œtrampolineâ€ï¼ˆè¹¦åºŠï¼‰çš„åœ°å€æ›¿æ¢ return åœ°å€ã€‚trampoline æ˜¯ä¸€æ®µä»»æ„çš„ä»£ç  â€” é€šå¸¸åªæ˜¯ nop æŒ‡ä»¤ã€‚åœ¨å¯åŠ¨çš„æ—¶å€™ï¼Œ Kprobes åœ¨è¹¦åºŠæ³¨å†Œäº†ä¸€ä¸ª kprobeã€‚</p>
<!--
When the probed function executes its return instruction, control
passes to the trampoline and that probe is hit.  Kprobesâ€™ trampoline
handler calls the `user-specified` return handler associated with the
kretprobe, then sets the saved instruction pointer to the saved return
address, and thatâ€™s where execution `resumes` upon return from the trap.
ç”Ÿè¯ï¼šuser-specified, set ... to, resume, uponï¼ˆæ­¤åŽçš„æ„æ€ï¼Œè·Ÿåœ¨å•è¯åŽé¢çš„å¥å­è¡¨è¾¾çš„äº‹æƒ…å®Œæˆä¹‹åŽçš„æ„æ€ï¼‰
-->
<p>åœ¨è¢«æŽ¢æµ‹çš„å‡½æ•°æ‰§è¡Œ return æŒ‡ä»¤æ—¶ï¼ŒæŽ§åˆ¶è½¬ç§»åˆ°è¹¦åºŠå‘½ä¸­æŽ¢é’ˆã€‚ Kprobes çš„è¹¦åºŠå¤„ç†å‡½æ•°è°ƒç”¨ä¸Ž kretprobe å…³è”çš„ç”¨æˆ·æŒ‡å®šçš„å›žè°ƒå‡½æ•°ï¼Œç„¶åŽæŠŠä¿å­˜çš„æŒ‡ä»¤æŒ‡é’ˆè®¾ç½®ä¸ºä¿å­˜çš„ return åœ°å€ï¼Œä¸€æ—¦ä»Ž trap è¿”å›žï¼Œæ‰§è¡Œä¼šåœ¨è¿™é‡Œæ¢å¤ã€‚</p>
<!--
While the probed function is executing, its return address is
stored in an object of type kretprobe_instance.  Before calling
register_kretprobe(), the user sets the maxactive field of the
kretprobe struct to specify how many instances of the specified
function can be probed `simultaneously`.  register_kretprobe()
pre-allocates the `indicated` number of kretprobe_instance objects.
ç”Ÿè¯ï¼šsimultaneous, indicatedï¼ˆå½¢å®¹è¯ï¼‰
-->
<p>åœ¨è¢«æŽ¢æµ‹çš„å‡½æ•°æ‰§è¡ŒæœŸé—´ï¼Œå®ƒçš„è¿”å›žåœ°å€è¢«ä¿å­˜åœ¨ä¸€ä¸ª <code>kretprobe_instance</code> ç±»åž‹çš„å¯¹è±¡ä¸­ã€‚åœ¨è°ƒç”¨ <code>register_kretprobe()</code> å‡½æ•°å‰ï¼Œç”¨æˆ·è®¾ç½® kretprobe ç»“æž„ä½“çš„ <code>maxactive</code> å­—æ®µè¡¨ç¤ºå¯åŒæ—¶æŽ¢æµ‹æŒ‡å®šå‡½æ•°çš„å®žä¾‹æ•°é‡ã€‚ <code>register_kretprobe()</code> å‡½æ•°ä¼šé¢„å…ˆåˆ†é…è§„å®šæ•°é‡çš„ <code>kretprobe_instance</code> å¯¹è±¡ã€‚</p>
<!--
For example, if the function is non-recursive and is called with a
spinlock held, maxactive = 1 should be enough.  If the function is
non-recursive and can never `relinquish` the CPU (e.g., via a semaphore
or `preemption`), NR_CPUS should be enough.  If maxactive <= 0, it is
set to a default value.  If CONFIG_PREEMPT is enabled, the default
is max(10, 2*NR_CPUS).  Otherwise, the default is NR_CPUS.
ç”Ÿè¯ï¼š with a spinlock held, relinquish, preemption
-->
<p>ä¾‹å¦‚ï¼Œå‡è®¾è¯¥å‡½æ•°æ˜¯éžé€’å½’çš„ï¼Œä¸”åœ¨è‡ªæ—‹é”é”ä½çš„æƒ…å†µä¸‹è¢«è°ƒç”¨ï¼Œé‚£ <code>maxactive</code> çš„å€¼ä¸º 1 åº”è¯¥è¶³å¤Ÿã€‚å¦‚æžœå‡½æ•°æ˜¯éžé€’å½’çš„ï¼Œä¸”æ°¸è¿œä¸æ”¾å¼ƒ CPU ï¼ˆä¾‹å¦‚ï¼šé€šè¿‡ä¿¡å·é‡æˆ–æŠ¢å ï¼‰ï¼Œé‚£ NR_CPUS åº”è¯¥è¶³å¤Ÿã€‚è¦æ˜¯ <code>maxactive</code> çš„å€¼å°äºŽç­‰äºŽé›¶çš„è¯ï¼Œä¼šè®¾ç½®æˆé»˜è®¤å€¼ã€‚å¦‚æžœå¼€å¯ CONFIG_PREEMPT é€‰é¡¹ï¼Œé»˜è®¤å€¼ä¸º <code>max(10, 2*NR_CPUS)</code>ï¼ˆåœ¨ä¸¤å€çš„ CPU æ•°é‡ä¸Ž 10 ä¹‹é—´å–è¾ƒå¤§çš„å€¼ï¼‰ã€‚å…¶ä»–æƒ…å†µï¼Œé»˜è®¤å€¼ä¸º NR_CPUSï¼ˆCPU æ•°é‡ï¼‰ã€‚</p>
<!--
Itâ€™s not a `disaster` if you set maxactive too low; youâ€™ll just miss
some probes.  In the kretprobe struct, the nmissed field is set to
zero when the return probe is registered, and is `incremented` every
time the probed function is entered but there is no kretprobe_instance
object available for establishing the return probe.
ç”Ÿè¯ï¼šdisaster, incremented
-->
<p>å¦‚æžœä½ æŠŠ <code>maxactive</code> è®¾ç½®çš„å¾ˆå°çš„è¯ï¼Œä¹Ÿä¸ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Œåªæ˜¯ä¼šæ¼æŽ‰ä¸€äº›æŽ¢é’ˆè€Œå·²ã€‚åœ¨ kretprobe ç»“æž„ä½“ä¸­ï¼Œreturn æŽ¢é’ˆæ³¨å†ŒåŽ <code>nmissed</code> å­—æ®µä¼šè®¾ç½®ä¸º 0ï¼Œä¹‹åŽåœ¨æ¯æ¬¡è¿›å…¥è¢«æŽ¢æµ‹å‡½æ•°ä¸”æ²¡æœ‰å¯ç”¨çš„ <code>kretprobe_instance</code> å¯¹è±¡å…³è” return æŽ¢æµ‹çš„æ—¶å€™ç´¯åŠ ã€‚</p>
<!--
### Kretprobe entry-handler
Kretprobes also provides an optional user-specified handler which runs
on function entry. This handler is specified by setting the entry_handler
field of the kretprobe struct. Whenever the kprobe `placed by` kretprobe at the
function entry is hit, the user-defined entry_handler, if any, is invoked.
If the entry_handler returns 0 (success) then a `corresponding` return handler
is `guaranteed` to be called upon function return. If the entry_handler
returns a non-zero error then Kprobes leaves the return address as is, and
the kretprobe has no further effect for that particular function instance.
ç”Ÿè¯ï¼šplaced by, correspondingï¼ˆå½¢å®¹è¯ï¼‰, guarantee, furtherï¼ˆè¿›ä¸€æ­¥ï¼‰, effectï¼ˆæ•ˆæžœï¼Œå½±å“ï¼‰
-->
<h4 id="kretprobe-å…¥å£å›žè°ƒå‡½æ•°">Kretprobe å…¥å£å›žè°ƒå‡½æ•°</h4>
<p>Kretprobes è¿˜æä¾›ä¸€ä¸ªå¯é€‰çš„ç”¨æˆ·å›žè°ƒå‡½æ•°ï¼Œå®ƒè¿è¡ŒäºŽå‡½æ•°å…¥å£ã€‚è¿™ä¸ªå›žè°ƒå‡½æ•°é€šè¿‡ kretprobe ç»“æž„ä½“ <code>entry_handler</code> å­—æ®µæŒ‡å®šã€‚æ¯å½“å‘½ä¸­æ”¾ç½®åœ¨å‡½æ•°å…¥å£å¤„çš„ kprobe æ—¶ï¼Œå°±ä¼šè°ƒç”¨ç”¨æˆ·è‡ªå®šä¹‰çš„ <code>entry_handler</code> å‡½æ•°ã€‚å¦‚æžœ <code>entry_handler</code> å‡½æ•°è¿”å›žé›¶ï¼ˆæˆåŠŸï¼‰ï¼Œé‚£ä¹ˆå¯¹åº”çš„ return å›žè°ƒå‡½æ•°ä¿è¯ä¼šåœ¨å‡½æ•°è¿”å›žçš„æ—¶å€™è¢«è°ƒç”¨ã€‚å¦‚æžœ <code>entry_handler</code> è¿”å›žä¸€ä¸ªéžé›¶é”™è¯¯ï¼Œ Kprobes ä¼šä¿ç•™è¿”å›žåœ°å€ï¼Œè€Œ kretprobe å¯¹ç‰¹å®šçš„å‡½æ•°å®žä¾‹æ²¡æœ‰å½±å“ã€‚</p>
<!--
Multiple entry and return handler `invocations` are matched using the unique
kretprobe_instance object associated with them. Additionally, a user
may also specify per return-instance private data to be part of each
kretprobe_instance object. This is especially useful when sharing private
data between corresponding user entry and return handlers. The size of each
private data object can be specified at kretprobe registration time by
setting the data_size field of the kretprobe struct. This data can be
accessed through the data field of each kretprobe_instance object.
ç”Ÿè¯ï¼šinvocationï¼ˆåè¯ï¼Œè°ƒç”¨ï¼‰, corresponding
-->
<p>ä½¿ç”¨ä¸Žå®ƒä»¬å…³è”çš„å”¯ä¸€å¯¹è±¡ kretprobe_instanceï¼Œå¯ä»¥åŒ¹é…è®¸å¤šçš„ entry å’Œ return å›žè°ƒå‡½æ•°è°ƒç”¨ã€‚å¦å¤–ï¼Œç”¨æˆ·ä¹Ÿå¯ä»¥æŠŠæ¯ä¸ª return-instace çš„ç§æœ‰æ•°æ®æŒ‡å®šä¸ºæ¯ä¸ª kretprobe_instance å¯¹è±¡çš„ä¸€éƒ¨åˆ†ã€‚è¿™åœ¨ entry å’Œ return å›žè°ƒå‡½æ•°ä¹‹é—´å…±äº«ç§æœ‰æ•°æ®æ—¶å°¤å…¶æœ‰ç”¨ã€‚æ¯ä¸ªç§æœ‰æ•°æ®å¯¹è±¡çš„å¤§å°å¯ä»¥åœ¨ kretprobe æ³¨å†Œæ—¶é€šè¿‡ kretprobe ç»“æž„ä½“ä¸­çš„ data_size å­—æ®µæŒ‡å®šã€‚ç§æœ‰æ•°æ®å¯ä»¥é€šè¿‡æ¯ä¸ª kretprobe_instance å¯¹è±¡çš„ data å­—æ®µè®¿é—®ã€‚</p>
<!--
`In case` probed function is entered but there is no kretprobe_instance
object available, then `in addition to` incrementing the nmissed count,
the user entry_handler invocation is also skipped.
-->
<p>å¦‚æžœå·²ç»è¿›å…¥è¢«æŽ¢æµ‹å‡½æ•°ä½†æ²¡æœ‰å¯ç”¨çš„ kretprobe_instance å¯¹è±¡ï¼Œé‚£ä¹ˆé™¤äº†å¢žåŠ  <code>nmissed</code> çš„è®¡æ•°ä¹‹å¤–ï¼Œè¿˜ä¼šè·³è¿‡ <code>entry_handler</code> è°ƒç”¨ã€‚</p>
<!--
.. _kprobes_jump_optimization:
How Does Jump Optimization Work?
---------------------------------
If your kernel is built with CONFIG_OPTPROBES=y (currently this flag
is automatically set â€˜yâ€™ on x86/x86-64, non-preemptive kernel) and
the â€œdebug.kprobes_optimizationâ€ kernel parameter is set to 1 (see
sysctl(8)), Kprobes tries to reduce probe-hit `overhead` by using a jump
instruction instead of a breakpoint instruction at each probepoint.
-->
<h3 id="è·³è½¬ä¼˜åŒ–å¦‚ä½•å·¥ä½œçš„">è·³è½¬ä¼˜åŒ–å¦‚ä½•å·¥ä½œçš„ï¼Ÿ</h3>
<p>å¦‚æžœå†…æ ¸ä½¿ç”¨ CONFIG_OPTPROBES=y ï¼ˆx86/x86-64ã€éžæŠ¢å å¼å†…æ ¸ä¸Šè¯¥æ ‡è®°è‡ªåŠ¨åœ°è®¾ç½®ä¸º yï¼‰ç¼–è¯‘ï¼Œä¸”å†…æ ¸å‚æ•° â€œdebug.kprobes_optimizationâ€ è®¾ç½®ä¸º 1 ï¼ˆè§ sysctl(8) ï¼‰ï¼Œé‚£ä¹ˆ Kprobes å°è¯•åœ¨æ¯ä¸ªæŽ¢æµ‹ç‚¹ç”¨ jump æŒ‡ä»¤ä»£æ›¿ breakpoint æŒ‡ä»¤æ¥å‡å°‘å‘½ä¸­æŽ¢é’ˆçš„å¼€é”€ã€‚</p>
<!--
Init a Kprobe
^^^^^^^^^^^^^

When a probe is registered, before `attempting` this optimization,
Kprobes inserts an `ordinary`, breakpoint-based kprobe at the specified
address. So, even if itâ€™s not possible to optimize this particular
probepoint, thereâ€™ll be a probe there.
-->
<h4 id="åˆå§‹åŒ–-kprobe">åˆå§‹åŒ– Kprobe</h4>
<p>åœ¨æ³¨å†Œäº†ä¸€ä¸ªæŽ¢é’ˆè¯•å›¾ä¼˜åŒ–ä¹‹å‰ï¼ŒKprobes ä¼šåœ¨æŒ‡å®šçš„åœ°å€æ’å…¥ä¸€ä¸ªæ™®é€šçš„ï¼ŒåŸºäºŽæ–­ç‚¹çš„ kprobeã€‚æ‰€ä»¥ï¼Œå³ä¾¿ä¸èƒ½ä¼˜åŒ–è¿™ä¸ªç‰¹å®šçš„æŽ¢æµ‹ç‚¹ï¼Œä¹Ÿä¼šæœ‰ä¸€ä¸ªæŽ¢é’ˆåœ¨é‚£å„¿ã€‚</p>
<!--
Safety Check
^^^^^^^^^^^^

Before optimizing a probe, Kprobes `performs` the following safety checks:

	* Kprobes verifies that the `region` that will be replaced by the jump
	instruction (the â€œoptimized regionâ€) lies entirely within one function.
	(A jump instruction is multiple bytes, and so may `overlay` multiple
	instructions.)

	* Kprobes analyzes the entire function and verifies that there is no
	jump into the optimized region.  Specifically:
		* the function contains no `indirect` jump;
		* the function contains no instruction that causes an exception (since
		the `fixup` code triggered by the exception could jump back into the
		optimized region â€” Kprobes checks the exception tables to verify this);
		* there is no near jump to the optimized region (`other than` to the first
		byte).

	* For each instruction in the optimized region, Kprobes verifies that
	the instruction can be executed `out of line`.
-->
<h4 id="å®‰å…¨æ£€æŸ¥">å®‰å…¨æ£€æŸ¥</h4>
<p>åœ¨è¿›è¡Œä¼˜åŒ–æŽ¢é’ˆä¹‹å‰ï¼ŒKprobes ä¼šåšä»¥ä¸‹å®‰å…¨æ£€æŸ¥ï¼š</p>
<ul>
<li>
<p>Kprobes æ ¡éªŒä¼šè¢« jump æŒ‡ä»¤æ›¿æ¢çš„åŒºåŸŸï¼ˆâ€å·²ä¼˜åŒ–çš„åŒºåŸŸâ€œï¼‰å®Œå…¨å¤„äºŽä¸€ä¸ªå‡½æ•°å†…éƒ¨ã€‚ï¼ˆjump æŒ‡ä»¤æ˜¯å¤šå­—èŠ‚æŒ‡ä»¤ï¼Œå› æ­¤å¯èƒ½ä¼šè¦†ç›–å¤šä¸ªæŒ‡ä»¤ï¼‰</p>
</li>
<li>
<p>Kprobes åˆ†æžæ•´ä¸ªå‡½æ•°ï¼Œå¹¶ä¸”ç¡®è®¤ä¸ä¼šè·³å…¥å·²ä¼˜åŒ–çš„åŒºåŸŸã€‚ç‰¹åˆ«æ˜¯ï¼š</p>
<ul>
<li>è¯¥å‡½æ•°ä¸åŒ…å«é—´æŽ¥è·³è½¬</li>
<li>è¯¥å‡½æ•°ä¸åŒ…å«å¼•èµ·å¼‚å¸¸çš„æŒ‡ä»¤ï¼ˆå› ä¸ºè¢«å¼‚å¸¸è§¦å‘çš„å›ºå®šä»£ç å¯èƒ½ä¼šè·³å›žåˆ°å·²ä¼˜åŒ–çš„åŒºåŸŸ â€” Kprobes ä¼šæ£€æŸ¥å¼‚å¸¸è¡¨æ¥éªŒè¯è¿™ä¸€ç‚¹ï¼‰</li>
<li>è¯¥å‡½æ•°é™„è¿‘æ²¡æœ‰è·³è½¬åˆ°å·²ä¼˜åŒ–çš„åŒºåŸŸï¼ˆé™¤äº†ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼‰</li>
</ul>
</li>
<li>
<p>å¯¹äºŽå·²ä¼˜åŒ–åŒºåŸŸä¸­çš„æ¯ä¸€ä¸ªæŒ‡ä»¤ï¼ŒKprobes ä¼šéªŒè¯å®ƒä»¬èƒ½å¦ç¦»çº¿æ‰§è¡Œã€‚</p>
</li>
</ul>
<!--
Preparing Detour Buffer
^^^^^^^^^^^^^^^^^^^^^^^

Next, Kprobes prepares a "detour" buffer, which contains the following
instruction sequence:

	- code to push the CPU's registers (emulating a breakpoint trap)
	- a call to the trampoline code which calls user's probe handlers.
	- code to restore registers
	- the instructions from the optimized region
	- a jump back to the original execution path.
-->
<h4 id="å‡†å¤‡-detour-ç¼“å†²åŒº">å‡†å¤‡ detour ç¼“å†²åŒº</h4>
<blockquote>
<p>detour æ„æ€æ˜¯åƒäº¤é€šèŠ‚ç‚¹ï¼ˆçŽ¯å²›ï¼‰é‚£æ ·</p>
</blockquote>
<p>æŽ¥ç€ï¼ŒKprobes å‡†å¤‡ä¸€ä¸ªâ€œçŽ¯å½¢â€ç¼“å†²åŒºï¼ŒåŒ…å«ä»¥ä¸‹æŒ‡ä»¤åºåˆ—ï¼š</p>
<ul>
<li>æŽ¨è¿› CPU å¯„å­˜å™¨çš„ä»£ç ï¼ˆæ¨¡æ‹Ÿæ–­ç‚¹ trapï¼‰</li>
<li>è°ƒç”¨è¹¦åºŠä»£ç ï¼Œå†é—´æŽ¥è°ƒç”¨ç”¨æˆ·çš„æŽ¢é’ˆå›žè°ƒå‡½æ•°</li>
<li>æ¢å¤å¯„å­˜å™¨çš„ä»£ç </li>
<li>ä¼˜åŒ–åŒºåŸŸçš„æŒ‡ä»¤</li>
<li>è·³å›žåŽŸå§‹æ‰§è¡Œè·¯å¾„çš„æŒ‡ä»¤</li>
</ul>
<!--
Pre-optimization
^^^^^^^^^^^^^^^^^

After preparing the detour buffer, Kprobes verifies that none of the
following situations exist:

	* The probe has a post_handler.
	* Other instructions in the optimized region are probed.
	* The probe is disabled.
-->
<h4 id="ä¼˜åŒ–å‰">ä¼˜åŒ–å‰</h4>
<p>åœ¨å‡†å¤‡ detour ç¼“å†²åŒºåŽï¼Œ Kprobes ä¼šæ£€æŸ¥ç¡®ä¿ä¸å‡ºçŽ°ä»¥ä¸‹æƒ…å†µï¼š</p>
<ul>
<li>æŽ¢é’ˆæœ‰ä¸€ä¸ª post_handler å›žè°ƒå‡½æ•°</li>
<li>åœ¨ä¼˜åŒ–åŒºåŸŸä¸­çš„å…¶ä»–æŒ‡ä»¤è¢«æŽ¢æµ‹äº†</li>
<li>å·²ç¦ç”¨çš„æŽ¢é’ˆ</li>
</ul>
<!--
In any of the above cases, Kprobes wonâ€™t start optimizing the probe.
Since these are temporary situations, Kprobes tries to start
optimizing it again if the situation is changed.
-->
<p>åœ¨ä¸Šè¿°ä»»ä½•ä¸€ç§æƒ…å†µä¸‹ï¼ŒKprobes éƒ½ä¸ä¼šä¼˜åŒ–æŽ¢é’ˆã€‚å› ä¸ºè¿™éƒ½æ˜¯ä¸´æ—¶æƒ…å†µï¼Œå¦‚æžœæƒ…å†µæœ‰å˜åŒ–ï¼ŒKprobes ä¼šå†æ¬¡è¿›è¡Œä¼˜åŒ–ã€‚</p>
<!--
If the kprobe can be optimized, Kprobes enqueues the kprobe to an
optimizing list, and kicks the kprobe-optimizer workqueue to optimize
it.  If the to-be-optimized probepoint is hit before being optimized,
Kprobes returns control to the original instruction path by setting
the CPUâ€™s instruction pointer to the copied code in the detour buffer
â€” thus at least avoiding the single-step.
-->
<p>å¦‚æžœ kprobe å¯ä»¥è¢«ä¼˜åŒ–ï¼ŒKprobes ä¼šæŠŠ kprobe åˆ—å…¥ä¼˜åŒ–é˜Ÿåˆ—ä¸­ï¼Œç„¶åŽå¯åŠ¨å·¥ä½œé˜Ÿåˆ— kprobe-optimizer åŽ»ä¼˜åŒ–å®ƒã€‚å¦‚æžœè¢«ä¼˜åŒ–çš„ probepoint åœ¨ä¼˜åŒ–ä¹‹å‰å‘½ä¸­ï¼Œ Kprobes é€šè¿‡æŠŠ CPU çš„æŒ‡ä»¤æŒ‡é’ˆè®¾ç½®ä¸º detour ç¼“å†²åŒºä¸­è¢«å¤åˆ¶çš„ä»£ç ï¼Œå°†æŽ§åˆ¶æƒè¿”å›žåˆ°åŽŸå§‹æŒ‡ä»¤è·¯å¾„ â€” è¿™æ ·åšè‡³å°‘é¿å…äº†å•æ­¥æ‰§è¡Œã€‚</p>
<!--
Optimization
^^^^^^^^^^^^^

The Kprobe-optimizer doesnâ€™t insert the jump instruction immediately;
`rather`, it calls synchronize_rcu() for safety first, because itâ€™s
possible for a CPU to be interrupted in the middle of executing the
optimized region [^3].  As you know, synchronize_rcu() can ensure
that all interruptions that were active when synchronize_rcu()
was called are done, but only if CONFIG_PREEMPT=n.  So, this version
of kprobe optimization supports only kernels with CONFIG_PREEMPT=n [^4].

After that, the Kprobe-optimizer calls stop_machine() to replace
the optimized region with a jump instruction to the detour buffer,
using text_poke_smp().
-->
<h4 id="ä¼˜åŒ–">ä¼˜åŒ–</h4>
<p>Kprobe-optimizer å¹¶ä¸ä¼šç«‹å³æ’å…¥ jump æŒ‡ä»¤ï¼Œç›¸åä¸ºäº†å®‰å…¨å®ƒä¼šå…ˆè°ƒç”¨ <code>synchronize_rcu()</code> å‡½æ•°ï¼Œå› ä¸ºåœ¨å¤„ç†ä¼˜åŒ–åŒºåŸŸçš„è¿‡ç¨‹ä¸­ CPU å¯èƒ½ä¼šè¢«ä¸­æ–­ <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>ã€‚å¦‚ä½ æ‰€çŸ¥ï¼Œ <code>synchronize_rcu()</code> å‡½æ•°å¯ä»¥ç¡®ä¿æ‰€æœ‰æ´»è·ƒçš„ä¸­æ–­åœ¨è°ƒç”¨ <code>synchronize_rcu()</code> çš„æ—¶å€™å·²ç»å®Œæˆï¼Œä½†å‰ææ˜¯ <code>CONFIG_PREEMPT=n</code> çš„æ—¶å€™ã€‚æ‰€ä»¥ï¼Œkprobe çš„ä¼˜åŒ–ç‰ˆæœ¬åªæ”¯æŒ <code>CONFIG_PREEMPT=n</code> çš„å†…æ ¸ <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>ã€‚</p>
<p>ä¹‹åŽï¼Œ Kprobe-optimizer è°ƒç”¨ <code>stop_machine()</code> å‡½æ•°æ›¿æ¢ä¼˜åŒ–åŒºåŸŸï¼Œç”¨ä¸€ä¸ªè·³è½¬åˆ° detour ç¼“å†²åŒºæŒ‡ä»¤ï¼Œä½¿ç”¨ <code>text_poke_smp()</code> å‡½æ•°ã€‚</p>
<!--
Unoptimization
^^^^^^^^^^^^^^^^^
When an optimized kprobe is unregistered, disabled, or blocked by
another kprobe, it will be unoptimized.  If this happens before
the optimization is complete, the kprobe is just `dequeued` from the
optimized list.  If the optimization has been done, the jump is
replaced with the original code (except for an int3 breakpoint in
the first byte) by using text_poke_smp().
-->
<h4 id="å–æ¶ˆä¼˜åŒ–">å–æ¶ˆä¼˜åŒ–</h4>
<p>å½“ä¼˜åŒ–çš„ kprobe è¢«å…¶ä»– kprobe æ³¨é”€ã€ç¦ç”¨æˆ–é˜»å¡žçš„æ—¶å€™ï¼Œå®ƒå°†ä¸ä¼šè¢«ä¼˜åŒ–ã€‚å¦‚æžœè¿™ç§æƒ…å†µåœ¨ä¼˜åŒ–å®Œæˆä¹‹å‰å‘ç”Ÿï¼Œåˆ™åªæ˜¯å°† kprobe ä»Žä¼˜åŒ–é˜Ÿåˆ—ä¸­ç§»é™¤ã€‚å¦‚æžœä¼˜åŒ–å·²ç»å®Œæˆï¼Œä¼šé€šè¿‡è°ƒç”¨ <code>text_poke_smp()</code> å‡½æ•°æŠŠ jump æŒ‡ä»¤æ›¿æ¢ä¸ºåŽŸå§‹ä»£ç ï¼ˆé™¤äº†ç¬¬ä¸€ä¸ªå­—èŠ‚ä¸­çš„ int3 æ–­ç‚¹ï¼‰ã€‚</p>
<!--
[^3]: Please imagine that the 2nd instruction is interrupted and then
the optimizer replaces the 2nd instruction with the jump address
while the interrupt handler is running. When the interrupt returns to
original address, there is no valid instruction, and it causes an unexpected result.
-->
<!--
[^4]: This optimization-safety checking may be replaced with the
stop-machine method that ksplice uses for supporting a CONFIG_PREEMPT=y
kernel.
-->
<!--
NOTE for geeks:
The jump optimization changes the kprobeâ€™s pre_handler behavior.
Without optimization, the pre_handler can change the kernelâ€™s execution
path by changing regs->ip and returning 1.  However, when the probe
is optimized, that `modification` is ignored.  `Thus`, if you want to
`tweak` the kernelâ€™s execution path, you need to `suppress` optimization,
using one of the following techniques:

	* Specify an empty function for the kprobeâ€™s post_handler.
	or
	* Execute â€˜sysctl -w debug.kprobes_optimization=nâ€™
-->
<p>geeks æ³¨æ„ï¼š<br />
è·³è½¬ä¼˜åŒ–æ”¹å˜äº† kprobe çš„ <code>pre_handler</code> çš„è¡Œä¸ºã€‚ä¼˜åŒ–å‰ï¼Œ<code>pre_handler</code> é€šè¿‡æ”¹å˜ <code>regs-&gt;ip</code> çš„åŒæ—¶è¿”å›ž 1 å¯ä»¥æ”¹å˜å†…æ ¸çš„æ‰§è¡Œè·¯å¾„ã€‚ç„¶è€Œï¼Œåœ¨ probe è¢«ä¼˜åŒ–çš„æ—¶å€™ï¼Œä¿®æ”¹ä¼šè¢«å¿½ç•¥ã€‚å› æ­¤ï¼Œå¦‚æžœä½ æƒ³å¾®è°ƒå†…æ ¸çš„æ‰§è¡Œè·¯å¾„ï¼Œéœ€è¦ä½¿ç”¨ä¸€ä¸ªæ–¹æ³•åŽ»æŠ‘åˆ¶ä¼˜åŒ–ï¼š</p>
<ul>
<li>ç»™ kprobe çš„ post_handler æŒ‡å®šä¸€ä¸ªç©ºå‡½æ•°</li>
<li>æ‰§è¡Œ <code>sysctl -w debug.kprobes_optimization=n</code> å‘½ä»¤</li>
</ul>
<!--
.. _kprobes_blacklist:
Blacklist
---------
Kprobes can probe most of the kernel except itself. This means
that there are some functions where kprobes cannot probe. Probing
(trapping) such functions can cause a recursive trap (e.g. double
fault) or the `nested` probe handler may never be called.
Kprobes manages such functions as a blacklist.
If you want to add a function into the blacklist, you just need
to (1) include linux/kprobes.h and (2) use NOKPROBE_SYMBOL() macro
to specify a blacklisted function.
Kprobes checks the given probe address `against` the blacklist and
rejects registering it, if the given address is in the blacklist.
-->
<h3 id="é»‘åå•">é»‘åå•</h3>
<p>Kprobes å¯ä»¥æŽ¢æµ‹é™¤è‡ªèº«ä»¥å¤–çš„å¤§éƒ¨åˆ†å†…æ ¸ç©ºé—´ã€‚è¿™è¡¨ç¤ºæœ‰ä¸€äº›å‡½æ•° kprobes æ— æ³•æŽ¢æµ‹ã€‚æŽ¢æµ‹ï¼ˆtrappingï¼‰è¿™æ ·çš„å‡½æ•°ä¼šå¯¼è‡´é€’å½’ trap ï¼ˆæ¯”å¦‚ï¼šåŒé‡æ•…éšœï¼‰æˆ–è€…åµŒå¥—çš„ probe å›žè°ƒå‡½æ•°å¯èƒ½æ°¸è¿œä¸ä¼šè¢«è°ƒç”¨ã€‚å¦‚æžœä½ æƒ³æ·»åŠ ä¸€ä¸ªå‡½æ•°åˆ°é»‘åå•ä¸­ï¼Œåªéœ€è¦ä¸¤ä¸ªæ­¥éª¤ï¼šé¦–å…ˆï¼Œå¼•å…¥<code> linux/kprobes.h</code> æ–‡ä»¶ï¼›å…¶æ¬¡ï¼Œä½¿ç”¨ <code>NOKPROBE_SYMBOL()</code> å®æŒ‡å®šä¸€ä¸ªè¦è¢«åˆ—å…¥é»‘åå•çš„å‡½æ•°ã€‚ Kprobes å¯¹ç…§é»‘åå•æ£€æŸ¥ä¼ å…¥çš„ probe åœ°å€ï¼Œå¦‚æžœä¼ å…¥çš„åœ°å€åœ¨é»‘åå•ä¸­ä¼šæ‹’ç»æ³¨å†Œã€‚</p>
<!--
.. kprobes_archs_supported:
## Architectures Supported
Kprobes and return probes are implemented on the following
architectures:
-->
<h2 id="æ”¯æŒçš„æž¶æž„">æ”¯æŒçš„æž¶æž„</h2>
<p>Kprobes å’Œ Kretprobes å·²åœ¨ä¸‹é¢çš„è¿™äº›ç»“æž„ä½“ç³»ä¸Šå®žçŽ°ï¼š</p>
<ul>
<li>i386 (Supports jump optimization)ï¼ˆæ”¯æŒè·³è½¬ä¼˜åŒ–ï¼‰</li>
<li>x86_64 (AMD-64, EM64T) (Supports jump optimization)ï¼ˆæ”¯æŒè·³è½¬ä¼˜åŒ–ï¼‰</li>
<li>ppc64</li>
<li>ia64 (Does not support probes on instruction slot1.)ï¼ˆåœ¨ slot1 æŒ‡ä»¤ä¸Šä¸æ”¯æŒ probesï¼‰</li>
<li>sparc64 (Return probes not yet implemented.)ï¼ˆè¿”å›ž probes è¿˜æ²¡å®žçŽ°ï¼‰</li>
<li>arm</li>
<li>ppc</li>
<li>mips</li>
<li>s390</li>
<li>parisc</li>
</ul>
<!--
Configuring Kprobes
===================
When configuring the kernel using make menuconfig/xconfig/oldconfig,
ensure that CONFIG_KPROBES is set to â€œyâ€. Under â€œGeneral setupâ€, look
for â€œKprobesâ€.

So that you can load and unload Kprobes-based instrumentation modules,
make sure â€œLoadable module supportâ€ (CONFIG_MODULES) and â€œModule
unloadingâ€ (CONFIG_MODULE_UNLOAD) are set to â€œyâ€.

Also make sure that CONFIG_KALLSYMS and perhaps even CONFIG_KALLSYMS_ALL
are set to â€œyâ€, since kallsyms_lookup_name() is used by the in-kernel
kprobe `address` resolution code.
-->
<h2 id="é…ç½®-kprobes">é…ç½® Kprobes</h2>
<p>åœ¨ä½¿ç”¨ <code>make menuconfig/xconfig/oldconfig</code> é…ç½®å†…æ ¸æ—¶ï¼Œç¡®ä¿ <code>CONFIG_KPROBES </code> è®¾ç½®ä¸º â€œyâ€ã€‚åœ¨ â€œGeneral setupâ€ å­—ç¬¦åŽæœç´¢ â€œKprobesâ€ã€‚</p>
<p>ä¸ºäº†å¯ä»¥åŠ è½½å’Œå¸è½½åŸºäºŽ Kprobes çš„æŽ¢æµ‹æ¨¡å—ï¼Œè¯·ç¡®ä¿å°†â€œæ”¯æŒæ¨¡å—åŠ è½½â€ï¼ˆCONFIG_MODULESï¼‰å’Œâ€œæ¨¡å—å¸è½½â€ï¼ˆCONFIG_MODULE_UNLOADï¼‰è®¾ç½®ä¸º â€œyâ€ã€‚</p>
<p>è¿˜è¦ç¡®ä¿å°†  <code>CONFIG_KALLSYMS </code> ç”šè‡³æ˜¯ <code>CONFIG_KALLSYMS_ALL</code> éƒ½è®¾ç½®ä¸º â€œyâ€ï¼Œå› ä¸º <code>kallsyms_lookup_name()</code> å‡½æ•°è¢«å†…æ ¸é‡Œçš„ kprobe åœ°å€è§£æžä»£ç ä½¿ç”¨ã€‚</p>
<!--
If you need to insert a probe in the middle of a function, you may find
it useful to â€œCompile the kernel with debug infoâ€ (CONFIG_DEBUG_INFO),
so you can use â€œobjdump -d -l vmlinuxâ€ to see the source-to-object
code mapping.
ç–‘æƒ‘ï¼šyou may find it useful to ...ï¼ˆit ä»£è¯ï¼ŒæŒ‡åŽé¢çš„ä»Žå¥ï¼‰
-->
<p>å¦‚æžœä½ éœ€è¦åœ¨å‡½æ•°ä¸­é—´æ’å…¥ probeï¼Œä¹Ÿè®¸å‘çŽ°â€œä½¿ç”¨ debug info ç¼–è¯‘å†…æ ¸â€ (<code>CONFIG_DEBUG_INFO</code>) éžå¸¸æœ‰ç”¨ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ <code>objdump -d -l vmlinux</code> å‘½ä»¤åŽ»æŸ¥çœ‹æºç åˆ°ç›®æ ‡ä»£ç çš„æ˜ å°„å…³ç³»ã€‚</p>
<!--
API Reference
=============
The Kprobes API includes a â€œregisterâ€ function and an â€œunregisterâ€
function for each type of probe. The API also includes â€œregister_*probesâ€
and â€œunregister_*probesâ€ functions for (un)registering arrays of probes.
Here are `terse`, mini-man-page specifications for these functions and
the associated probe handlers that youâ€™ll write. See the files in the
samples/kprobes/ sub-directory for examples.
-->
<h2 id="api-å‚è€ƒ">API å‚è€ƒ</h2>
<p>Kprobes API ä¸ºæ¯ç§æŽ¢é’ˆç±»åž‹æä¾›äº†ä¸€ä¸ªâ€æ³¨å†Œâ€œå’Œâ€œæ³¨é”€â€å‡½æ•°ã€‚è¿˜åŒ…æ‹¬æ‰¹é‡æ³¨å†Œã€æ³¨é”€æŽ¢é’ˆçš„ <code>register_*probes</code> å’Œ <code>unregister_*probes</code> å‡½æ•°ã€‚è¿™æœ‰äº›è¿·ä½ æ‰‹å†Œä»¥åŠå°†ä¼šç”¨åˆ°çš„ç›¸å…³çš„æŽ¢é’ˆå›žè°ƒå‡½æ•°çš„ç®€çŸ­è¯´æ˜Žã€‚ç›¸å…³ä¾‹å­ï¼Œå¯æŸ¥çœ‹åœ¨ <code>samples/kprobes/</code> å­ç›®å½•å†…çš„æ–‡ä»¶ã€‚</p>
<h3 id="register_kprobe">register_kprobe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">register_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Sets a breakpoint at the address kp->addr.  When the breakpoint is
hit, Kprobes calls kp->pre_handler.  After the probed instruction
is single-stepped, Kprobe calls kp->post_handler.  If a fault
occurs during execution of kp->pre_handler or kp->post_handler,
or during single-stepping of the probed instruction, Kprobes calls
kp->fault_handler.  Any or all handlers can be NULL. If kp->flags
is set KPROBE_FLAG_DISABLED, that kp will be registered but disabled,
so, its handlers arenâ€™t hit until calling enable_kprobe(kp).
-->
<p>åœ¨ <code>kp-&gt;addr</code> åœ°å€è®¾ç½®ä¸€ä¸ªæ–­ç‚¹ã€‚å‘½ä¸­æ–­ç‚¹æ—¶ï¼ŒKprobes è°ƒç”¨ <code>kp-&gt;pre_handler</code>ã€‚åœ¨æŽ¢æµ‹çš„æŒ‡ä»¤å•æ­¥æ‰§è¡ŒåŽï¼ŒKprobe è°ƒç”¨ <code>kp-&gt;post_handler</code>ã€‚å¦‚æžœä¸€ä¸ªé”™è¯¯å‘ç”Ÿï¼Œåœ¨æ‰§è¡Œ <code>kp-&gt;pre_handler</code> æˆ– <code>kp-&gt;post_handler</code> æœŸé—´ï¼Œåˆæˆ–è€…æ˜¯åœ¨å•æ­¥æ‰§è¡Œè¢«æŽ¢æµ‹æŒ‡ä»¤æœŸé—´ï¼ŒKprobes ä¼šè°ƒç”¨ <code>kp-&gt;fault_handler</code>ã€‚æ‰€æœ‰å›žè°ƒå‡½æ•°éƒ½å¯ä»¥æ˜¯ <code>NULL</code>ã€‚å¦‚æžœ <code>kp-&gt;flags</code> è®¾ç½®ä¸º  <code>KPROBE_FLAG_DISABLED</code> ï¼Œ<code>kp</code> å°†ä¼šè¢«æ³¨å†Œä¸”å¤„äºŽç¦ç”¨çŠ¶æ€ã€‚æ‰€ä»¥ <code>kp</code> çš„å›žè°ƒå‡½æ•°åœ¨è°ƒç”¨ <code>enable_kprobe(kp)</code> ä¹‹å‰ä¸ä¼šè¢«è°ƒç”¨ã€‚</p>
<!--
.. note
	1. With the introduction of the â€œsymbol_nameâ€ field to struct kprobe, the probepoint address resolution will now be taken care of by the kernel. The following will now work:

	kp.symbol_name = "symbol_name";

	(64-bit powerpc `intricacies` such as function descriptors are handled `transparently`)
	2. Use the â€œoffsetâ€ field of struct kprobe if the offset into the symbol
	to install a probepoint is known. This field is used to calculate the
	probepoint.
	3. Specify either the kprobe "symbol_name" OR the "addr". If both are
	specified, kprobe registration will fail with -EINVAL.
	4. With CISC architectures (such as i386 and x86_64), the kprobes code
	does not validate if the kprobe.addr is at an instruction `boundary`.
	Use â€œoffsetâ€ with `caution`.

register_kprobe() returns 0 on success, or a negative errno otherwise.
-->
<p>æ³¨æ„ï¼š</p>
<ol>
<li>
<p>é€šè¿‡å¼•å…¥ <code>symbol_name</code> å­—æ®µæ¥æž„é€  kprobeï¼ŒæŽ¢æµ‹ç‚¹åœ°å€è§£æžå°†ä¼šç”±å†…æ ¸æ¥å¤„ç†ã€‚å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å†…å®¹ï¼š</p>
<p><code>kp.symbol_name = &quot;symbol_name&quot;;</code></p>
<p>ï¼ˆ64 ä½ powepc é”™ç»¼å¤æ‚ï¼Œä¾‹å¦‚é€æ˜Žåœ°å¤„ç†å‡½æ•°æè¿°ç¬¦ï¼‰</p>
</li>
<li>
<p>å¦‚æžœåœ¨ç¬¦å·ä¸­ç”¨äºŽå®‰è£…æŽ¢æµ‹ç‚¹çš„åç§»é‡æ˜¯å·²çŸ¥çš„ï¼Œè¯·ä½¿ç”¨ kprobes ç»“æž„ä½“çš„ <code>offset</code> å­—æ®µã€‚è¿™ä¸ªå­—æ®µç”¨äºŽè®¡ç®—æŽ¢æµ‹ç‚¹ã€‚</p>
</li>
<li>
<p>kprobe çš„ <code>symbol_name</code> æˆ–è€… <code>addr</code> å­—æ®µéƒ½è¢«æŒ‡å®šï¼Œkprobe æ³¨å†Œä¼šå¤±è´¥ä¸”è¿”å›ž <code>EINVAL</code>ã€‚</p>
</li>
<li>
<p>ä½¿ç”¨ CISC æž¶æž„ï¼ˆå¦‚ï¼ši386ï¼Œx86_64ï¼‰ï¼Œkprobes ä»£ç ä¸ä¼šéªŒè¯ï¼Œå¦‚æžœ <code>kprobe.addr</code> åœ¨æŒ‡ä»¤è¾¹ç•Œã€‚è°¨æ…Žä½¿ç”¨ <code>offset</code>ã€‚</p>
</li>
</ol>
<p><code>register_kprobe()</code> å‡½æ•°æˆåŠŸè¿”å›ž 0ï¼Œå…¶ä»–æƒ…å†µè¿”å›žä¸€ä¸ªè´Ÿçš„ <code>errno</code>ã€‚</p>
<p>ç”¨æˆ·çš„ pre-handlerï¼ˆ<code>kp-&gt;pre_handler</code>ï¼‰å‡½æ•°åŽŸåž‹:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/ptrace.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">pre_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Called with p pointing to the kprobe associated with the breakpoint,
and regs pointing to the struct containing the registers saved when
the breakpoint was hit.  Return 0 here unless youâ€™re a Kprobes geek.
-->
<p>ç”¨æŒ‡å‘ä¸Žæ–­ç‚¹å…³è”çš„ kprobe æŒ‡é’ˆ <code>p</code> ä»¥åŠå‘½ä¸­æ–­ç‚¹æ—¶ä¿å­˜çš„å¯„å­˜å™¨æŒ‡é’ˆ <code>regs</code> è°ƒç”¨ã€‚</p>
<!-- Userâ€™s post-handler (kp->post_handler): -->
<p>ç”¨æˆ·çš„ post-handler ï¼ˆ<code>kp-&gt;post_handler</code>ï¼‰å‡½æ•°åŽŸåž‹ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/ptrace.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">post_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
p and regs are as described for the pre_handler.  flags always seems to be zero.
-->
<p><code>p</code> å’Œ <code>regs</code> åŒ  <code>pre_handler</code> æ‰€è¿°ã€‚<code>flags</code> çœ‹èµ·æ¥ä¸€ç›´æ˜¯ 0ã€‚</p>
<!--
Userâ€™s fault-handler (kp->fault_handler):
-->
<p>ç”¨æˆ·çš„ fault-handler ï¼ˆ<code>kp-&gt;fault_handler</code>ï¼‰å‡½æ•°åŽŸåž‹ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/ptrace.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">fault_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapnr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
p and regs are as described for the pre_handler.  trapnr is the
architecture-specific trap number associated with the fault (e.g.,
on i386, 13 for a general protection fault or 14 for a page fault).
Returns 1 if it successfully handled the exception.
-->
<p><code>p</code> å’Œ <code>regs</code> åŒ <code>pre_handler</code> æ‰€è¿° ã€‚ <code>trapnr</code> æ˜¯æ•…éšœç›¸å…³çš„ç‰¹å®šæž¶æž„ä¸‹çš„ trap å·ï¼ˆä¾‹å¦‚ï¼šåœ¨ i386 ä¸Šï¼Œ 13 ä¸ºæ™®é€šé˜²æŠ¤æ•…éšœï¼Œ14 ä¸ºé¡µé¢æ•…éšœï¼‰ã€‚å¦‚æžœæˆåŠŸçš„å¤„ç†äº†å¼‚å¸¸è¿”å›ž 1ã€‚</p>
<h3 id="register_kretprobe">register_kretprobe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">register_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Establishes a return probe for the function whose address is
rp->kp.addr.  When that function returns, Kprobes calls rp->handler.
You must set rp->maxactive `appropriately` before you call
register_kretprobe(); see â€œHow Does a Return Probe Work?â€ for details.

register_kretprobe() returns 0 on success, or a negative errno otherwise.
-->
<p>ä¸º <code>rp-&gt;kp.addr</code> åœ°å€çš„å‡½æ•°å»ºç«‹ä¸€ä¸ª return æŽ¢é’ˆã€‚åœ¨å‡½æ•°è¿”å›žæ—¶ï¼Œkprobes è°ƒç”¨ <code>rp-&gt;handler</code> ã€‚åœ¨è°ƒç”¨ <code>register_kretprobe()</code> ä¹‹å‰å¿…é¡»è®¾ç½®åˆé€‚çš„ <code>rp-&gt;maxactive</code>ï¼Œç»†èŠ‚å‚è€ƒ â€œReturn Probe å¦‚ä½•å·¥ä½œï¼Ÿâ€ ã€‚</p>
<p><code>register_kretprobe()</code> æˆåŠŸè¿”å›ž 0ï¼Œå…¶ä»–æƒ…å†µè¿”å›žä¸€ä¸ªè´Ÿçš„ <code>errno</code>ã€‚</p>
<!--
Userâ€™s return-probe handler (rp->handler):
-->
<p>ç”¨æˆ·çš„ return æŽ¢é’ˆå›žè°ƒå‡½æ•°ï¼ˆ<code>rp-&gt;handler</code>ï¼‰åŽŸåž‹ï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/ptrace.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">kretprobe_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe_instance</span> <span class="o">*</span><span class="n">ri</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
regs is as described for kprobe.pre_handler.  ri points to the
kretprobe_instance object, of which the following fields may be of interest:

	* ret_addr: the return address
	* rp: points to the corresponding kretprobe object
	* task: points to the corresponding task struct
	* data: points to per return-instance private data; see â€œKretprobe
	entry-handlerâ€ for details.
-->
<p><code>regs</code> åŒ kprobe.pre_handler æè¿°é‚£æ ·ã€‚<code>ri</code> æŒ‡å‘ <code>kretprobe_instance</code> å¯¹è±¡ï¼Œå…¶ä¸­å¯èƒ½æ¶‰åŠä»¥ä¸‹å­—æ®µï¼š</p>
<ul>
<li>ret_addrï¼šè¿”å›žåœ°å€</li>
<li>rpï¼šæŒ‡å‘ç›¸å…³çš„ kretprobe å¯¹è±¡</li>
<li>taskï¼šæŒ‡å‘ç›¸å…³çš„ task ç»“æž„ä½“</li>
<li>dataï¼šæŒ‡å‘æ¯ä¸ª return-instace ç§æœ‰æ•°æ®ï¼Œç»†èŠ‚å‚è€ƒ â€œkretprobe entry-handlerâ€ã€‚</li>
</ul>
<!--
The regs_return_value(regs) macro provides a simple abstraction to
`extract` the return value from the `appropriate` register as defined by
the architectureâ€™s ABI.

The handlerâ€™s return value is currently ignored.
-->
<p><code>regs_return_value(regs)</code> å®æä¾›ä¸€ä¸ªç®€å•çš„æŠ½è±¡æ–¹æ³•ï¼Œä»Žæž¶æž„çš„ ABI å®šä¹‰çš„åˆé€‚çš„å¯„å­˜å™¨ä¸­æå–è¿”å›žå€¼ã€‚</p>
<p>ç›®å‰ï¼Œå›žè°ƒå‡½æ•°çš„è¿”å›žå€¼æ˜¯è¢«å¿½ç•¥çš„ã€‚</p>
<h3 id="unregister_probe">unregister_*probe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">	<span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span>	<span class="kt">void</span> <span class="nf">unregister_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="nf">unregister_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Removes the specified probe.  The unregister function can be called
at any time after the probe has been registered.

.. note

	If the functions find an incorrect probe (ex. an unregistered probe),
	they clear the addr field of the probe.
-->
<p>ç§»é™¤æŽ¢é’ˆã€‚æ³¨é”€å‡½æ•°å¯ä»¥åœ¨æŽ¢é’ˆè¢«æ³¨å†ŒåŽè°ƒç”¨ã€‚</p>
<p>æ³¨æ„ï¼š<br />
å¦‚æžœè¿™äº›å‘çŽ°ä¸€ä¸ªä¸æ­£ç¡®çš„æŽ¢é’ˆï¼ˆä¸åŒ…æ‹¬æœªæ³¨å†Œçš„æŽ¢é’ˆï¼‰ï¼Œå®ƒä»¬ä¼šæ¸…é™¤æŽ¢é’ˆçš„ <code>addr</code> å­—æ®µã€‚</p>
<h3 id="register_probes">register_*probes</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">register_kprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">**</span><span class="n">kps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">register_kretprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">**</span><span class="n">rps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Registers each of the num probes in the specified array.  If any
error occurs during registration, all probes in the array, up to
the bad probe, are safely unregistered before the register_*probes
function returns.

	* kps/rps: an array of pointers to `*probe` data structures
	* num: the number of the array entries.

.. note

	You have to allocate(or define) an array of pointers and set all
	of the array entries before using these functions.
-->
<p>æ³¨å†Œæ•°ç»„ä¸­ <code>num</code> ä¸ªæŽ¢é’ˆã€‚å¦‚æžœåœ¨æ³¨å†ŒæœŸé—´å‘ç”Ÿé”™è¯¯ï¼Œåœ¨ <code>register_*probes</code> å‡½æ•°è¿”å›žä¹‹å‰ä¼šå®‰å…¨åœ°æ³¨é”€æ•°ç»„ä¸­å·²æ³¨å†Œçš„æŽ¢é’ˆï¼Œç›´åˆ°å‘ç”Ÿé”™è¯¯çš„æŽ¢é’ˆä¸ºæ­¢ã€‚</p>
<ul>
<li><code>kps/rps</code>ï¼šæŒ‡å‘ <code>*probe</code> æ•°æ®ç»“æž„çš„æŒ‡é’ˆæ•°ç»„</li>
<li><code>num</code>ï¼šæ•°ç»„çš„å¤§å°</li>
</ul>
<p>æ³¨æ„ï¼š<br />
å¿…é¡»åˆ†é…ï¼ˆæˆ–å®šä¹‰ï¼‰æŒ‡é’ˆæ•°ç»„ï¼Œä¸”åœ¨ä½¿ç”¨è¿™äº›å‡½æ•°ä¹‹å‰è®¾ç½®æ•°ç»„çš„æ‰€æœ‰å…ƒç´ ã€‚</p>
<h3 id="unregister_probes">unregister_*probes</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">unregister_kprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">**</span><span class="n">kps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">unregister_kretprobes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">**</span><span class="n">rps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Removes each of the num probes in the specified array at once.

.. note

	If the functions find some incorrect probes (ex. unregistered
	probes) in the specified array, they clear the addr field of those
	incorrect probes. However, other probes in the array are
	unregistered correctly.
-->
<p>ä¸€æ¬¡æ€§ç§»é™¤æŒ‡å®šæ•°ç»„ä¸­ <code>num</code> ä¸ªæŽ¢é’ˆã€‚</p>
<p>æ³¨æ„ï¼š<br />
å¦‚æžœè¿™äº›å‡½æ•°åœ¨æ•°ç»„ä¸­å‘çŽ°ä¸€äº›ä¸æ­£ç¡®çš„æŽ¢é’ˆï¼ˆæ¯”å¦‚ï¼šæœªæ³¨å†Œçš„æŽ¢é’ˆï¼‰ï¼Œä¼šæ¸…é™¤é‚£äº›ä¸æ­£ç¡®æŽ¢é’ˆçš„ <code>addr</code> å­—æ®µã€‚æ•°ç»„ä¸­å…¶ä»–çš„æŽ¢é’ˆä¼šè¢«æ³¨é”€æŽ‰ã€‚</p>
<h3 id="disable_probe">disable_*probe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">disable_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">disable_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><!--
Temporarily disables the specified `*probe`. You can enable it again by using enable_*probe(). You must specify the probe which has been registered.
-->
<p>ä¸´æ—¶åœ°ç¦ç”¨æŸä¸ªæŽ¢é’ˆã€‚è°ƒç”¨ <code>enable_*probe()</code> å‡½æ•°å¯å†æ¬¡å¯ç”¨ã€‚å¿…é¡»æ˜¯å·²ç»æ³¨å†Œçš„æŽ¢é’ˆã€‚</p>
<h3 id="enable_probe">enable_*probe</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">enable_kprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">kp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">enable_kretprobe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kretprobe</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Enables <code>*probe</code> which has been disabled by disable_*probe(). You must specify the probe which has been registered.<br />
é€šè¿‡ <code>disable_*probe()</code> å¯ç”¨å·²ç»è¢«ç¦ç”¨çš„ <code>*probe</code>ã€‚å¿…é¡»æŒ‡å®šå·²ç»æ³¨å†Œçš„ probeã€‚</p>
<!--
Kprobes Features and Limitations
================================
Kprobes allows multiple probes at the same address. Also,
a probepoint for which there is a post_handler cannot be optimized.
So if you install a kprobe with a post_handler, at an optimized
probepoint, the probepoint will be unoptimized automatically.
-->
<h2 id="kprobes-ç‰¹æ€§ä¸Žé™åˆ¶">Kprobes ç‰¹æ€§ä¸Žé™åˆ¶</h2>
<p>kprobes å…è®¸åœ¨åŒä¸€ä¸ªåœ°å€æ’å…¥å¤šä¸ªæŽ¢é’ˆã€‚æ­¤å¤–ï¼Œå¸¦æœ‰ <code>post_handler</code> çš„æŽ¢æµ‹ç‚¹æ— æ³•è¢«ä¼˜åŒ–ã€‚æ‰€ä»¥ï¼Œå¦‚æžœåœ¨å·²ä¼˜åŒ–çš„æŽ¢æµ‹ç‚¹æ’å…¥å¸¦æœ‰ <code>post_handler</code> å›žè°ƒå‡½æ•°çš„ kprobe æŽ¢é’ˆï¼ŒæŽ¢æµ‹ç‚¹ä¼šè‡ªåŠ¨åœ°å˜æˆæœªä¼˜åŒ–çš„ã€‚</p>
<!--
In general, you can install a probe anywhere in the kernel.
In particular, you can probe interrupt handlers.  Known exceptions
are discussed in this section.
-->
<p>é€šå¸¸ï¼Œå¯ä»¥åœ¨å†…æ ¸çš„ä»»æ„ä½ç½®æ’å…¥æŽ¢é’ˆã€‚ç‰¹åˆ«çš„æ˜¯ï¼Œå®ƒå¯ä»¥æŽ¢æµ‹ä¸­æ–­å¤„ç†å‡½æ•°ã€‚æœ¬èŠ‚è®¨è®ºäº†å·²çŸ¥çš„å¼‚å¸¸ã€‚</p>
<!--
The register_*probe functions will return -EINVAL if you attempt
to install a probe in the code that implements Kprobes (mostly
kernel/kprobes.c and `arch/*/kernel/kprobes.c`, but also functions such
as do_page_fault and notifier_call_chain).
-->
<p>å¦‚æžœè¯•å›¾åœ¨å®žçŽ° Kprobes çš„ä»£ç ä¸­æ’å…¥ä¸€ä¸ªæŽ¢é’ˆï¼Œ<code>register_*probe</code> å‡½æ•°å°†è¿”å›ž <code>-EINVAL</code>ã€‚ï¼ˆåœ¨ <code>kernel/kprobes.c</code> å’Œ <code>arch/*/kernel/kprobes.c</code> æ–‡ä»¶ä¸­ï¼Œè¿˜æœ‰åƒ <code>do_page_fault</code> å’Œ <code>notifier_call_chain</code> è¿™ç±»çš„å‡½æ•°ï¼‰ã€‚</p>
<!--
If you install a probe in an inline-able function, Kprobes makes
no attempt to `chase down` all inline instances of the function and
install probes there.  gcc may inline a function without being asked,
so keep this in mind if youâ€™re not seeing the probe hits you expect.
-->
<p>å¦‚æžœåœ¨å¯å†…è”çš„å‡½æ•°ä¸­æ’å…¥æŽ¢é’ˆï¼ŒKprobes å¹¶ä¸ä¼šç»™æ‰€æœ‰å†…è”å®žä¾‹æ’å…¥æŽ¢é’ˆã€‚å¦‚æžœæ²¡æœ‰å‘½ä¸­æœŸæœ›çš„æŽ¢é’ˆï¼Œè®°ä½ä¸€ç‚¹ï¼Œ gcc å¯èƒ½ä¼šè‡ªåŠ¨å†…è”ä¸€ä¸ªå‡½æ•°ã€‚</p>
<!--
A probe handler can modify the environment of the probed function
-- e.g., by modifying kernel data structures, or by modifying the
contents of the pt_regs struct (which are restored to the registers
upon return from the breakpoint).  So Kprobes can be used, for example,
to install a bug fix or to inject faults for testing.  Kprobes, of
course, has no way to `distinguish` the `deliberately` injected faults
from the accidental ones.  Don't drink and probe.
-->
<p>æŽ¢é’ˆå›žè°ƒå‡½æ•°å¯ä»¥ä¿®æ”¹è¢«æ£€æµ‹å‡½æ•°çš„çŽ¯å¢ƒ &ndash; ä¾‹å¦‚ï¼Œæ”¹å˜å†…æ ¸æ•°æ®ç»“æž„æˆ–è€… <code>pt_regs</code> æ•°æ®ç»“æž„çš„å†…å®¹ï¼ˆä»Žæ–­ç‚¹è¿”å›žæ—¶æ¢å¤åˆ°å¯„å­˜å™¨ä¸­ï¼‰ã€‚å› æ­¤ï¼ŒKprobes å¯ç”¨äºŽå®‰è£… bug ä¿®å¤æˆ–æµ‹è¯•æ—¶æ³¨å…¥é”™è¯¯ã€‚å½“ç„¶ï¼Œ Kprobes æ˜¯æ²¡æœ‰åŠžæ³•æŠŠæ•…æ„åœ°æ³¨å…¥çš„é”™è¯¯ä¸Žæ„å¤–çš„é”™è¯¯åŒºåˆ†å¼€ã€‚ä¸è¦å–å¤§äº†æžäº‹æƒ…ã€‚</p>
<!--
Kprobes makes no attempt to prevent probe handlers from stepping on
each other â€” e.g., probing printk() and then calling printk() from a
probe handler.  If a probe handler hits a probe, that second probeâ€™s
handlers wonâ€™t be run in that instance, and the kprobe.nmissed member
of the second probe will be incremented.
-->
<p>Kprobes ä¸ä¼šé˜»æ­¢æŽ¢é’ˆå›žè°ƒå‡½æ•°ä¹‹é—´çš„ç›¸äº’ä½œç”¨ &ndash; æ¯”å¦‚ï¼Œå…ˆç»™ <code>printk()</code> å‡½æ•°æ’å…¥æŽ¢é’ˆï¼ŒæŽ¥ç€åˆä»Žå¦ä¸€ä¸ªæŽ¢é’ˆå›žè°ƒå‡½æ•°ä¸­è°ƒç”¨ <code>printk()</code> å‡½æ•°ã€‚å¦‚æžœæŽ¢é’ˆå›žè°ƒå‡½æ•°å‘½ä¸­ä¸€ä¸ªæŽ¢é’ˆï¼Œé‚£ä¹ˆè¿™ç¬¬äºŒä¸ªæŽ¢é’ˆçš„å›žè°ƒå‡½æ•°ä¸ä¼šæ‰§è¡Œï¼Œå°†åªä¼šç´¯åŠ æŽ¢é’ˆçš„ <code>kprobe.nmissed</code> å€¼ã€‚</p>
<!--
As of Linux v2.6.15-rc1, multiple handlers (or multiple instances of
the same handler) may run concurrently on different CPUs.
-->
<p>è‡ª Linux v2.6.15-rc1 å¼€å§‹ï¼Œå¤šä¸ªå›žè°ƒå‡½æ•°ï¼ˆæˆ–è€…ç›¸åŒå›žè°ƒå‡½æ•°çš„å¤šä¸ªå®žä¾‹ï¼‰å¯ä»¥åŒæ—¶åœ¨ä¸åŒçš„ CPU ä¸Šè¿è¡Œã€‚</p>
<!--
Kprobes does not use `mutexes` or allocate memory except during
registration and unregistration.
-->
<p>é™¤äº†æ³¨å†Œå’Œæ³¨é”€æŽ¢é’ˆä¹‹å¤–ï¼ŒKprobes ä¸ä¼šç”¨äº’æ–¥é”æˆ–åˆ†é…å†…å­˜ã€‚</p>
<!--
Probe handlers are run with preemption disabled or interrupt disabled,
which depends on the architecture and optimization state.  (e.g.,
kretprobe handlers and optimized kprobe handlers run without interrupt
disabled on x86/x86-64).  In any case, your handler should not yield
the CPU (e.g., by attempting to `acquire` a `semaphore`, or waiting I/O).
-->
<p>æŽ¢é’ˆå›žè°ƒå‡½æ•°åœ¨ç¦ç”¨æŠ¢å æˆ–è€…ç¦ç”¨ä¸­æ–­çš„æƒ…å†µä¸‹è¿è¡Œï¼Œè¿™å–å†³äºŽæž¶æž„ä»¥åŠä¼˜åŒ–çŠ¶æ€ï¼ˆä¾‹å¦‚ï¼Œkretprobe å’Œä¼˜åŒ–çš„ kprobe å›žè°ƒå‡½æ•°åœ¨ x86/x86-64 ä¸Šè¿è¡Œæ—¶æ²¡æœ‰ç¦ç”¨ä¸­æ–­ï¼‰ã€‚ä¸ç®¡å¦‚ä½•ï¼Œä½ çš„å›žè°ƒå‡½æ•°éƒ½ä¸åº”è¯¥è®©å‡º CPU ï¼ˆæ¯”å¦‚ï¼Œè¯•å›¾èŽ·å–ä¿¡å·é‡æˆ–ç­‰å¾… I/Oï¼‰ã€‚</p>
<!--
Since a return probe is implemented by replacing the return
address with the trampoline's address, stack `backtraces` and calls
to __builtin_return_address() will typically yield the trampolineâ€™s
address instead of the real return address for kretprobed functions.
(As far as we can tell, __builtin_return_address() is used only for instrumentation
and error reporting.)
-->
<p>å› ä¸º return æŽ¢é’ˆæ˜¯é€šè¿‡æŠŠè¹¦åºŠçš„åœ°å€æ›¿æ¢ä¸ºè¿”å›žåœ°å€æ¥å®žçŽ°çš„ï¼Œæ‰€ä»¥å †æ ˆå›žæº¯ä»¥åŠè°ƒç”¨  <code>__builtin_return_address()</code> å‡½æ•°å¾—åˆ°çš„æ˜¯è¹¦åºŠçš„åœ°å€ï¼Œè€Œä¸æ˜¯ kretprobed å‡½æ•°å®žé™… return åœ°å€ï¼ˆå°±ç›®å‰æˆ‘ä»¬çŸ¥é“çš„è€Œè¨€ï¼Œ<code>__builtin_return_address()</code> å‡½æ•°åªç”¨äºŽæµ‹è¯•å·¥å…·å’ŒæŠ¥å‘Šé”™è¯¯ï¼‰ã€‚</p>
<!--
If the number of times a function is called does not match the number
of times it returns, registering a return probe on that function may
produce `undesirable` results. In such a case, a line:
kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c
gets printed. With this information, one will be able to `correlate` the
exact instance of the kretprobe that caused the problem. We have the
do_exit() case covered. do_execve() and do_fork() are not an issue.
Weâ€™re `unaware of` other specific cases where this could be a problem.
-->
<p>å¦‚æžœä¸€ä¸ªå‡½æ•°çš„è°ƒç”¨æ¬¡æ•°ä¸èƒ½åŒ¹é…è¿”å›žçš„æ¬¡æ•°ï¼Œåœ¨é‚£ä¸ªå‡½æ•°ä¸Šæ³¨å†Œçš„æŽ¢é’ˆå¯èƒ½äº§ç”Ÿä¸æƒ³è¦çš„ç»“æžœã€‚è¿™ç§æƒ…å†µï¼Œä¼šè¾“å‡ºä¸€è¡Œ <code>kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c</code>ã€‚æœ‰äº†è¿™è¡Œä¿¡æ¯ï¼Œå°±å¯ä»¥å…³è”å¯¼è‡´é—®é¢˜çš„ kretprobe å®žä¾‹ã€‚æ¶µç›–äº† <code>do_exit()</code> å‡½æ•°çš„æƒ…å†µã€‚ <code>do_execve()</code> å’Œ <code>do_fork()</code> å‡½æ•°éƒ½ä¸æ˜¯é—®é¢˜ã€‚æˆ‘ä»¬ä¸çŸ¥é“çš„å…¶ä»–ç‰¹å®šçš„æƒ…å†µï¼Œå¯èƒ½ä¼šå‡ºçŽ°é—®é¢˜ã€‚</p>
<!--
If, upon entry to or exit from a function, the CPU is running on
a stack other than that of the current task, registering a return
probe on that function may produce undesirable results.  For this
reason, Kprobes doesnâ€™t support return probes (or kprobes)
on the x86_64 version of __switch_to(); the registration functions
return -EINVAL.
-->
<p>å¦‚æžœåœ¨è¿›å…¥æˆ–è€…é€€å‡ºæŸä¸ªå‡½æ•°æ—¶ï¼ŒCPU åœ¨é™¤å½“å‰ task ä»¥å¤–çš„å †æ ˆä¸Šè¿è¡Œï¼Œé‚£åœ¨è¿™ä¸ªå‡½æ•°ä¸Šæ³¨å†Œ return æŽ¢é’ˆå¯èƒ½ä¼šäº§ç”Ÿä¸æƒ³è¦çš„ç»“æžœã€‚å› ä¸ºè¿™ä¸ªåŽŸå› ï¼ŒKprobes ä¸æ”¯æŒ <code>__switch_to()</code> å‡½æ•° x86_64 ç‰ˆæœ¬çš„ return æŽ¢é’ˆï¼ˆæˆ– kprobesï¼‰ï¼Œæ³¨å†Œå‡½æ•°ä¼šè¿”å›ž <code>-EINVAL</code> ã€‚</p>
<!--
On x86/x86-64, since the Jump Optimization of Kprobes modifies
instructions widely, there are some limitations to optimization. To
explain it, we introduce some `terminology`. Imagine a 3-instruction
sequence consisting of a two 2-byte instructions and one 3-byte
instruction.
-->
<p>åœ¨ x86/x86-64 æž¶æž„ä¸Šï¼Œç”±äºŽ Kprobes è·³è½¬ä¼˜åŒ–ä¿®æ”¹æŒ‡ä»¤æ™®éå­˜åœ¨ï¼Œä¼šå¯¹ä¼˜åŒ–æœ‰ä¸€äº›é™åˆ¶ã€‚ä¸ºè§£é‡Šè¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¼•å…¥äº›æœ¯è¯­ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ä¸ªç”± 2 å­—èŠ‚æŒ‡ä»¤å’Œ 3 å­—èŠ‚æŒ‡ä»¤ç»„æˆçš„ 3 ä¸ªæŒ‡ä»¤åºåˆ—ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">	    <span class="n">IA</span>
	    <span class="o">|</span>
<span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">5</span><span class="p">][</span><span class="mi">6</span><span class="p">][</span><span class="mi">7</span><span class="p">]</span>
	    <span class="p">[</span><span class="n">ins1</span><span class="p">][</span><span class="n">ins2</span><span class="p">][</span>  <span class="n">ins3</span> <span class="p">]</span>
	    <span class="p">[</span><span class="o">&lt;-</span>     <span class="n">DCR</span>       <span class="o">-&gt;</span><span class="p">]</span>
	    <span class="p">[</span><span class="o">&lt;-</span> <span class="n">JTPR</span> <span class="o">-&gt;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">ins1</span><span class="p">:</span> <span class="mi">1</span><span class="n">st</span> <span class="n">Instruction</span>
<span class="nl">ins2</span><span class="p">:</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">Instruction</span>
<span class="nl">ins3</span><span class="p">:</span> <span class="mi">3</span><span class="n">rd</span> <span class="n">Instruction</span>
<span class="nl">IA</span><span class="p">:</span>  <span class="n">Insertion</span> <span class="n">Address</span>
<span class="nl">JTPR</span><span class="p">:</span> <span class="n">Jump</span> <span class="n">Target</span> <span class="n">Prohibition</span> <span class="n">Region</span>
<span class="nl">DCR</span><span class="p">:</span> <span class="n">Detoured</span> <span class="n">Code</span> <span class="n">Region</span>
</code></pre></td></tr></table>
</div>
</div><!--
The instructions in DCR are copied to the out-of-line buffer
of the kprobe, because the bytes in DCR are replaced by
a 5-byte jump instruction. So there are several limitations.

	a) The instructions in DCR must be relocatable.
	b) The instructions in DCR must not include a call instruction.
	c) JTPR must not be targeted by any jump or call instruction.
	d) DCR must not `straddle` the border between functions.

Anyway, these limitations are checked by the in-kernel instruction
decoder, so you donâ€™t need to worry about that.
-->
<p>DCR å†…çš„æŒ‡ä»¤è¢«å¤åˆ¶åˆ° kprobe çš„ç¦»çº¿ç¼“å†²åŒºä¸­ï¼Œå› ä¸º DCR å†…çš„å­—èŠ‚è¢« 5 å­—èŠ‚ jump æŒ‡ä»¤æ›¿ä»£äº†ã€‚æ‰€ä»¥ï¼Œè¿™å„¿ä¼šæœ‰å‡ ä¸ªé™åˆ¶ã€‚</p>
<ul>
<li>DCR å†…çš„æŒ‡ä»¤ä¸€å®šæ˜¯å¯é‡å®šä½çš„</li>
<li>DCR å†…çš„æŒ‡ä»¤ä¸€å®šä¸èƒ½åŒ…å« <code>call</code> æŒ‡ä»¤</li>
<li>JTPR ä¸èƒ½ä½œä¸º <code>jump</code> æˆ– <code>call</code> æŒ‡ä»¤çš„ç›®æ ‡</li>
<li>DCR ä¸èƒ½è·¨è¶Šå‡½æ•°ä¹‹é—´çš„è¾¹ç•Œ</li>
</ul>
<p>ä¸è¿‡ï¼Œè¿™äº›é™åˆ¶ç”±å†…æ ¸çš„æŒ‡ä»¤è§£ç å™¨æ£€æŸ¥ï¼Œæ‰€ä»¥ä¸éœ€è¦å…³å¿ƒè¿™äº›é™åˆ¶ã€‚</p>
<!--
Probe Overhead
==============
On a typical CPU in use in 2005, a kprobe hit takes 0.5 to 1.0
microseconds to process.  Specifically, a benchmark that hits the same
probepoint repeatedly, firing a simple handler each time, reports 1-2
million hits per second, depending on the architecture.  A return-probe
hit typically takes 50-75% longer than a kprobe hit.
When you have a return probe set on a function, adding a kprobe at
the entry to that function adds `essentially` no overhead.

Here are sample overhead `figures` (in usec) for different architectures:
-->
<h2 id="æŽ¢é’ˆçš„å¼€é”€">æŽ¢é’ˆçš„å¼€é”€</h2>
<p>åœ¨ 2005 å¹´å¸¸è§çš„ CPU ä¸Šï¼Œå¤„ç†å‘½ä¸­ kprobe è¦èŠ±è´¹ 0.5 - 1.0 å¾®ç§’ã€‚å…·ä½“ä¸€ç‚¹ï¼ŒåŸºå‡†æµ‹è¯•åå¤å‘½ä¸­åŒä¸€ä¸ªæŽ¢æµ‹ç‚¹ï¼Œæ¯ä¸€æ¬¡è§¦å‘ç®€å•çš„å›žè°ƒå‡½æ•°ï¼Œæ¯ç§’ 1-2 ç™¾ä¸‡æ¬¡å‘½ä¸­ï¼Œå…·ä½“æ•°å€¼å–å†³äºŽ CPU æž¶æž„ã€‚é€šå¸¸ï¼Œå‘½ä¸­ return æŽ¢é’ˆæ¯”å‘½ä¸­ kprobe å¤šèŠ±è´¹ 50-75% çš„æ—¶é—´ã€‚å½“ä½ æŠŠä¸€ä¸ª kretprobe æ’å…¥åˆ°ä¸€ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œå®žé™…æ˜¯åœ¨å‡½æ•°å…¥å£å¤„æ·»åŠ ä¸€ä¸ª kprobeï¼ŒåŸºæœ¬ä¸Šä¸Šå‡½æ•°ä¸ä¼šå¢žåŠ å¼€é”€ã€‚</p>
<p>ä¸‹é¢æœ‰äº›ä¸åŒæž¶æž„å¼€é”€çš„æ ·æœ¬ï¼ˆå¾®ç§’ï¼‰ï¼š</p>
<pre><code>k = kprobe; r = return probe; kr = kprobe + return probe
on same function

i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips
k = 0.57 usec; r = 0.92; kr = 0.99

x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips
k = 0.49 usec; r = 0.80; kr = 0.82

ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU)
k = 0.77 usec; r = 1.26; kr = 1.45
</code></pre>
<!--
Optimized Probe Overhead
========================
Typically, an optimized kprobe hit takes 0.07 to 0.1 microseconds to
process. Here are sample overhead figures (in usec) for x86 architectures:
-->
<h2 id="å·²ä¼˜åŒ–æŽ¢é’ˆå¼€é”€">å·²ä¼˜åŒ–æŽ¢é’ˆå¼€é”€</h2>
<p>é€šå¸¸ï¼Œå‘½ä¸­å·²ä¼˜åŒ–çš„ kprobe è¦èŠ±è´¹ 0.07 - 0.1 å¾®å¦™æ¥å¤„ç†ã€‚è¿™æ˜¯ x86 æž¶æž„å¼€é”€çš„æ ·æœ¬ï¼ˆå¾®å¦™ï¼‰ï¼š</p>
<pre><code>k = unoptimized kprobe, b = boosted (single-step skipped), o = optimized kprobe,
r = unoptimized kretprobe, rb = boosted kretprobe, ro = optimized kretprobe.

i386: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips
k = 0.80 usec; b = 0.33; o = 0.05; r = 1.10; rb = 0.61; ro = 0.33

x86-64: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips
k = 0.99 usec; b = 0.43; o = 0.06; r = 1.24; rb = 0.68; ro = 0.30
</code></pre>
<h2 id="todo">TODO</h2>
<!--
a. SystemTap (http://sourceware.org/systemtap): Provides a simplified
programming interface for probe-based instrumentation.  Try it out.
b. Kernel return probes for sparc64.
c. Support for other architectures.
d. User-space probes.
e. Watchpoint probes (which fire on data references).
-->
<pre><code>1. [SystemTap](http://sourceware.org/systemtap)ï¼šç»™åŸºäºŽæŽ¢é’ˆçš„æŽ¢æµ‹å·¥å…·æä¾›äº†ä¸€ä¸ªç®€å•çš„ç¼–ç¨‹æŽ¥å£ã€‚å¯ä»¥è¯•ä¸€ä¸‹
2. sparc64 æž¶æž„çš„ kretprobe
3. æ”¯æŒå…¶ä»–æž¶æž„
4. ç”¨æˆ·ç©ºé—´çš„æŽ¢é’ˆ
5. è§‚å¯Ÿç‚¹æŽ¢é’ˆï¼ˆåœ¨æ•°æ®å¼•ç”¨æ—¶è§¦å‘ï¼‰
</code></pre>
<h2 id="kprobes-ä¾‹å­">Kprobes ä¾‹å­</h2>
<p>è§ <a href="https://github.com/torvalds/linux/blob/master/samples/kprobes/kprobe_example.c">samples/kprobes/kprobe_example.c</a> æ–‡ä»¶</p>
<h2 id="kretprobes-ä¾‹å­">Kretprobes ä¾‹å­</h2>
<p>è§ <a href="https://github.com/torvalds/linux/blob/master/samples/kprobes/kretprobe_example.c">samples/kprobes/kretprobe_example.c</a> æ–‡ä»¶</p>
<!--
For additional information on Kprobes, `refer to` the following URLs:
-->
<p>æœ‰å…³ Kprobes çš„å…¶ä»–ä¿¡æ¯ï¼Œè¯·å‚è€ƒä»¥ä¸‹ URL é“¾æŽ¥ï¼š</p>
<ul>
<li><a href="http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe">http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe</a></li>
<li><a href="http://www.redhat.com/magazine/005mar05/features/kprobes/">http://www.redhat.com/magazine/005mar05/features/kprobes/</a></li>
<li><a href="http://www-users.cs.umn.edu/~boutcher/kprobes/">http://www-users.cs.umn.edu/~boutcher/kprobes/</a></li>
<li><a href="http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf">http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf</a> (pages 101-115)</li>
</ul>
<!--
Deprecated Features
===================
Jprobes is now a `deprecated` feature. People who are depending on it should
migrate to other tracing features or use older kernels. Please consider to
migrate your tool to one of the following options:

* Use trace-event to trace target function with arguments.

  trace-event is a low-overhead (and almost no visible overhead if it
  is off) statically defined event interface. You can define new events
  and trace it via ftrace or any other tracing tools.

  See the following urls:

    - https://lwn.net/Articles/379903/
    - https://lwn.net/Articles/381064/
    - https://lwn.net/Articles/383362/

* Use ftrace dynamic events (kprobe event) with perf-probe.

  If you build your kernel with debug info (CONFIG_DEBUG_INFO=y), you can
  find which register/stack is assigned to which local variable or arguments
  by using perf-probe and set up new event to trace it.

  See following documents:

	* Documentation/trace/kprobetrace.rst
	* Documentation/trace/events.rst
	* tools/perf/Documentation/perf-probe.txt
-->
<h2 id="å·²å¼ƒç”¨çš„æœºåˆ¶">å·²å¼ƒç”¨çš„æœºåˆ¶</h2>
<p>çŽ°åœ¨ Jprobes æ˜¯ä¸€ä¸ªä¸è¢«æŽ¨èçš„æœºåˆ¶ã€‚ä¾èµ–å®ƒçš„åº”è¯¥è¿ç§»åˆ°å…¶ä»–è¿½è¸ªæœºåˆ¶æˆ–ä½¿ç”¨æ—§çš„å†…æ ¸ã€‚è¯·è€ƒè™‘æŠŠä½ çš„å·¥å…·è¿ç§»åˆ°ä»¥ä¸‹å·¥å…·ä¸­ï¼š</p>
<ul>
<li>ä½¿ç”¨ trace-event è¿½è¸ªå¸¦å‚æ•°çš„å‡½æ•°</li>
</ul>
<blockquote>
<p>trace-event æ˜¯ä¸ªä½Žå¼€é”€çš„é™æ€å®šä¹‰çš„äº‹ä»¶æŽ¥å£ï¼ˆå¦‚æžœå…³é—­ï¼Œæ²¡æœ‰æ˜Žæ˜¾çš„å¼€é”€ï¼‰ã€‚ä½ å¯ä»¥å®šä¹‰æ–°äº‹ä»¶ï¼Œé€šè¿‡ ftrace æˆ–è€…å…¶ä»–è¿½è¸ªå·¥å…·è¿½è¸ªå®ƒã€‚<br />
å‚è€ƒä»¥ä¸‹ URL é“¾æŽ¥ï¼š<br />
- <a href="https://lwn.net/Articles/379903/">https://lwn.net/Articles/379903/</a><br />
- <a href="https://lwn.net/Articles/381064/">https://lwn.net/Articles/381064/</a><br />
- <a href="https://lwn.net/Articles/383362/">https://lwn.net/Articles/383362/</a></p>
</blockquote>
<ul>
<li>ä½¿ç”¨ ftrace åŠ¨æ€äº‹ä»¶ï¼ˆkprobe äº‹ä»¶ï¼‰å’Œ perf-probe</li>
</ul>
<blockquote>
<p>å¦‚æžœä½ ä½¿ç”¨è°ƒè¯•ä¿¡æ¯ï¼ˆ<code>CONFIG_DEBUG_INFO=y</code>ï¼‰ç¼–è¯‘ä½ çš„å†…æ ¸ï¼Œå¯ä»¥ç”¨ perf-probe è®¾ç½®æ–°äº‹ä»¶åŽ»è¿½è¸ªå®ƒï¼Œèƒ½å‘çŽ°å¯„å­˜å™¨/æ ˆè¢«åˆ†é…ç»™äº†å“ªä¸ªæœ¬åœ°å˜é‡æˆ–è€…å‚æ•°ã€‚<br />
å‚è€ƒä»¥ä¸‹æ–‡æ¡£ï¼š<br />
- <a href="https://github.com/torvalds/linux/blob/master/Documentation/trace/kprobetrace.rst">Documentation/trace/kprobetrace.rst</a><br />
- <a href="https://github.com/torvalds/linux/blob/master/Documentation/trace/events.rst">Documentation/trace/events.rst</a><br />
- <a href="https://github.com/torvalds/linux/blob/master/tools/perf/Documentation/perf-probe.txt">tools/perf/Documentation/perf-probe.txt</a></p>
</blockquote>
<!--
The kprobes debugfs interface
=============================
With recent kernels (> 2.6.20) the list of registered kprobes is visible
under the /sys/kernel/debug/kprobes/ directory (assuming debugfs is mounted at //sys/kernel/debug).

/sys/kernel/debug/kprobes/list: Lists all registered probes on the system:
-->
<h2 id="kprobes-debugfs-æŽ¥å£">kprobes debugfs æŽ¥å£</h2>
<p>æœ€æ–°çš„å†…æ ¸ï¼ˆ&gt; 2.6.20ï¼‰ï¼Œå·²ç»æ³¨å†Œçš„ kprobes åˆ—è¡¨ä½äºŽ <code>/sys/kernel/debug/kprobes/</code> ç›®å½•ä¹‹ä¸‹ï¼ˆå‡è®¾ debugfs è¢«æŒ‚è½½åˆ° <code>/sys/kernel/debug</code> ç›®å½•ï¼‰ã€‚</p>
<p><code>/sys/kernel/debug/kprobes/list</code>ï¼šåˆ—å‡ºåœ¨ç³»ç»Ÿä¸Šæ‰€æœ‰å·²æ³¨å†Œçš„ probesï¼š</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">c015d71a</span>  <span class="n">k</span>  <span class="n">vfs_read</span><span class="o">+</span><span class="mh">0x0</span>
<span class="n">c03dedc5</span>  <span class="n">r</span>  <span class="n">tcp_v4_rcv</span><span class="o">+</span><span class="mh">0x0</span>
</code></pre></td></tr></table>
</div>
</div><!--
The first column provides the kernel address where the probe is inserted.
The second column identifies the type of probe (k - kprobe and r - kretprobe)
while the third column specifies the symbol+offset of the probe.
If the probed function belongs to a module, the module name is also
specified. Following columns show probe status. If the probe is on
a virtual address that is no longer valid (module init sections, module
virtual addresses that correspond to modules thatâ€™ve been unloaded),
such probes are marked with [GONE]. If the probe is temporarily disabled,
such probes are marked with [DISABLED]. If the probe is optimized, it is
marked with [OPTIMIZED]. If the probe is ftrace-based, it is marked with
[FTRACE].
-->
<p>ç¬¬ä¸€åˆ—ï¼Œæ˜¯å·²æ’å…¥æŽ¢é’ˆçš„å†…æ ¸åœ°å€ã€‚ç¬¬äºŒåˆ—ï¼Œæ˜¯è¡¨ç¤ºæŽ¢é’ˆçš„ç±»åž‹ï¼ˆk - kprobeï¼Œr - kretprobeï¼‰ã€‚ç¬¬ä¸‰åˆ—ï¼Œæ˜¯æŒ‡å®šæŽ¢é’ˆçš„ç¬¦å·+åç§»é‡ï¼ˆsymbol+offsetï¼‰ã€‚å¦‚æžœè¢«æŽ¢æµ‹çš„å‡½æ•°å±žäºŽä¸€ä¸ªæ¨¡å—ï¼Œé‚£ä¹ˆè¿™ä¸ªæ¨¡å—çš„åå­—ä¹Ÿä¼šè¢«åˆ—å‡ºæ¥ã€‚éšåŽçš„å‡ åˆ—æ˜¾ç¤ºæŽ¢é’ˆçš„çŠ¶æ€ã€‚å¦‚æžœæŽ¢é’ˆåœ¨è™šæ‹Ÿåœ°å€ä¸Šï¼Œå¹¶ä¸”åœ°å€æ— æ•ˆï¼ˆæ¨¡å—åˆå§‹åŒ–éƒ¨åˆ†ï¼Œæ¨¡å—è™šæ‹Ÿåœ°å€ï¼Œå¯¹åº”çš„æ¨¡å—å·²ç»å¸è½½ï¼‰ï¼Œè¿™ç±»æŽ¢é’ˆä¼šè¢«æ ‡è®°ä¸º [GONE]ã€‚å¦‚æžœæŽ¢é’ˆä¸´æ—¶è¢«ç¦ç”¨ï¼Œä¼šè¢«æ ‡è®°ä¸º [DISABLED]ã€‚å¦‚æžœæŽ¢é’ˆè¢«ä¼˜åŒ–äº†ï¼Œä¼šè¢«æ ‡è®°ä¸º [OPTIMIZED]ã€‚å¦‚æžœæŽ¢é’ˆæ˜¯åŸºäºŽ ftrace çš„ï¼Œä¼šè¢«æ ‡è®°ä¸º [FTRACE]ã€‚</p>
<!--
/sys/kernel/debug/kprobes/enabled: Turn kprobes ON/OFF forcibly.
-->
<p><code>/sys/kernel/debug/kprobes/enabled</code>ï¼šå¼ºåˆ¶å¼€å¯/å…³é—­ kprobesã€‚</p>
<!--
Provides a knob to globally and forcibly turn registered kprobes ON or OFF.
By default, all kprobes are enabled. By echoing â€œ0â€ to this file, all
registered probes will be `disarmed`, till such time a â€œ1â€ is echoed to this
file. Note that this knob just disarms and arms all kprobes and doesnâ€™t
change each probeâ€™s disabling state. This means that disabled kprobes (marked
[DISABLED]) will be not enabled if you turn ON all kprobes by this knob.
-->
<p>æä¾›ä¸€ä¸ªå…¨å±€æŒ‰é’®ï¼Œå¼ºåˆ¶çš„å¼€å¯æˆ–å…³é—­å·²æ³¨å†Œçš„ kprobesã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ‰€æœ‰ kprobes æ˜¯å¼€å¯çš„ã€‚è¾“å‡º â€œ0â€ åˆ°è¿™ä¸ªæ–‡ä»¶ï¼Œæ‰€æœ‰å·²æ³¨å†Œçš„æŽ¢é’ˆä¼šè¢«å¸è½½ï¼Œè¾“å‡º â€œ1â€ åˆ°è¿™ä¸ªæ–‡ä»¶ï¼Œåˆé‡æ–°åŠ è½½ã€‚è¯·æ³¨æ„ï¼Œè¿™ä¸ªæŒ‰é’®åªæ˜¯å¸è½½å’ŒåŠ è½½æ‰€æœ‰ kprobesï¼Œå¹¶ä¸ä¼šæ”¹å˜æ¯ä¸ªæŽ¢é’ˆçš„ç¦ç”¨çŠ¶æ€ã€‚æ„æ€æ˜¯ï¼Œå·²ç»ç¦ç”¨çš„æŽ¢é’ˆï¼ˆæ ‡è®°ä¸º [DISABLED]ï¼‰æ˜¯ä¸ä¼šè¢«æ¿€æ´»çš„ã€‚</p>
<!--
The kprobes sysctl interface
============================
/proc/sys/debug/kprobes-optimization: Turn kprobes optimization ON/OFF.

When CONFIG_OPTPROBES=y, this sysctl interface `appears` and it provides
a knob to globally and forcibly turn jump optimization (see section
:ref:`kprobes_jump_optimization`) ON or OFF. By default, jump optimization
is allowed (ON). If you echo â€œ0â€ to this file or set
â€œdebug.kprobes_optimizationâ€ to 0 via sysctl, all optimized probes will be
unoptimized, and any new probes registered after that will not be optimized.

Note that this knob changes the optimized state. This means that optimized
probes (marked [OPTIMIZED]) will be unoptimized ([OPTIMIZED] tag will be
removed). If the knob is turned on, they will be optimized again.
-->
<h2 id="kprobes-sysctl-æŽ¥å£">kprobes sysctl æŽ¥å£</h2>
<p><code>/proc/sys/debug/kprobes-optimization</code>ï¼š kprobes ä¼˜åŒ–å¼€å…³ã€‚</p>
<p>åœ¨ <code>CONFIG_OPTPROBES=y</code> çš„æ—¶å€™ï¼Œ <code>sysctl</code> æŽ¥å£æä¾›ä¸€ä¸ªå…¨å±€æŒ‰é’®ï¼Œå¼ºåˆ¶çš„å¼€å¯æˆ–å…³é—­è·³è½¬ä¼˜åŒ–ï¼ˆæŸ¥çœ‹è·³è½¬ç« èŠ‚ï¼‰ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè·³è½¬ä¼˜åŒ–æ˜¯å¼€å¯çš„ã€‚å¦‚æžœè¾“å‡º â€œ0â€ åˆ°è¿™ä¸ªæ–‡ä»¶æˆ–è€…é€šè¿‡ <code>sysctl</code> è®¾ç½® <code>debug.kprobes_optimization</code> ä¸º 0 ï¼Œæ‰€æœ‰ä¼˜åŒ–çš„æŽ¢é’ˆå°†ä¼šå˜æˆæœªä¼˜åŒ–çš„ï¼Œè€Œä¸”åœ¨è¿™ä¹‹åŽä»»ä½•æ–°çš„è¢«æ³¨å†Œçš„æŽ¢é’ˆéƒ½ä¸ä¼šè¢«ä¼˜åŒ–ã€‚</p>
<p>æ³¨æ„ï¼Œè¿™ä¸ªæŒ‰é’®ä¼šæ”¹å˜ä¼˜åŒ–çŠ¶æ€ã€‚è¡¨ç¤ºå·²ä¼˜åŒ–çš„æŽ¢é’ˆï¼ˆæ ‡è®°ä¸º [OPTIMIZED]ï¼‰å°†å˜æˆæœªä¼˜åŒ–çš„ï¼ˆæ ‡è®° [OPTIMIZED] ä¼šè¢«ç§»é™¤ï¼‰ã€‚å¦‚æžœæŒ‰é’®è¢«æ‰“å¼€ï¼ŒæŽ¢é’ˆå°†å†æ¬¡è¢«ä¼˜åŒ–ã€‚</p>
<div class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn:1" role="doc-endnote">
<p>æœ‰éƒ¨åˆ†å†…æ ¸ä»£ç æ˜¯ä¸èƒ½è¢«æ•èŽ·çš„ï¼Œè¯¦æƒ…è§<a href="#%E9%BB%91%E5%90%8D%E5%8D%95">é»‘åå•</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>è¯·æƒ³è±¡ç¬¬äºŒä¸ªæŒ‡ä»¤è¢«ä¸­æ–­ï¼Œç„¶åŽä¼˜åŒ–å™¨åœ¨ä¸­æ–­å›žè°ƒå‡½æ•°æ­£åœ¨è¿è¡Œçš„æ—¶å€™ç”¨è·³è½¬åœ°å€æ›¿æ¢å®ƒã€‚å½“ä¸­æ–­è¿”å›žåˆ°åŽŸå§‹åœ°å€æ—¶ï¼Œæ²¡æœ‰æœ‰æ•ˆæŒ‡ä»¤ï¼Œè¿™ä¼šå¯¼è‡´ä¸€ä¸ªæ„å¤–çš„ç»“æžœã€‚ <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>ä¼˜åŒ–å®‰å…¨æ£€æŸ¥åœ¨ ksplice ç”¨äºŽæ”¯æŒ <code>CONFIG_PREEMPT=y</code> å†…æ ¸ä¸Šå¯ä»¥ç”¨ stop-machine æ–¹æ³•æ›¿æ¢ã€‚ <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    </article>
    
    
<script defer src="/public/js/clipboard.min.1626706afc88d95ebe1173b553ec732c6dc82a576989315fdf5e7779af738a44.js"></script>

<script defer src="/public/js/helper/prev.min.js"></script>

<script defer src="/public/js/helper/prop.min.js"></script>
<script>
  'use strict';
  document.addEventListener('DOMContentLoaded', function () {
    
    var clipInit = false;
    var preChromaElem = document.querySelectorAll('pre.chroma');
    var langCodeElem = document.querySelectorAll('.language-code');
    var dollarCodeElem = document.querySelectorAll('div.language-\\$');
    var gtCodeElem = document.querySelectorAll('div.language-\\>');

    var makeClipboard = function(elem) {
      var code = elem,
          text = elem.textContent;
        
      if (text.length > 15) {
        if (!clipInit) {
          var text, clip = new ClipboardJS('.copy-to-clipboard', {
            text: function (trigger) {
              var codeElem = prev(trigger).querySelectorAll('code');
              if (codeElem.length > 1) {
                text = prev(trigger).querySelector('code[class^="language-"]').textContent;
              } else {
                text = prev(trigger).querySelector('code').textContent;
              }

              return text.replace(/^\$\s/gm, '');
            }
          });

          var inPre;
          clip.on('success', function (e) {
            e.clearSelection();
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', 'Copied to clipboard!');
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clip.on('error', function (e) {
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', e.action.toString());
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clipInit = true;
        }

        var notAllowedClass = ['language-mermaid', 'language-viz', 'language-wave', 'language-chart', 'language-msc', 'language-flowchart'];
        var isNotAllowedIncluded = false;
        var curClassName = code.getAttribute('class');

        for (var i = 0; i < notAllowedClass.length; i++) {
          if (curClassName && curClassName.startsWith(notAllowedClass[i])) {
            isNotAllowedIncluded = true;
            break;
          }
        }

        if (!isNotAllowedIncluded) {
          if (curClassName) {
            var newClipboardElem = document.createElement('span');
            newClipboardElem.setAttribute('class', 'copy-to-clipboard');
            newClipboardElem.setAttribute('title', 'Copy to clipboard');
            elem.parentNode.parentNode.insertBefore(newClipboardElem, elem.parentNode.nextElementSibling);
          }
        }
      }
    }

    var makeSymbolClipboard = function(elem) {
      var clipboardSpan = document.createElement('span');
      clipboardSpan.setAttribute('class', 'copy-to-clipboard');
      clipboardSpan.setAttribute('title', 'Copy to clipboard');
      elem.parentNode.parentNode.insertBefore(clipboardSpan, elem.parentNode.nextElementSibling);
    }

    preChromaElem ? 
    preChromaElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function(codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;
    
    langCodeElem ? 
    langCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;

    dollarCodeElem ? 
    dollarCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;

    gtCodeElem ?
    gtCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;
    
  });
</script>
    <script>
  'use strict';
  
  function wrap(el, wrapper) {
    el.parentNode.insertBefore(wrapper, el);
    wrapper.appendChild(el);
  }

  (function () {
    var singleContentsElem = document.querySelector('.single__contents');
    singleContentsElem ? 
    singleContentsElem.querySelectorAll('pre > code').forEach(function(elem) {
      var dataLang = elem.getAttribute('data-lang');
      var dataLangWrapper = document.createElement('div');
      var code = null;
      var codeTitle = null;

      if (dataLang && dataLang.includes(':')) {
        code = dataLang.split(':')[0];
        codeTitle = dataLang.split(':')[1];

        dataLangWrapper.className = 'language-' + code;
        dataLangWrapper.setAttribute('data-lang', codeTitle);

        elem.className = 'language-' + code;
        elem.setAttribute('data-lang', codeTitle);
        elem.setAttribute('id', codeTitle);
      } else if (!dataLang) {
        dataLangWrapper.setAttribute('data-lang', 'Code');
        dataLangWrapper.className = 'language-code';
      }

      if (!dataLang || codeTitle) {
        wrap(elem.parentNode, dataLangWrapper);
      }

    }) : null;
  })();

  var langCodeElem = document.querySelectorAll('.language-code');
  langCodeElem ? langCodeElem.forEach(function (elem) {
    var newElem = document.createElement('span');
    newElem.className = 'copy-to-clipboard';
    newElem.setAttribute('title', 'Copy to clipboard');
    elem.append(newElem);
  }) : null;
  

  

  
  var dollarCodeElem = document.querySelectorAll('div.language-\\$');
  var gtCodeElem = document.querySelectorAll('div.language-\\>');

  dollarCodeElem ?
  dollarCodeElem.forEach(function(elem) {
    var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
    lnts ? 
    lnts.forEach(function(lnt) {
      lnt.innerHTML = '$<br/>';
    }) : null;
  }) : null;

  gtCodeElem ?
  gtCodeElem.forEach(function(elem) {
    var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
    lnts ? 
    lnts.forEach(function(lnt) {
      lnt.innerHTML = '><br/>';
    }) : null;
  }) : null;
  
</script>
    
    
    

    <section class="related">
    
    
    <h1 class="related__title">
      <hr class="hr-dots"/>
      <div>
        See Also
      </div>
      <hr class="hr-dots"/>
    </h1>
    <ul class="related-ul">
        
        <li>
          <a href="/public/posts/trace/an-introduction-to-kprobes/" class="related__link">è¯‘ï½œ2005ï½œ An Introduction to Kprobes</a>
        </li>
        
    </ul>
    
  </section>
    <div class="grow"></div>
<nav class="pagination-single">
  
    
      <a href="https://jayce.github.io/public/posts/trace/an-introduction-to-kprobes/" class="pagination-single__left">
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z"/></svg>
        </div>
        <div class="pagination-single__left-title">è¯‘ï½œ2005ï½œ An Introduction to Kprobes</div>      
      </a>
    
    <div class="grow"></div>
    
      <a href="https://jayce.github.io/public/posts/trace/user-space-probes/" class="pagination-single__right">      
        <div class="pagination-single__right-title">è¯‘ï½œ2008ï½œUser-Space Probes (Uprobes)</div>
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M5 13h11.17l-4.88 4.88c-.39.39-.39 1.03 0 1.42.39.39 1.02.39 1.41 0l6.59-6.59c.39-.39.39-1.02 0-1.41l-6.58-6.6c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41L16.17 11H5c-.55 0-1 .45-1 1s.45 1 1 1z"/></svg>
        </div>
      </a>
    
  
</nav>
    
  

    <div class="modal micromodal-slide" id="modal" aria-hidden="true">
  <div class="modal__overlay" tabindex="-1" data-micromodal-close>
    <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      
      <div class="modal__content" id="modal-content">
        <div id="mySwipe" class="swipe">
          <div class="swipe-wrap">
          </div>
        </div>
      </div>

      <span class="modal__items">
        
        <span class="modal__header">
          <div class="modal__paging" title="Page Info" aria-label="Current Page">
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--close" title="Close" aria-label="Close Button" data-micromodal-close>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="25" height="25"><path fill="currentColor" d="M 21.734375 19.640625 L 19.636719 21.734375 C 19.253906 22.121094 18.628906 22.121094 18.242188 21.734375 L 13 16.496094 L 7.761719 21.734375 C 7.375 22.121094 6.746094 22.121094 6.363281 21.734375 L 4.265625 19.640625 C 3.878906 19.253906 3.878906 18.628906 4.265625 18.242188 L 9.503906 13 L 4.265625 7.761719 C 3.882813 7.371094 3.882813 6.742188 4.265625 6.363281 L 6.363281 4.265625 C 6.746094 3.878906 7.375 3.878906 7.761719 4.265625 L 13 9.507813 L 18.242188 4.265625 C 18.628906 3.878906 19.257813 3.878906 19.636719 4.265625 L 21.734375 6.359375 C 22.121094 6.746094 22.121094 7.375 21.738281 7.761719 L 16.496094 13 L 21.734375 18.242188 C 22.121094 18.628906 22.121094 19.253906 21.734375 19.640625 Z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--full" title="Full Screen" aria-label="Full Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="25" height="25"><path fill="currentColor" d="M 5 3 C 3.9069372 3 3 3.9069372 3 5 L 3 8 A 1.0001 1.0001 0 1 0 5 8 L 5 5 L 8 5 A 1.0001 1.0001 0 1 0 8 3 L 5 3 z M 16 3 A 1.0001 1.0001 0 1 0 16 5 L 19 5 L 19 8 A 1.0001 1.0001 0 1 0 21 8 L 21 5 C 21 3.9069372 20.093063 3 19 3 L 16 3 z M 3.984375 14.986328 A 1.0001 1.0001 0 0 0 3 16 L 3 19 C 3 20.093063 3.9069372 21 5 21 L 8 21 A 1.0001 1.0001 0 1 0 8 19 L 5 19 L 5 16 A 1.0001 1.0001 0 0 0 3.984375 14.986328 z M 19.984375 14.986328 A 1.0001 1.0001 0 0 0 19 16 L 19 19 L 16 19 A 1.0001 1.0001 0 1 0 16 21 L 19 21 C 20.093063 21 21 20.093063 21 19 L 21 16 A 1.0001 1.0001 0 0 0 19.984375 14.986328 z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--normal" title="Normal Screen" aria-label="Normal Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="25" height="25"><path fill="currentColor" d="M 16.96875 4.972656 C 15.867188 4.988281 14.984375 5.894531 15 7 L 15 15 L 7 15 C 6.277344 14.988281 5.609375 15.367188 5.246094 15.992188 C 4.878906 16.613281 4.878906 17.386719 5.246094 18.007813 C 5.609375 18.632813 6.277344 19.011719 7 19 L 19 19 L 19 7 C 19.007813 6.460938 18.796875 5.941406 18.414063 5.558594 C 18.03125 5.175781 17.511719 4.964844 16.96875 4.972656 Z M 32.96875 4.972656 C 31.921875 4.988281 31.0625 5.8125 31.003906 6.859375 C 31 6.90625 31 6.953125 31 7 L 31 19 L 43 19 C 43.066406 19 43.132813 19 43.199219 18.992188 C 44.269531 18.894531 45.070313 17.972656 45.015625 16.902344 C 44.964844 15.828125 44.074219 14.988281 43 15 L 35 15 L 35 7 C 35.007813 6.460938 34.796875 5.941406 34.414063 5.558594 C 34.03125 5.175781 33.511719 4.964844 32.96875 4.972656 Z M 7 31 C 6.277344 30.988281 5.609375 31.367188 5.246094 31.992188 C 4.878906 32.613281 4.878906 33.386719 5.246094 34.007813 C 5.609375 34.632813 6.277344 35.011719 7 35 L 15 35 L 15 43 C 14.988281 43.722656 15.367188 44.390625 15.992188 44.753906 C 16.613281 45.121094 17.386719 45.121094 18.007813 44.753906 C 18.632813 44.390625 19.011719 43.722656 19 43 L 19 31 Z M 31 31 L 31 43 C 30.988281 43.722656 31.367188 44.390625 31.992188 44.753906 C 32.613281 45.121094 33.386719 45.121094 34.007813 44.753906 C 34.632813 44.390625 35.011719 43.722656 35 43 L 35 35 L 43 35 C 43.722656 35.011719 44.390625 34.632813 44.753906 34.007813 C 45.121094 33.386719 45.121094 32.613281 44.753906 31.992188 C 44.390625 31.367188 43.722656 30.988281 43 31 Z"/></svg>
          </div>
        </span>
        
        <div class="modal__icon modal__arrow modal__arrow--left" title="Arrow Left" aria-label="Arrow Left Button">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 23.28125 11 L 10 10 L 10 6.851563 C 10 6.523438 9.839844 6.277344 9.519531 6.03125 C 9.199219 5.949219 8.878906 5.949219 8.640625 6.113281 C 5.359375 8.410156 2.238281 12.257813 2.160156 12.421875 C 2.082031 12.578125 2.007813 12.8125 2.003906 12.976563 C 2.003906 12.980469 2 12.988281 2 12.992188 C 2 13.15625 2.078125 13.402344 2.160156 13.484375 C 2.238281 13.648438 5.28125 17.507813 8.640625 19.804688 C 8.960938 19.96875 9.28125 20.050781 9.519531 19.886719 C 9.839844 19.722656 10 19.476563 10 19.148438 L 10 16 L 23.28125 15 C 23.679688 14.679688 24 13.875 24 12.992188 C 24 12.195313 23.761719 11.320313 23.28125 11 Z"/></svg>
        </div>
        
        <div class="modal__icon modal__arrow modal__arrow--right" title="Arrow Right" aria-label="Arrow Right Button">

          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 2.71875 11.023438 L 16 10.023438 L 16 6.875 C 16 6.546875 16.160156 6.300781 16.480469 6.054688 C 16.800781 5.972656 17.121094 5.972656 17.359375 6.136719 C 20.640625 8.433594 23.761719 12.28125 23.839844 12.445313 C 23.917969 12.601563 23.992188 12.835938 23.996094 13 C 23.996094 13.003906 24 13.011719 24 13.015625 C 24 13.179688 23.921875 13.425781 23.839844 13.507813 C 23.761719 13.671875 20.71875 17.53125 17.359375 19.828125 C 17.039063 19.992188 16.71875 20.074219 16.480469 19.910156 C 16.160156 19.746094 16 19.5 16 19.171875 L 16 16.023438 L 2.71875 15.023438 C 2.320313 14.703125 2 13.898438 2 13.015625 C 2 12.21875 2.238281 11.34375 2.71875 11.023438 Z"/></svg>
        </div>

        <div class="modal__caption">
          <div class="modal__caption--text">
          </div>
        </div>

      </span>
    </div>
  </div>
</div>


<script defer src="/public/js/swipe.min.b4b82839155519d9ca67746615a4c86ccbc1061c196fe6d8aa26e4fe22902718.js"></script>

<script defer src="/public/js/micromodal.min.de01b44b2f383056bbcaf6ee921fd385d79108ec1129afd0eb2f3f5a07e11f45.js"></script>

<script defer src="/public/js/helper/fadeinout.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
  
   
  var docElem = document.documentElement;

   
  function openFullscreen() {
    if (docElem.requestFullscreen) {
      docElem.requestFullscreen();
    } else if (docElem.mozRequestFullScreen) {  
      docElem.mozRequestFullScreen();
    } else if (docElem.webkitRequestFullscreen) {  
      docElem.webkitRequestFullscreen();
    } else if (docElem.msRequestFullscreen) {  
      docElem.msRequestFullscreen();
    }
  }

   
  function closeFullscreen() {
    if (document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {  
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {  
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {  
        document.msExitFullscreen();
      }
    }
  }

  var modal = document.getElementById('modal');
  var galleryContainerElem = document.querySelector('.gallery__container');
  var swipeWrapElem = document.querySelector('.swipe-wrap');
  var mySwipeElem = document.getElementById('mySwipe');
  var arrowLeftElem = document.querySelector('.modal__arrow--left');
  var arrowRightElem = document.querySelector('.modal__arrow--right');
  var closeElem = document.querySelector('.modal__toolbar--close');
  var fullElem = document.querySelector('.modal__toolbar--full');
  var normalElem = document.querySelector('.modal__toolbar--normal');
  var captionElem = document.querySelector('.modal__caption');
  var pagingElem = document.querySelector('.modal__paging');
  var itemsElem = document.querySelector('.modal__items');
  var imgTotalNum = null;
  var myFadeTimeout = null;
  var mySwipe = null;
  var keydownFunction = function (e) {
    if (e.key === 'ArrowRight') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.next();
      }
    } else if (e.key === 'ArrowLeft') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.prev();
      }
    }
  }

  if (galleryContainerElem) {
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  } else {
    galleryContainerElem = document.querySelector('.single__contents');
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  }

  MicroModal.init({
    onClose: function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
        closeFullscreen();
      }
      window.removeEventListener('keydown', keydownFunction);
    },
    disableScroll: true,
    disableFocus: true,
    awaitOpenAnimation: false,
    awaitCloseAnimation: false,
    debugMode: false,
  });

  var imageLoad = function(src) {
    return new Promise(function(resolve, reject) {
      var newImg = new Image;
      newImg.onload = function() {
        resolve(newImg);
      }
      newImg.onerror = reject;
      newImg.src = src;
    });
  }

  galleryContainerElem.querySelectorAll('img').forEach(function (elem, idx) {
    elem.style.cursor = 'pointer';

    var clonedElem = elem.cloneNode(true);
    clonedElem.style.maxHeight = '100%';
    clonedElem.style.maxWidth = '100%';
    clonedElem.onclick = function (e) {
      e.stopPropagation();
    }

    var wrapper = document.createElement('div');
    wrapper.style.width = '100%';
    wrapper.style.height = '100vh';
    wrapper.setAttribute('data-micromodal-close', '');
    wrapper.onclick = function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
    }
    wrapper.onmouseenter = function () {
      clearTimeout(myFadeTimeout);
      fadeIn(itemsElem, 200);
    };
    wrapper.onmouseleave = function () {
      myFadeTimeout = setTimeout(function () {
        fadeOut(itemsElem, 200);
      }, 2500);
    }
    wrapper.ontouchstart = function() {
      fadeIn(itemsElem, 200);
    }
    wrapper.append(clonedElem);
    swipeWrapElem.append(wrapper);

    elem.addEventListener('click', async function (e) {
      MicroModal.show('modal');
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }

      var imgSrc = e.target.getAttribute('data-src') || e.target.getAttribute('src');
      var img = await imageLoad(imgSrc);
      clonedElem.style.width = img.width + 'px';
      clonedElem.style.height = img.height + 'px';
      
      
      mySwipe = new Swipe(mySwipeElem, {
        startSlide: idx,
        draggable: true,
        autoRestart: false,
        continuous: false,
        disableScroll: true,
        stopPropagation: true,
        callback: async function (index, element) {
          
          var imgElem = element.querySelector('img');
          var imgSrc = imgElem.getAttribute('data-src') || imgElem.getAttribute('src');
          var img = await imageLoad(imgSrc);
          imgElem.style.width = img.width + 'px';
          imgElem.style.height = img.height + 'px';

          
          if (captionElem && imgElem) {
            var caption = null;
            if (imgElem.getAttribute('data-caption')) {
              caption = imgElem.getAttribute('data-caption');
            } else if (imgElem.getAttribute('title')) {
              caption = imgElem.getAttribute('title');
            } else if (imgElem.getAttribute('alt')) {
              caption = imgElem.getAttribute('alt');
            } else {
              caption = imgElem.getAttribute('src');
            }

            captionElem.querySelector('.modal__caption--text').innerText = caption;
            pagingElem.innerText = (index + 1) + ' / ' + imgTotalNum;

            clearTimeout(myFadeTimeout);
            fadeIn(itemsElem, 200);
          }
        },
      });

      fadeIn(itemsElem);

      
      if (captionElem) {
        var caption = null;
        if (e.target.getAttribute('data-caption')) {
          caption = e.target.getAttribute('data-caption');
        } else if (e.target.getAttribute('title')) {
          caption = e.target.getAttribute('title');
        } else if (e.target.getAttribute('alt')) {
          caption = e.target.getAttribute('alt');
        } else {
          caption = e.target.getAttribute('src');
        }

        captionElem.querySelector('.modal__caption--text').innerText = caption;
        pagingElem.innerText = (idx + 1) + ' / ' + imgTotalNum;
      }

      if (normalElem && fullElem) {
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
      }
    });

    window.addEventListener('keydown', keydownFunction);
  });

  arrowLeftElem ?
    arrowLeftElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.prev();
      }
    }) : null;
  arrowRightElem ?
    arrowRightElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.next();
      }
    }) : null;

  closeElem ?
    closeElem.addEventListener('click', function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
      closeFullscreen();
      MicroModal.close('modal');
    }) : null;

  fullElem ?
    fullElem.addEventListener('click', function (e) {
      openFullscreen();
      if (normalElem) {
        normalElem.style.zIndex = 25;
        normalElem.style.opacity = 1;
        fullElem.style.zIndex = -1;
        fullElem.style.opacity = 0;
      }
    }) : null;

  normalElem ?
    normalElem.addEventListener('click', function (e) {
      closeFullscreen();
      if (fullElem) {
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
      }
    }) : null;
  
});
</script>

    <div class="hide">
      

<div class="search">
  <span class="icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M15.5 14h-.79l-.28-.27c1.2-1.4 1.82-3.31 1.48-5.34-.47-2.78-2.79-5-5.59-5.34-4.23-.52-7.79 3.04-7.27 7.27.34 2.8 2.56 5.12 5.34 5.59 2.03.34 3.94-.28 5.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
  </span>
  <input id="search" aria-label="Site Search" class="input" type="text" placeholder="Search" autocomplete="off">
  <div id="search-results" class="dropdown">
    <div id="search-menu" class="dropdown-menu" role="menu">
    </div>
  </div>
</div>


    </div>
  </div>
</main>


<aside class="single__side main-side">
  


<section class="sidebar hide">
  <script>document.querySelector('.sidebar').classList.remove('hide')</script>
  <div class="toc__flexbox" data-position="fixed">
    <h6 class="toc__title" data-ani="true">What&#39;s on this Page</h6>
    
      <label class="switch" data-ani="true">
        <input id="toggle-toc" aria-label="Toggle TOC" type="checkbox" checked>
        <span class="slider round"></span>
      </label>
    
  </div>
  <div class="toc " data-dir="ltr" data-folding="false" data-ani="true">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#è¯‘è€…åº">è¯‘è€…åº</a></li>
    <li><a href="#æ¦‚å¿µ-kprobes-å’Œ-return-probes">æ¦‚å¿µï¼š Kprobes å’Œ Return Probes</a>
      <ul>
        <li><a href="#kprobe-å¦‚ä½•å·¥ä½œ">Kprobe å¦‚ä½•å·¥ä½œï¼Ÿ</a></li>
        <li><a href="#æ”¹å˜æ‰§è¡Œè·¯å¾„">æ”¹å˜æ‰§è¡Œè·¯å¾„</a></li>
        <li><a href="#return-æŽ¢é’ˆ">Return æŽ¢é’ˆ</a>
          <ul>
            <li><a href="#return-æŽ¢é’ˆå¦‚ä½•å·¥ä½œçš„">Return æŽ¢é’ˆå¦‚ä½•å·¥ä½œçš„ï¼Ÿ</a></li>
            <li><a href="#kretprobe-å…¥å£å›žè°ƒå‡½æ•°">Kretprobe å…¥å£å›žè°ƒå‡½æ•°</a></li>
          </ul>
        </li>
        <li><a href="#è·³è½¬ä¼˜åŒ–å¦‚ä½•å·¥ä½œçš„">è·³è½¬ä¼˜åŒ–å¦‚ä½•å·¥ä½œçš„ï¼Ÿ</a>
          <ul>
            <li><a href="#åˆå§‹åŒ–-kprobe">åˆå§‹åŒ– Kprobe</a></li>
            <li><a href="#å®‰å…¨æ£€æŸ¥">å®‰å…¨æ£€æŸ¥</a></li>
            <li><a href="#å‡†å¤‡-detour-ç¼“å†²åŒº">å‡†å¤‡ detour ç¼“å†²åŒº</a></li>
            <li><a href="#ä¼˜åŒ–å‰">ä¼˜åŒ–å‰</a></li>
            <li><a href="#ä¼˜åŒ–">ä¼˜åŒ–</a></li>
            <li><a href="#å–æ¶ˆä¼˜åŒ–">å–æ¶ˆä¼˜åŒ–</a></li>
          </ul>
        </li>
        <li><a href="#é»‘åå•">é»‘åå•</a></li>
      </ul>
    </li>
    <li><a href="#æ”¯æŒçš„æž¶æž„">æ”¯æŒçš„æž¶æž„</a></li>
    <li><a href="#é…ç½®-kprobes">é…ç½® Kprobes</a></li>
    <li><a href="#api-å‚è€ƒ">API å‚è€ƒ</a>
      <ul>
        <li><a href="#register_kprobe">register_kprobe</a></li>
        <li><a href="#register_kretprobe">register_kretprobe</a></li>
        <li><a href="#unregister_probe">unregister_*probe</a></li>
        <li><a href="#register_probes">register_*probes</a></li>
        <li><a href="#unregister_probes">unregister_*probes</a></li>
        <li><a href="#disable_probe">disable_*probe</a></li>
        <li><a href="#enable_probe">enable_*probe</a></li>
      </ul>
    </li>
    <li><a href="#kprobes-ç‰¹æ€§ä¸Žé™åˆ¶">Kprobes ç‰¹æ€§ä¸Žé™åˆ¶</a></li>
    <li><a href="#æŽ¢é’ˆçš„å¼€é”€">æŽ¢é’ˆçš„å¼€é”€</a></li>
    <li><a href="#å·²ä¼˜åŒ–æŽ¢é’ˆå¼€é”€">å·²ä¼˜åŒ–æŽ¢é’ˆå¼€é”€</a></li>
    <li><a href="#todo">TODO</a></li>
    <li><a href="#kprobes-ä¾‹å­">Kprobes ä¾‹å­</a></li>
    <li><a href="#kretprobes-ä¾‹å­">Kretprobes ä¾‹å­</a></li>
    <li><a href="#å·²å¼ƒç”¨çš„æœºåˆ¶">å·²å¼ƒç”¨çš„æœºåˆ¶</a></li>
    <li><a href="#kprobes-debugfs-æŽ¥å£">kprobes debugfs æŽ¥å£</a></li>
    <li><a href="#kprobes-sysctl-æŽ¥å£">kprobes sysctl æŽ¥å£</a></li>
  </ul>
</nav>
  </div>
</section>



</aside>

<script>
  
  
  

  var enableToc = JSON.parse("true");
  var toc = JSON.parse("null");
  var tocPosition = JSON.parse("null");
  
  var singleMainElem = document.querySelector('.single__main');
  var singleSideElem = document.querySelector('.single__side');

  enquire.register("screen and (max-width: 769px)", {
    match: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        if (singleMainElem && singleSideElem) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
          singleSideElem.classList.remove('main-side');
          singleSideElem.classList.add('hide');
        }
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }
    },
    unmatch: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        singleMainElem.classList.remove('main');
        singleMainElem.classList.add('main-main');
        singleSideElem.classList.remove('hide');
        singleSideElem.classList.add('main-side');
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }

      var navCollapseBtn = document.querySelector('.navbar__burger');
      var navCollapse = document.getElementsByClassName('navbarm__collapse')[0];
      if (navCollapse) {
        navCollapse.setAttribute('data-open', false);
        navCollapse.style.maxHeight = 0;
        navCollapseBtn.classList.remove('is-active');
      }
      document.getElementsByClassName('navbar__menu')[0].classList.remove('is-active');
      document.getElementsByClassName('mobile-search')[0].classList.add('hide');
    },
    setup: function () { },
    deferSetup: true,
    destroy: function () { },
  });
</script>




<script defer src="/public/js/helper/getParents.min.js"></script>

<script defer src="/public/js/helper/closest.min.js"></script>

<script defer src="/public/js/helper/prev.min.js"></script>

<script defer src="/public/js/helper/prop.min.js"></script>

<script defer src="/public/js/helper/fadeinout.min.js"></script>

















<script>
  'use strict';

  window.onload = function() {
    var navbar = document.querySelector('.navbar');
    var singleContentsElem = document.querySelector('.single__contents');

    
    
    
    var enableBusuanzi = JSON.parse("false");
    var busuanziPagePV = JSON.parse("true");
    
    if (enableBusuanzi && busuanziPagePV) {
      var pagePvElem = document.querySelector('#busuanzi_value_page_pv');
      pagePvElem.textContent = pagePvElem.textContent.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    }    
    



    
    
    
    
    
    
    var enableToc = JSON.parse("true");
    var toc = JSON.parse("null");
    var hideToc = JSON.parse("false");
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var tocFolding = JSON.parse("null");
    
    if ((enableToc || toc) && document.querySelector('.toc')) {
      var tableOfContentsElem = document.querySelector('.toc').querySelector('#TableOfContents');

      tableOfContentsElem.onmouseenter = function() {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      tableOfContentsElem.onmouseleave = function() {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.add('scrolling');
        }
      }

      if (false === tocFolding) {

      } else {
        tableOfContentsElem.querySelectorAll('ul') ?
          tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
            rootUl.querySelectorAll('li').forEach(function (liElem) {
              liElem.querySelectorAll('ul').forEach(function (ulElem) {
                ulElem.style.display = 'none';
              });
            });
          }) : null;
      }

      if (tableOfContentsElem) {
        if (tableOfContentsElem.querySelectorAll('a').length > 0) {
          tableOfContentsElem.querySelectorAll('a').forEach(function (elem) {
            elem.addEventListener('click', function () {
              var id = elem.getAttribute('id');

              if (!navbar.classList.contains('scrolling')) {
                navbar.classList.remove('navbar--show');
                navbar.classList.remove('navbar--hide');
                navbar.classList.add('navbar--hide');
              }
              
              document.querySelector('.toc').querySelectorAll('a').forEach(function (elem) {
                elem.classList.remove('active');
              });
              elem.classList.add('active');

              var curElem = tableOfContentsElem.querySelector('[href="#' + id + '"]');
              if (curElem && curElem.nextElementSibling) {
                curElem.nextElementSibling.style.display = 'block';
              }
              if (curElem) {
                getParents(curElem, 'ul') ?
                  getParents(curElem, 'ul').forEach(function (elem) {
                    elem.style.display = 'block';
                  }) : null;
              }
            });
          });
        } else {
          if (tocFlexbox) {
            tocFlexbox.setAttribute('data-position', '');
            if (!tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
          }
          if (tocFlexboxOuter) {
            tocFlexboxOuter.setAttribute('data-position', '');
            if (!tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
        }
      }

      
      var toggleTocElem = document.getElementById("toggle-toc");
      var visibleTocElem = document.getElementById('visible-toc');
      var tocElem = document.querySelector('.toc');
      var mainElem = document.querySelector('main');
      var sideElem = document.querySelector('side');
      var tocFlexboxElem = document.querySelector('.toc__flexbox');

      toggleTocElem ? 
      toggleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'fixed');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main-main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'absolute');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        }
      }) : null;

      visibleTocElem ?
      visibleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
        }
      }) : null;
    }
    



    
    var text, clip = new ClipboardJS('.anchor');
    var headers = singleContentsElem.querySelectorAll("h1, h2, h3, h4");

    
    var languagedir = JSON.parse("\"ltr\"");

    headers ? 
    headers.forEach(function (elem) {
      var size = parseInt(elem.tagName.substr(1), 10) * 2;
      var url = encodeURI(document.location.origin + document.location.pathname);
      var link = url + "#" + elem.getAttribute('id');
      var newElemOuter = document.createElement('span');
      newElemOuter.classList.add('anchor');
      newElemOuter.classList.add('hide');
      newElemOuter.setAttribute('data-clipboard-text', link);
      newElemOuter.style.position = 'relative';

      var newElemInner = document.createElement('span');
      newElemInner.style.position = 'absolute';
      newElemInner.style.top = '50%';
      newElemInner.style.left = '0.75rem';
      newElemInner.style.transform = 'translateY(-50%)';
      newElemInner.innerHTML = `
<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="${32 - size}px" height="${32 - size}px"><path d="M 5.5625 0 C 4.136719 0 2.707031 0.542969 1.625 1.625 C -0.539063 3.789063 -0.539063 7.335938 1.625 9.5 L 5.28125 13.15625 C 5.667969 13.554688 6.304688 13.558594 6.703125 13.171875 C 7.101563 12.785156 7.105469 12.148438 6.71875 11.75 L 3.03125 8.0625 C 1.632813 6.664063 1.632813 4.429688 3.03125 3.03125 C 4.429688 1.632813 6.664063 1.632813 8.0625 3.03125 L 12.96875 7.9375 C 14.367188 9.335938 14.367188 11.570313 12.96875 12.96875 C 12.804688 13.132813 12.621094 13.25 12.4375 13.375 C 11.980469 13.6875 11.859375 14.308594 12.171875 14.765625 C 12.484375 15.222656 13.105469 15.34375 13.5625 15.03125 C 13.847656 14.835938 14.125 14.625 14.375 14.375 C 16.539063 12.210938 16.539063 8.664063 14.375 6.5 L 9.5 1.625 C 8.417969 0.542969 6.988281 0 5.5625 0 Z M 10.78125 8.875 C 10.738281 8.882813 10.695313 8.894531 10.65625 8.90625 C 10.507813 8.9375 10.371094 9 10.25 9.09375 C 10.039063 9.253906 9.820313 9.429688 9.625 9.625 C 7.460938 11.789063 7.460938 15.335938 9.625 17.5 L 14.5 22.375 C 16.664063 24.539063 20.210938 24.539063 22.375 22.375 C 24.539063 20.210938 24.539063 16.664063 22.375 14.5 L 18.71875 10.875 C 18.476563 10.578125 18.089844 10.441406 17.714844 10.527344 C 17.34375 10.613281 17.050781 10.90625 16.964844 11.277344 C 16.878906 11.652344 17.015625 12.039063 17.3125 12.28125 L 20.96875 15.9375 C 22.367188 17.335938 22.367188 19.570313 20.96875 20.96875 C 19.570313 22.367188 17.335938 22.367188 15.9375 20.96875 L 11.03125 16.0625 C 9.632813 14.664063 9.632813 12.429688 11.03125 11.03125 C 11.152344 10.90625 11.300781 10.820313 11.4375 10.71875 C 11.839844 10.472656 12.015625 9.976563 11.855469 9.53125 C 11.699219 9.085938 11.25 8.8125 10.78125 8.875 Z"/></svg>`;

      if (languagedir === "rtl") {
        newElemInner.style.left = '-2rem';
      } else {
        newElemInner.style.right = '-2rem';
      }

      newElemOuter.append(newElemInner);
      elem.append(newElemOuter);

      elem.addEventListener('mouseenter', function() {
        this.querySelector('.anchor').classList.remove('hide');
      });
      elem.addEventListener('mouseleave', function () {
        this.querySelector('.anchor').classList.add('hide');
      });
    }) : null;

    document.querySelectorAll('.anchor').forEach(function(elem) {
      elem.addEventListener('mouseleave', function() {
        elem.setAttribute('aria-label', null);
        elem.classList.remove('tooltipped');
        elem.classList.remove('tooltipped-s');
        elem.classList.remove('tooltipped-w');
      });
    });

    clip.on('success', function (e) {
      e.clearSelection();
      e.trigger.setAttribute('aria-label', 'Link copied to clipboard!');
      e.trigger.classList.add('tooltipped');
      e.trigger.classList.add('tooltipped-s');
    });
    // =================================================================



    
    
    var lib = JSON.parse("null");

    if (lib && lib.includes('mermaid')) {
      
      var themeVariant = localStorage.getItem('theme') || JSON.parse("\"light\"");

      if (themeVariant === "dark" || themeVariant === "hacker") {
        mermaid.initialize({ theme: 'dark' });
      } else {
        mermaid.initialize({ theme: 'default' });
      }
      
      var mermaids = [];
      [].push.apply(mermaids, document.getElementsByClassName('language-mermaid'));
      mermaids.forEach(function(elem) {
        var elemParentNode = elem.parentNode;

        if (elemParentNode !== document.body) {
          elemParentNode.parentNode.insertBefore(elem, elemParentNode);
          elemParentNode.parentNode.removeChild(elemParentNode);
        }

        var newElemWrapper = document.createElement('div');
        newElemWrapper.classList.add('mermaid');
        newElemWrapper.style.padding = '34px 4px 6px';
        newElemWrapper.innerHTML = elem.innerHTML;
        elem.replaceWith(newElemWrapper);
      });
    }
    

    

    
    if (lib && lib.includes('katex')) {
      var mathElements = document.getElementsByClassName('math');
      var options = {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\[", right: "\\]", display: true },
          { left: "$", right: "$", display: false },
          { left: "\\(", right: "\\)", display: false }
        ],
      };

      renderMathInElement(document.querySelector('.single__contents'), options);
    }
    



    
    if (lib && lib.includes('flowchartjs')) {
      
      var options = JSON.parse("{\"arrow-end\":\"block\",\"element-color\":\"black\",\"fill\":\"white\",\"flowstate\":{\"approved\":{\"fill\":\"#58C4A3\",\"font-size\":12,\"no-text\":\"n/a\",\"yes-text\":\"APPROVED\"},\"current\":{\"fill\":\"yellow\",\"font-color\":\"red\",\"font-weight\":\"bold\"},\"future\":{\"fill\":\"#FFFF99\"},\"invalid\":{\"fill\":\"#444444\"},\"past\":{\"fill\":\"#CCCCCC\",\"font-size\":12},\"rejected\":{\"fill\":\"#C45879\",\"font-size\":12,\"no-text\":\"REJECTED\",\"yes-text\":\"n/a\"},\"request\":{\"fill\":\"blue\"}},\"font-color\":\"black\",\"font-size\":14,\"line-color\":\"black\",\"line-length\":50,\"line-width\":3,\"no-text\":\"no\",\"scale\":1,\"symbols\":{\"end\":{\"class\":\"end-element\"},\"start\":{\"element-color\":\"green\",\"fill\":\"yellow\",\"font-color\":\"red\"}},\"text-margin\":10,\"x\":0,\"y\":0,\"yes-text\":\"yes\"}");
      var jsonContent = null;

      var flowchartPrefix = "language-flowchart";
      var index = 0;
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + flowchartPrefix + "]"), function(x){
          x.style.display = 'none'
          x.parentNode.style.backgroundColor = "transparent"
          jsonContent = x.innerText;

          var node0 = document.createElement('div');
          node0.id = 'flowchart' + index;
          x.parentNode.insertBefore(node0, x);

          var diagram = flowchart.parse(jsonContent);
          diagram.drawSVG("flowchart"+index, options);

          index +=1;
      });      
    }
    

    

    
    document.querySelectorAll("mjx-container").forEach(function (x) {
      x.parentElement.classList += 'has-jax'
    });
    



    
    if (lib && lib.includes('msc')) {
      
      var options = JSON.parse("{\"theme\":\"hand\"}");
      var jsonContent = null;

      var index = 0;
      var chartPrefix = "language-msc";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        node0.id = 'msc' + index;
        x.parentNode.insertBefore(node0, x);
        var diagram = Diagram.parse(jsonContent);
        diagram.drawSVG("msc" + index, options);
        index += 1;
      });
    }
    



    
    if (lib && lib.includes('chart')) {
      var borderColor = "#666";
      var bgColor = "#ddd";
      var borderWidth = 2;

      Chart.defaults.global.elements.rectangle.borderWidth = borderWidth;
      Chart.defaults.global.elements.rectangle.borderColor = borderColor;
      Chart.defaults.global.elements.rectangle.backgroundColor = bgColor;

      Chart.defaults.global.elements.line.borderWidth = borderWidth;
      Chart.defaults.global.elements.line.borderColor = borderColor;
      Chart.defaults.global.elements.line.backgroundColor = bgColor;

      Chart.defaults.global.elements.point.borderWidth = borderWidth;
      Chart.defaults.global.elements.point.borderColor = borderColor;
      Chart.defaults.global.elements.point.backgroundColor = bgColor;

      var chartPrefix = "language-chart";
      var index = 0;
      var jsonContent = null;

      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('canvas');
        var source = null;
        node0.height = 200;
        node0.style.height = 200;
        node0.id = 'myChart' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        var ctx = document.getElementById('myChart' + index).getContext('2d');
        var myChart = new Chart(ctx, source);
        index += 1;
      });            
    }
    



    
    if (lib && lib.includes('wavedrom')) {
      var wavePrefix = "language-wave";
      var index = 0;
      var jsonContent = null;
      
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + wavePrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        var source = null;
        node0.id = 'WaveDrom_Display_' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        WaveDrom.RenderWaveForm(index, source, "WaveDrom_Display_");
        index += 1;
      });
    }
    



    
    if (lib && lib.includes('viz')) {
      var vizPrefix = "language-viz-";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        var engine;
        x.getAttribute("class").split(" ").forEach(function (cls) {
          if (cls.startsWith(vizPrefix)) {
            engine = cls.substr(vizPrefix.length);
          }
        });
        var viz = new Viz();
        viz.renderSVGElement(x.innerText, { engine: engine })
          .then(function (element) {
            element.style.width = "100%";
            x.parentNode.insertBefore(element, x);
          })
      });
    }
    
    
  }
</script>


            
            <footer class="footer">
    
    
<div class="footer__social">
  <div class="social">
    
            
    
            
    
            
    
            
    
      
      <a href="https://github.com/jayce" title="github" aria-label="github">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 24 24" version="1.1">
<g id="surface3680">
<path fill="currentColor" d="M 10.898438 2.101562 C 6.300781 2.601562 2.601562 6.300781 2.101562 10.800781 C 1.601562 15.5 4.300781 19.699219 8.398438 21.300781 C 8.699219 21.398438 9 21.199219 9 20.800781 L 9 19.199219 C 9 19.199219 8.601562 19.300781 8.101562 19.300781 C 6.699219 19.300781 6.101562 18.101562 6 17.398438 C 5.898438 17 5.699219 16.699219 5.398438 16.398438 C 5.101562 16.300781 5 16.300781 5 16.199219 C 5 16 5.300781 16 5.398438 16 C 6 16 6.5 16.699219 6.699219 17 C 7.199219 17.800781 7.800781 18 8.101562 18 C 8.5 18 8.800781 17.898438 9 17.800781 C 9.101562 17.101562 9.398438 16.398438 10 16 C 7.699219 15.5 6 14.199219 6 12 C 6 10.898438 6.5 9.800781 7.199219 9 C 7.101562 8.800781 7 8.300781 7 7.601562 C 7 7.199219 7 6.601562 7.300781 6 C 7.300781 6 8.699219 6 10.101562 7.300781 C 10.601562 7.101562 11.300781 7 12 7 C 12.699219 7 13.398438 7.101562 14 7.300781 C 15.300781 6 16.800781 6 16.800781 6 C 17 6.601562 17 7.199219 17 7.601562 C 17 8.398438 16.898438 8.800781 16.800781 9 C 17.5 9.800781 18 10.800781 18 12 C 18 14.199219 16.300781 15.5 14 16 C 14.601562 16.5 15 17.398438 15 18.300781 L 15 20.898438 C 15 21.199219 15.300781 21.5 15.699219 21.398438 C 19.398438 19.898438 22 16.300781 22 12.101562 C 22 6.101562 16.898438 1.398438 10.898438 2.101562 Z M 10.898438 2.101562 "/>
</g>
</svg>

      </a>
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
            
    
    
  
  
    
      <a href="https://jayce.github.io/public/posts/index.xml" type="application/rss+xml" title="RSS" aria-label="RSS Feed Link">
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><circle fill="currentColor" cx="6.18" cy="17.82" r="2.18"/><path fill="currentColor" d="M5.59 10.23c-.84-.14-1.59.55-1.59 1.4 0 .71.53 1.28 1.23 1.4 2.92.51 5.22 2.82 5.74 5.74.12.7.69 1.23 1.4 1.23.85 0 1.54-.75 1.41-1.59-.68-4.2-3.99-7.51-8.19-8.18zm-.03-5.71C4.73 4.43 4 5.1 4 5.93c0 .73.55 1.33 1.27 1.4 6.01.6 10.79 5.38 11.39 11.39.07.73.67 1.28 1.4 1.28.84 0 1.5-.73 1.42-1.56-.73-7.34-6.57-13.19-13.92-13.92z"/></svg>
      </a>
    
  


  </div>
</div>

    
<div id="gtt">
  <div class="gtt">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M8.12 14.71L12 10.83l3.88 3.88c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L12.7 8.71c-.39-.39-1.02-.39-1.41 0L6.7 13.3c-.39.39-.39 1.02 0 1.41.39.38 1.03.39 1.42 0z"/></svg>
  </div>
</div>

    <hr />

    <div class="basicflex flexwrap">
        
    </div>

    <div class="footer__poweredby">
        
                
            <p class="caption">
                
                    Â©2020, All Rights Reserved
                
            </p>
        

        
            <p class="caption">Powered by <a href="https://gohugo.io/" target="_blank" rel="noreferrer">Hugo</a> and the <a href="https://github.com/zzossig/hugo-theme-zzo" target="_blank" rel="noreferrer">Zzo theme</a></p>
        
        
    </div> 
</footer>
        </div>
        





<div class="wrapper__right hide" data-pad="true" dir="ltr">
  <script>document.querySelector('.wrapper__right').classList.remove('hide')</script>
  
</div>

    </div>
</body>

</html>